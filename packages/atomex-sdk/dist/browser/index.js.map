{
  "version": 3,
  "sources": ["../../src/atomex/atomex.ts", "../../src/atomex/atomexContext.ts", "../../src/utils/converters.ts", "../../src/native/index.browser.ts", "../../src/utils/guards.ts", "../../src/utils/atomexUtils.ts", "../../src/utils/text.ts", "../../src/utils/index.ts", "../../src/blockchain/signersManager.ts", "../../src/blockchain/controlledCurrencyBalancesProvider.ts", "../../src/blockchain/atomexBlockchainProvider.ts", "../../src/ethereum/utils/index.ts", "../../src/ethereum/signers/web3EthereumSigner.ts", "../../src/ethereum/currencies.ts", "../../src/ethereum/balancesProviders/ethereumBalancesProvider.ts", "../../src/ethereum/swapTransactionsProviders/ethereumSwapTransactionsProvider.ts", "../../src/ethereum/blockchainToolkitProviders/ethereumBlockchainToolkitProvider.ts", "../../src/exchange/helpers/symbolsHelper.ts", "../../src/exchange/exchangeManager.ts", "../../src/common/models/dataSource.ts", "../../src/common/models/importantDataReceivingMode.ts", "../../src/core/eventEmitter.ts", "../../src/exchange/inMemoryExchangeSymbolsProvider.ts", "../../src/swaps/swapManager.ts", "../../src/tezos/walletTezosSigner/beaconWalletTezosSigner.ts", "../../src/tezos/utils/index.ts", "../../src/tezos/utils/signing.ts", "../../src/tezos/walletTezosSigner/templeWalletTezosSigner.ts", "../../src/tezos/walletTezosSigner/walletTezosSigner.ts", "../../src/tezos/inMemoryTezosSigner.ts", "../../src/tezos/currencies.ts", "../../src/tezos/balancesProviders/tezosBalancesProvider.ts", "../../src/tezos/swapTransactionsProviders/tezosSwapTransactionsProvider.ts", "../../src/tezos/blockchainToolkitProviders/tezosBlockchainToolkitProvider.ts", "../../src/clients/rest/httpClient.ts", "../../src/clients/helpers.ts", "../../src/clients/rest/restAtomexClient.ts", "../../src/clients/webSocket/webSocketClient.ts", "../../src/clients/webSocket/exchangeWebSocketClient.ts", "../../src/clients/webSocket/marketDataWebSocketClient.ts", "../../src/clients/webSocket/webSocketAtomexClient.ts", "../../src/clients/mixedAtomexClient.ts", "../../src/atomexBuilder/atomexComponents/exchangeService.ts", "../../src/authorization/models/authTokenSource.ts", "../../src/authorization/authorizationManager.ts", "../../src/browser/localStorageAuthorizationManagerStore/defaultSerializedAuthTokenMapper.ts", "../../src/browser/localStorageAuthorizationManagerStore/multipleKeysStoreStrategy.ts", "../../src/browser/localStorageAuthorizationManagerStore/singleKeyStoreStrategy.ts", "../../src/browser/localStorageAuthorizationManagerStore/localStorageAuthorizationManagerStore.ts", "../../src/stores/inMemoryAuthorizationManagerStore.ts", "../../src/atomexBuilder/atomexComponents/authorizationManager.ts", "../../src/atomexBuilder/atomexConfig.ts", "../../src/atomexBuilder/atomexBuilder.ts", "../../src/atomexBuilder/createDefaultAtomex.ts", "../../src/legacy/index.ts", "../../src/legacy/config.ts", "../../src/legacy/atomex.ts", "../../src/legacy/ethereum.ts", "../../src/legacy/helpers.ts", "../../src/legacy/tezos.ts", "../../src/legacy/fa12.ts", "../../src/legacy/fa2.ts"],
  "sourcesContent": ["import type { AuthorizationManager } from '../authorization/index';\nimport type { Signer, SignersManager } from '../blockchain/index';\nimport type { AtomexService, Currency } from '../common/index';\nimport type { ExchangeManager } from '../exchange/exchangeManager';\nimport type { Swap, SwapManager } from '../swaps/index';\nimport type { AtomexContext } from './atomexContext';\nimport {\n  SwapOperationCompleteStage, AtomexBlockchainOptions,\n  AtomexOptions, NewSwapRequest\n} from './models/index';\n\nexport class Atomex implements AtomexService {\n  readonly authorization: AuthorizationManager;\n  readonly exchangeManager: ExchangeManager;\n  readonly swapManager: SwapManager;\n  readonly signers: SignersManager;\n\n  protected readonly atomexContext: AtomexContext;\n\n  private _isStarted = false;\n\n  constructor(readonly options: AtomexOptions) {\n    this.atomexContext = options.atomexContext;\n    this.signers = options.managers.signersManager;\n    this.authorization = options.managers.authorizationManager;\n    this.exchangeManager = options.managers.exchangeManager;\n    this.swapManager = options.managers.swapManager;\n\n    if (options.blockchains)\n      for (const blockchainName of Object.keys(options.blockchains))\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        this.addBlockchain(_context => options.blockchains![blockchainName]!);\n  }\n\n  get atomexNetwork() {\n    return this.atomexContext.atomexNetwork;\n  }\n\n  get isStarted() {\n    return this._isStarted;\n  }\n\n  async start(): Promise<void> {\n    if (this.isStarted)\n      return;\n\n    await this.authorization.start();\n    await this.exchangeManager.start();\n    await this.swapManager.start();\n\n    this._isStarted = true;\n  }\n\n  stop(): void {\n    if (!this.isStarted)\n      return;\n\n    this.authorization.stop();\n    this.exchangeManager.stop();\n    this.swapManager.stop();\n\n    this._isStarted = false;\n  }\n\n  async addSigner(signer: Signer) {\n    await this.signers.addSigner(signer);\n\n    await this.options.blockchains?.[signer.blockchain]?.mainnet.blockchainToolkitProvider?.addSigner(signer);\n  }\n\n  addBlockchain(factoryMethod: (context: AtomexContext) => AtomexBlockchainOptions) {\n    const blockchainOptions = factoryMethod(this.atomexContext);\n    const networkOptions = this.atomexNetwork == 'mainnet' ? blockchainOptions.mainnet : blockchainOptions.testnet;\n\n    if (networkOptions)\n      this.atomexContext.providers.blockchainProvider.addBlockchain(networkOptions);\n  }\n\n  getCurrency(currencyId: Currency['id']) {\n    return this.atomexContext.providers.currenciesProvider.getCurrency(currencyId);\n  }\n\n  async swap(newSwapRequest: NewSwapRequest, completeStage?: SwapOperationCompleteStage): Promise<Swap | readonly Swap[]>;\n  async swap(swapId: Swap['id'], completeStage?: SwapOperationCompleteStage): Promise<Swap | readonly Swap[]>;\n  async swap(newSwapRequestOrSwapId: NewSwapRequest | Swap['id'], _completeStage = SwapOperationCompleteStage.All): Promise<Swap | readonly Swap[]> {\n    if (typeof newSwapRequestOrSwapId === 'number')\n      throw new Error('Swap tracking is not implemented yet');\n\n    const orderId = await this.exchangeManager.addOrder(newSwapRequestOrSwapId.accountAddress, newSwapRequestOrSwapId);\n    const order = await this.exchangeManager.getOrder(newSwapRequestOrSwapId.accountAddress, orderId);\n    if (!order)\n      throw new Error(`The ${orderId} order not found`);\n\n    if (order.status !== 'Filled')\n      throw new Error(`The ${orderId} order is not filled`);\n\n    const swaps = await Promise.all(order.swapIds.map(swapId => this.swapManager.getSwap(swapId, newSwapRequestOrSwapId.accountAddress)));\n    if (!swaps.length)\n      throw new Error('Swaps not found');\n    if (swaps.some(swap => !swap))\n      throw new Error('Swap not found');\n\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return swaps.length === 1 ? swaps[0]! : (swaps as readonly Swap[]);\n  }\n}\n", "import type { AuthorizationManager } from '../authorization/index';\nimport type { SignersManager, AtomexBlockchainProvider } from '../blockchain/index';\nimport type { AtomexNetwork, CurrenciesProvider } from '../common/index';\nimport type { ExchangeManager, ExchangeService, ManagedExchangeSymbolsProvider } from '../exchange/index';\nimport type { SwapManager, SwapService } from '../swaps/index';\n\nexport class AtomexContext {\n  private static idCounter = 0;\n\n  readonly id: number;\n\n  readonly managers: AtomexContextManagersSection;\n  readonly services: AtomexContextServicesSection;\n  readonly providers: AtomexContextProvidersSection;\n\n  constructor(readonly atomexNetwork: AtomexNetwork) {\n    this.id = AtomexContext.idCounter++;\n\n    this.managers = new AtomexContextManagersSection(this);\n    this.services = new AtomexContextServicesSection(this);\n    this.providers = new AtomexContextProvidersSection(this);\n  }\n}\n\nclass AtomexContextManagersSection {\n  private _signersManager: SignersManager | undefined;\n  private _authorizationManager: AuthorizationManager | undefined;\n  private _exchangeManager: ExchangeManager | undefined;\n  private _swapManager: SwapManager | undefined;\n\n  constructor(readonly context: AtomexContext) {\n  }\n\n  get signersManager(): SignersManager {\n    if (!this._signersManager)\n      throw new AtomexComponentNotResolvedError('managers.signersManager');\n\n    return this._signersManager;\n  }\n\n  private set signersManager(signersManager: SignersManager) {\n    this._signersManager = signersManager;\n  }\n\n  get authorizationManager(): AuthorizationManager {\n    if (!this._authorizationManager)\n      throw new AtomexComponentNotResolvedError('managers.authorizationManager');\n\n    return this._authorizationManager;\n  }\n\n  private set authorizationManager(authorizationManager: AuthorizationManager) {\n    this._authorizationManager = authorizationManager;\n  }\n\n  get exchangeManager(): ExchangeManager {\n    if (!this._exchangeManager)\n      throw new AtomexComponentNotResolvedError('managers.exchangeManager');\n\n    return this._exchangeManager;\n  }\n\n  private set exchangeManager(exchangeManager: ExchangeManager) {\n    this._exchangeManager = exchangeManager;\n  }\n\n  get swapManager(): SwapManager {\n    if (!this._swapManager)\n      throw new AtomexComponentNotResolvedError('managers.swapManager');\n\n    return this._swapManager;\n  }\n\n  private set swapManager(swapManager: SwapManager) {\n    this._swapManager = swapManager;\n  }\n}\n\nclass AtomexContextServicesSection {\n  private _exchangeService: ExchangeService | undefined;\n  private _swapService: SwapService | undefined;\n\n  constructor(readonly context: AtomexContext) {\n  }\n\n  get exchangeService(): ExchangeService {\n    if (!this._exchangeService)\n      throw new AtomexComponentNotResolvedError('services.exchangeService');\n\n    return this._exchangeService;\n  }\n\n  private set exchangeService(exchangeService: ExchangeService) {\n    this._exchangeService = exchangeService;\n  }\n\n  get swapService(): SwapService {\n    if (!this._swapService)\n      throw new AtomexComponentNotResolvedError('services.swapService');\n\n    return this._swapService;\n  }\n\n  private set swapService(swapService: SwapService) {\n    this._swapService = swapService;\n  }\n}\n\nclass AtomexContextProvidersSection {\n  private _blockchainProvider: AtomexBlockchainProvider | undefined;\n  private _currenciesProvider: CurrenciesProvider | undefined;\n  private _exchangeSymbolsProvider: ManagedExchangeSymbolsProvider | undefined;\n\n  constructor(readonly context: AtomexContext) {\n  }\n\n  get blockchainProvider(): AtomexBlockchainProvider {\n    if (!this._blockchainProvider)\n      throw new AtomexComponentNotResolvedError('providers.blockchainProvider');\n\n    return this._blockchainProvider;\n  }\n\n  private set blockchainProvider(blockchainProvider: AtomexBlockchainProvider) {\n    this._blockchainProvider = blockchainProvider;\n  }\n\n  get currenciesProvider(): CurrenciesProvider {\n    if (!this._currenciesProvider)\n      throw new AtomexComponentNotResolvedError('providers.currenciesProvider');\n\n    return this._currenciesProvider;\n  }\n\n  private set currenciesProvider(currenciesProvider: CurrenciesProvider) {\n    this._currenciesProvider = currenciesProvider;\n  }\n\n  get exchangeSymbolsProvider(): ManagedExchangeSymbolsProvider {\n    if (!this._exchangeSymbolsProvider)\n      throw new AtomexComponentNotResolvedError('providers.exchangeSymbolsProvider');\n\n    return this._exchangeSymbolsProvider;\n  }\n\n  private set exchangeSymbolsProvider(exchangeSymbolsProvider: ManagedExchangeSymbolsProvider) {\n    this._exchangeSymbolsProvider = exchangeSymbolsProvider;\n  }\n}\n\nexport class AtomexComponentNotResolvedError extends Error {\n  readonly name: string;\n  readonly componentName: string;\n\n  constructor(componentName: string) {\n    super(AtomexComponentNotResolvedError.getMessage(componentName));\n\n    this.componentName = componentName;\n    this.name = this.constructor.name;\n  }\n\n  private static getMessage(componentName: string) {\n    return `Atomex \"${componentName}\" component has not resolved yet`;\n  }\n}\n", "import BigNumber from 'bignumber.js';\n\nimport { Buffer } from '../native';\n\nexport const hexStringToUint8Array = (hex: string): Uint8Array => {\n  const integers = hex.match(/[\\da-f]{2}/gi)?.map(val => parseInt(val, 16));\n\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n  return new Uint8Array(integers!);\n};\n\nexport const uint8ArrayToHexString = (value: Uint8Array): string => Buffer.from(value).toString('hex');\nexport const stringToHexString = (value: string): string => Buffer.from(value, 'utf8').toString('hex');\nexport const hexStringToString = (value: string): string => Buffer.from(hexStringToUint8Array(value)).toString('utf8');\n\nexport const objectToHexString = (value: Record<string, unknown>): string => stringToHexString(JSON.stringify(value));\nexport const hexStringToObject = <T extends Record<string, unknown> = Record<string, unknown>>(value: string): T | null => {\n  try {\n    return JSON.parse(hexStringToString(value));\n  }\n  catch {\n    return null;\n  }\n};\n\nexport const tokensAmountToNat = (tokensAmount: BigNumber | number, decimals: number): BigNumber => {\n  return new BigNumber(tokensAmount).multipliedBy(10 ** decimals).integerValue();\n};\n\nexport const numberToTokensAmount = (value: BigNumber | number, decimals: number): BigNumber => {\n  return new BigNumber(value).integerValue().div(10 ** decimals);\n};\n\nexport const toFixedBigNumber = (\n  value: BigNumber.Value,\n  decimalPlaces: number,\n  roundingMode?: BigNumber.RoundingMode\n): BigNumber => {\n  value = BigNumber.isBigNumber(value) ? value : new BigNumber(value);\n\n  return new BigNumber((value as BigNumber).toFixed(decimalPlaces, roundingMode));\n};\n", "export { Buffer } from 'buffer';\n", "import isPlainObjectLodashFunction from 'lodash.isplainobject';\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const isArray = (arg: any): arg is any[] => {\n  return Array.isArray(arg);\n};\n\nexport const isReadonlyArray = (arg: unknown): arg is readonly unknown[] => {\n  return Array.isArray(arg);\n};\n\nexport const isPlainObject = <T extends Record<string, unknown> = Record<string, unknown>>(value: unknown): value is T => {\n  return isPlainObjectLodashFunction(value);\n};\n", "import type { AtomexNetwork } from '../common/index';\n\nexport const ensureNetworksAreSame = (\n  value1: { atomexNetwork: AtomexNetwork } | AtomexNetwork,\n  value2: { atomexNetwork: AtomexNetwork } | AtomexNetwork\n) => {\n  if ((typeof value1 === 'string' ? value1 : value1.atomexNetwork) === (typeof value2 === 'string' ? value2 : value2.atomexNetwork))\n    return;\n\n  throw new Error('Networks are different');\n};\n", "export const capitalize = (value: string): string => value && (value[0]?.toLocaleUpperCase() + value.slice(1));\n\nconst stringPad = (string: string, isStart: boolean, maxLength: number, fillString = ' ') => {\n  if (String.prototype.padStart !== undefined)\n    return string.padStart(maxLength, fillString);\n\n  const stringLength = string.length;\n  // eslint-disable-next-line eqeqeq\n  if (maxLength <= stringLength || fillString == '')\n    return string;\n\n  const fillLength = maxLength - stringLength;\n  let filler = fillString.repeat(Math.ceil(fillLength / fillString.length));\n\n  if (filler.length > fillLength)\n    filler = filler.slice(0, fillLength);\n\n  return isStart ? filler + string : string + filler;\n};\n\nexport const padStart = (string: string, maxLength: number, fillString = ' ') => String.prototype.padStart !== undefined\n  ? string.padStart(maxLength, fillString)\n  : stringPad(string, true, maxLength, fillString);\n\nexport const padEnd = (string: string, maxLength: number, fillString = ' ') => String.prototype.padEnd !== undefined\n  ? string.padEnd(maxLength, fillString)\n  : stringPad(string, false, maxLength, fillString);\n", "export * as converters from './converters';\nexport * as guards from './guards';\nexport * as atomexUtils from './atomexUtils';\nexport * as textUtils from './text';\n\nexport const wait = (ms: number) => new Promise<void>(resolve => setTimeout(resolve, ms));\n\nexport const prepareTimeoutDuration = (durationMs: number) => Math.min(durationMs, 0x7FFFFFFF);\n", "import type { AtomexNetwork } from '../common/index';\nimport { atomexUtils } from '../utils/index';\nimport type { Signer } from './signer';\n\nexport class SignersManager {\n  private readonly _signers: Set<Signer> = new Set();\n\n  constructor(readonly atomexNetwork: AtomexNetwork) {\n  }\n\n  protected get signers(): Set<Signer> {\n    return this._signers;\n  }\n\n  addSigner(signer: Signer): Promise<Signer> {\n    atomexUtils.ensureNetworksAreSame(this, signer);\n    this._signers.add(signer);\n\n    return Promise.resolve(signer);\n  }\n\n  async removeSigner(signer: Signer): Promise<boolean>;\n  async removeSigner(address: string, blockchain?: string): Promise<boolean>;\n  async removeSigner(signerOrAddress: Signer | string, blockchain?: string): Promise<boolean> {\n    const signer = typeof signerOrAddress === 'string'\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      ? (await this.findSigner(signerOrAddress, blockchain))\n      : signerOrAddress;\n\n    return signer ? this._signers.delete(signer) : false;\n  }\n\n  async findSigner(address: string, blockchain?: string): Promise<Signer | undefined> {\n    if (!this.signers.size)\n      return undefined;\n\n    const signerAndAddressPromises: Array<Promise<[signer: Signer, address: string]>> = [];\n    for (const signer of this.signers) {\n      if (blockchain && signer.blockchain !== blockchain)\n        continue;\n\n      const addressOrPromise = signer.getAddress();\n      if (typeof addressOrPromise === 'string') {\n        if (addressOrPromise === address)\n          return signer;\n        else\n          continue;\n      }\n\n      signerAndAddressPromises.push(addressOrPromise.then(address => [signer, address]));\n    }\n\n    const signerAndAddressResults = await Promise.allSettled(signerAndAddressPromises);\n    for (const signerAndAddressResult of signerAndAddressResults) {\n      if (signerAndAddressResult.status !== 'fulfilled') {\n        // TODO: warning if status === 'rejected'\n        continue;\n      }\n\n      if (signerAndAddressResult.value[1] === address)\n        return signerAndAddressResult.value[0];\n    }\n\n    return undefined;\n  }\n}\n", "import type { BigNumber } from 'bignumber.js';\n\nimport type { Currency } from '../common/index';\nimport type { CurrencyBalanceProvider } from './currencyBalanceProvider';\n\nexport class ControlledCurrencyBalancesProvider implements CurrencyBalanceProvider {\n  constructor(\n    readonly currency: Currency,\n    protected readonly getBalanceImplementation: (address: string) => Promise<BigNumber>\n  ) { }\n\n  getBalance(address: string): Promise<BigNumber> {\n    return this.getBalanceImplementation(address);\n  }\n}\n", "import type { AtomexBlockchainNetworkOptions } from '../atomex/models/atomexOptions';\nimport type { CurrenciesProvider, Currency } from '../common/index';\nimport type { AtomexProtocol } from './atomexProtocol';\nimport type { BalancesProvider } from './balancesProvider';\nimport type { BlockchainToolkitProvider } from './blockchainToolkitProvider';\nimport { ControlledCurrencyBalancesProvider } from './controlledCurrencyBalancesProvider';\nimport type { CurrencyBalanceProvider } from './currencyBalanceProvider';\nimport type { SwapTransactionsProvider } from './swapTransactionProvider';\n\nexport interface CurrencyInfo {\n  currency: Currency;\n  atomexProtocol: AtomexProtocol | undefined;\n  blockchainToolkitProvider: BlockchainToolkitProvider;\n  balanceProvider: CurrencyBalanceProvider;\n  swapTransactionsProvider: SwapTransactionsProvider;\n}\n\nexport class AtomexBlockchainProvider implements CurrenciesProvider {\n  protected readonly currencyInfoMap: Map<Currency['id'], CurrencyInfo> = new Map();\n\n  addBlockchain(networkOptions: AtomexBlockchainNetworkOptions) {\n    for (const currency of networkOptions.currencies) {\n      if (this.currencyInfoMap.has(currency.id))\n        throw new Error('There is already currency added with the same key');\n\n      const currencyOptions = networkOptions.currencyOptions[currency.id];\n      const options: CurrencyInfo = {\n        currency,\n        atomexProtocol: currencyOptions?.atomexProtocol,\n        blockchainToolkitProvider: networkOptions.blockchainToolkitProvider,\n        balanceProvider: currencyOptions?.currencyBalanceProvider ?? this.createControlledBalancesProvider(currency, networkOptions.balancesProvider),\n        swapTransactionsProvider: currencyOptions?.swapTransactionsProvider ?? networkOptions.swapTransactionsProvider,\n      };\n      this.currencyInfoMap.set(currency.id, options);\n    }\n  }\n\n  getCurrency(currencyId: Currency['id']): Currency | undefined {\n    return this.getCurrencyInfo(currencyId)?.currency;\n  }\n\n  getCurrencyInfo(currencyId: Currency['id']): CurrencyInfo | undefined {\n    const options = this.currencyInfoMap.get(currencyId);\n\n    return options;\n  }\n\n  protected createControlledBalancesProvider(currency: Currency, balancesProvider: BalancesProvider): ControlledCurrencyBalancesProvider {\n    return new ControlledCurrencyBalancesProvider(\n      currency,\n      (address: string) => balancesProvider.getBalance(address, currency)\n    );\n  }\n}\n", "import { ec as EC } from 'elliptic';\n\nimport { Buffer } from '../../native';\nimport { converters } from '../../utils';\nimport { uint8ArrayToHexString } from '../../utils/converters';\n\nlet secp256k1Curve: EC | null = null;\nconst getSecp256k1Curve = () => {\n  if (!secp256k1Curve)\n    secp256k1Curve = new EC('secp256k1');\n\n  return secp256k1Curve;\n};\n\nconst splitSignature = (hexSignature: string): { r: string, s: string, v: number, recoveryParameter: number } => {\n  const signatureBytes = converters.hexStringToUint8Array(hexSignature);\n\n  if (signatureBytes.length !== 64 && signatureBytes.length !== 65)\n    throw new Error(`Invalid signature: ${hexSignature}`);\n\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n  let v = signatureBytes.length === 64 ? 27 + (signatureBytes[32]! >> 7) : signatureBytes[64]!;\n  if (v === 0 || v === 1)\n    v += 27;\n\n  const result = {\n    r: uint8ArrayToHexString(signatureBytes.slice(0, 32)),\n    s: uint8ArrayToHexString(signatureBytes.slice(32, 64)),\n    v,\n    recoveryParameter: 1 - (v % 2)\n  };\n\n  return result;\n};\n\nexport const recoverPublicKey = (hexSignature: string, web3MessageHash: string) => {\n  const splittedSignature = splitSignature(hexSignature);\n\n  const messageBuffer = Buffer.from(web3MessageHash.startsWith('0x') ? web3MessageHash.substring(2) : web3MessageHash, 'hex');\n  const ecPublicKey = getSecp256k1Curve().recoverPubKey(\n    messageBuffer,\n    { r: splittedSignature.r, s: splittedSignature.s },\n    splittedSignature.recoveryParameter,\n  );\n\n  return '0x' + ecPublicKey.encode('hex', false);\n};\n", "import type Web3 from 'web3';\n\nimport type { AtomexSignature, Signer } from '../../blockchain/index';\nimport type { AtomexNetwork } from '../../common/index';\nimport { recoverPublicKey } from '../utils/index';\n\nexport class Web3EthereumSigner implements Signer {\n  static readonly signingAlgorithm = 'Keccak256WithEcdsa:Geth2940';\n\n  readonly blockchain = 'ethereum';\n\n  constructor(\n    readonly atomexNetwork: AtomexNetwork,\n    protected readonly web3: Web3\n  ) {\n  }\n\n  async getAddress(): Promise<string> {\n    const accounts = await this.web3.eth.getAccounts();\n    const address = accounts[0];\n    if (!address)\n      throw new Error('Address is unavailable');\n\n    return address;\n  }\n\n  getPublicKey() {\n    return undefined;\n  }\n\n  async sign(message: string): Promise<AtomexSignature> {\n    const address = await this.getAddress();\n    const signatureBytes = await this.signInternal(message, address);\n    const publicKeyBytes = recoverPublicKey(signatureBytes, this.web3.eth.accounts.hashMessage(message));\n\n    return {\n      address,\n      publicKeyBytes: publicKeyBytes.startsWith('0x') ? publicKeyBytes.substring(2) : publicKeyBytes,\n      signatureBytes: signatureBytes.substring(signatureBytes.startsWith('0x') ? 2 : 0, signatureBytes.length - 2),\n      algorithm: Web3EthereumSigner.signingAlgorithm\n    };\n  }\n\n  protected signInternal(message: string, address: string) {\n    return new Promise<string>((resolve, reject) => this.web3.eth.personal.sign(message, address, '', (error, signature) => {\n      return signature ? resolve(signature) : reject(error);\n    }));\n  }\n}\n", "import type { AtomexBlockchainNetworkOptions } from '../atomex/models/atomexOptions';\nimport type { EthereumCurrency } from './models/currency';\n\nconst ethereumNativeCurrency: EthereumCurrency = {\n  id: 'ETH',\n  name: 'Ethereum',\n  symbol: 'ETH',\n  blockchain: 'ethereum',\n  decimals: 18,\n  type: 'native'\n};\n\nexport const ethereumMainnetCurrencies: AtomexBlockchainNetworkOptions['currencies'] = [\n  ethereumNativeCurrency\n];\n\nexport const ethereumTestnetCurrencies: AtomexBlockchainNetworkOptions['currencies'] = [\n  ethereumNativeCurrency\n];\n", "import type BigNumber from 'bignumber.js';\n\nimport type { BalancesProvider } from '../../blockchain/index';\nimport type { Currency } from '../../index';\n\nexport class EthereumBalancesProvider implements BalancesProvider {\n  getBalance(_address: string, _currency: Currency): Promise<BigNumber> {\n    throw new Error('Method not implemented.');\n  }\n}\n", "import type { SwapTransactionsProvider, Transaction } from '../../blockchain/index';\nimport type { Swap } from '../../index';\n\nexport class EthereumSwapTransactionsProvider implements SwapTransactionsProvider {\n  private _isStarted = false;\n\n  get isStarted() {\n    return this._isStarted;\n  }\n\n  async start() {\n    if (this.isStarted)\n      return;\n\n    this._isStarted = true;\n  }\n\n  stop(): void {\n    if (!this.isStarted)\n      return;\n\n    this._isStarted = false;\n  }\n\n  getSwapTransactions(_swap: Swap): Promise<readonly Transaction[]> {\n    throw new Error('Method not implemented.');\n  }\n}\n", "import type { BlockchainToolkitProvider, Signer } from '../../blockchain/index';\n\nexport class EthereumBlockchainToolkitProvider implements BlockchainToolkitProvider {\n  getReadonlyToolkit(_blockchain: string, _toolkitId: string): Promise<unknown> {\n    throw new Error('Method not implemented.');\n  }\n  getToolkit(_blockchain: string, _address: string, _toolkitId: string): Promise<unknown> {\n    throw new Error('Method not implemented.');\n  }\n  addSigner(_signer: Signer): Promise<boolean> {\n    throw new Error('Method not implemented.');\n  }\n  removeSigner(_signer: Signer): Promise<boolean> {\n    throw new Error('Method not implemented.');\n  }\n}\n", "import BigNumber from 'bignumber.js';\n\nimport type { Currency, Side } from '../../common/index';\nimport { converters, guards } from '../../utils/index';\nimport type { ExchangeSymbol, SymbolCurrency } from '../models/index';\n\nexport const getQuoteBaseCurrenciesBySymbol = (symbol: string): readonly [quoteCurrency: string, baseCurrency: string] => {\n  const [quoteCurrency = '', baseCurrency = ''] = symbol.split('/');\n\n  return [quoteCurrency, baseCurrency];\n};\n\nexport const convertSymbolToFromToCurrenciesPair = (\n  symbol: ExchangeSymbol,\n  side: Side,\n  currencyAmount: BigNumber.Value,\n  quoteCurrencyPrice: BigNumber.Value,\n  isQuoteCurrencyAmount = true\n): readonly [from: SymbolCurrency, to: SymbolCurrency] => {\n  const preparedQuoteCurrencyPrice = converters.toFixedBigNumber(quoteCurrencyPrice, symbol.decimals.price, BigNumber.ROUND_FLOOR);\n  const [quoteCurrencyId, baseCurrencyId] = getQuoteBaseCurrenciesBySymbol(symbol.name);\n\n  let preparedQuoteCurrencyAmount: BigNumber;\n  let preparedBaseCurrencyAmount: BigNumber;\n\n  if (isQuoteCurrencyAmount) {\n    preparedQuoteCurrencyAmount = converters.toFixedBigNumber(currencyAmount, symbol.decimals.quoteCurrency, BigNumber.ROUND_FLOOR);\n    preparedBaseCurrencyAmount = converters.toFixedBigNumber(\n      preparedQuoteCurrencyPrice.multipliedBy(preparedQuoteCurrencyAmount),\n      symbol.decimals.baseCurrency,\n      BigNumber.ROUND_FLOOR\n    );\n  }\n  else {\n    preparedBaseCurrencyAmount = converters.toFixedBigNumber(currencyAmount, symbol.decimals.baseCurrency, BigNumber.ROUND_FLOOR);\n    preparedQuoteCurrencyAmount = converters.toFixedBigNumber(\n      preparedBaseCurrencyAmount.div(preparedQuoteCurrencyPrice),\n      symbol.decimals.quoteCurrency,\n      BigNumber.ROUND_CEIL\n    );\n  }\n\n  const preparedBaseCurrencyPrice = converters.toFixedBigNumber(\n    new BigNumber(1).div(preparedQuoteCurrencyPrice),\n    symbol.decimals.price,\n    BigNumber.ROUND_FLOOR\n  );\n\n  const quoteCurrency: SymbolCurrency = {\n    currencyId: quoteCurrencyId,\n    amount: preparedQuoteCurrencyAmount,\n    price: preparedQuoteCurrencyPrice,\n  };\n\n  const baseCurrency: SymbolCurrency = {\n    currencyId: baseCurrencyId,\n    amount: preparedBaseCurrencyAmount,\n    price: preparedBaseCurrencyPrice,\n  };\n\n  return side === 'Buy'\n    ? [baseCurrency, quoteCurrency]\n    : [quoteCurrency, baseCurrency];\n};\n\nexport const findSymbolAndSide = (\n  symbols: ReadonlyMap<ExchangeSymbol['name'], ExchangeSymbol> | readonly ExchangeSymbol[],\n  from: Currency['id'],\n  to: Currency['id']\n): readonly [symbol: string, side: Side] => {\n  const sellSideSymbolName = `${from}/${to}`;\n  const buySideSymbolName = `${to}/${from}`;\n  let symbol: ExchangeSymbol | undefined;\n  let side: Side = 'Sell';\n\n  if (guards.isReadonlyArray(symbols)) {\n    for (const s of symbols) {\n      if (s.name === sellSideSymbolName) {\n        symbol = s;\n        break;\n      }\n\n      if (s.name === buySideSymbolName) {\n        symbol = s;\n        side = 'Buy';\n        break;\n      }\n    }\n  }\n  else {\n    symbol = symbols.get(sellSideSymbolName);\n    if (!symbol) {\n      side = 'Buy';\n      symbol = symbols.get(buySideSymbolName);\n    }\n  }\n\n  if (!symbol)\n    throw new Error(`Invalid pair: ${from}/${to}`);\n\n  return [symbol.name, side];\n};\n", "import type { BigNumber } from 'bignumber.js';\nimport { nanoid } from 'nanoid';\n\nimport { AtomexService, DataSource, ImportantDataReceivingMode, Side } from '../common/index';\nimport { EventEmitter, type ToEventEmitter, type Result } from '../core/index';\nimport type { ExchangeService, ExchangeServiceEvents } from './exchangeService';\nimport type { ManagedExchangeSymbolsProvider } from './exchangeSymbolsProvider';\nimport { symbolsHelper } from './helpers/index';\nimport type {\n  CancelAllOrdersRequest, CancelOrderRequest, CurrencyDirection, ExchangeSymbol,\n  OrderPreviewParameters as OrderPreviewParameters,\n  NewOrderRequest, Order, OrderBook, OrderPreview, OrdersSelector, Quote, OrderType\n} from './models/index';\n\nexport class ExchangeManager implements AtomexService {\n  readonly events: ExchangeServiceEvents = {\n    orderUpdated: new EventEmitter(),\n    orderBookUpdated: new EventEmitter(),\n    topOfBookUpdated: new EventEmitter()\n  };\n\n  private _isStarted = false;\n  private _orderBookCache: Map<OrderBook['symbol'], OrderBook> = new Map();\n\n  constructor(\n    protected readonly exchangeService: ExchangeService,\n    protected readonly symbolsProvider: ManagedExchangeSymbolsProvider\n  ) {\n  }\n\n  get isStarted() {\n    return this._isStarted;\n  }\n\n  async start() {\n    if (this.isStarted)\n      return;\n\n    this.attachEvents();\n    await this.exchangeService.start();\n    await this.getSymbols();\n\n    this._isStarted = true;\n  }\n\n  stop() {\n    if (!this._isStarted)\n      return;\n\n    this.detachEvents();\n    this.exchangeService.stop();\n\n    this._isStarted = false;\n  }\n\n  getOrder(accountAddress: string, orderId: number, _mode = ImportantDataReceivingMode.SafeMerged): Promise<Order | undefined> {\n    return this.exchangeService.getOrder(accountAddress, orderId);\n  }\n\n  getOrders(accountAddress: string, selector?: OrdersSelector | undefined, _mode = ImportantDataReceivingMode.SafeMerged): Promise<Order[]> {\n    return this.exchangeService.getOrders(accountAddress, selector);\n  }\n\n  async getSymbol(name: string, dataSource = DataSource.All): Promise<ExchangeSymbol | undefined> {\n    if ((dataSource & DataSource.Local) === DataSource.Local) {\n      const symbol = this.symbolsProvider.getSymbol(name);\n      if (symbol)\n        return symbol;\n    }\n\n    if ((dataSource & DataSource.Remote) === DataSource.Remote) {\n      const symbols = await this.exchangeService.getSymbols();\n      this.symbolsProvider.setSymbols(symbols);\n\n      return this.symbolsProvider.getSymbol(name);\n    }\n\n    return undefined;\n  }\n\n  async getSymbols(dataSource = DataSource.All): Promise<readonly ExchangeSymbol[]> {\n    if ((dataSource & DataSource.Local) === DataSource.Local) {\n      const symbols = this.symbolsProvider.getSymbols();\n      if (symbols.length > 0)\n        return symbols;\n    }\n\n    if ((dataSource & DataSource.Remote) === DataSource.Remote) {\n      const symbols = await this.exchangeService.getSymbols();\n      this.symbolsProvider.setSymbols(symbols);\n\n      return symbols;\n    }\n\n    return [];\n  }\n\n  getTopOfBook(symbols?: string[]): Promise<Quote[]>;\n  getTopOfBook(directions?: CurrencyDirection[]): Promise<Quote[]>;\n  getTopOfBook(symbolsOrDirections?: string[] | CurrencyDirection[]): Promise<Quote[]> {\n    return (this.exchangeService.getTopOfBook as (symbolsOrDirections?: string[] | CurrencyDirection[]) => Promise<Quote[]>)(symbolsOrDirections);\n  }\n\n  getOrderBook(symbol: string): Promise<OrderBook | undefined>;\n  getOrderBook(direction: CurrencyDirection): Promise<OrderBook | undefined>;\n  async getOrderBook(symbolOrDirection: string | CurrencyDirection): Promise<OrderBook | undefined> {\n    let symbol: string;\n\n    if (typeof symbolOrDirection === 'string')\n      symbol = symbolOrDirection;\n    else {\n      const exchangeSymbols = this.symbolsProvider.getSymbolsMap();\n      [symbol] = symbolsHelper.findSymbolAndSide(exchangeSymbols, symbolOrDirection.from, symbolOrDirection.to);\n    }\n\n    if (!symbol)\n      throw new Error('Invalid Symbol');\n\n    const orderBook = await this.exchangeService.getOrderBook(symbol);\n    if (orderBook)\n      this._orderBookCache.set(symbol, orderBook);\n\n    return orderBook;\n  }\n\n  addOrder(accountAddress: string, newOrderRequest: NewOrderRequest): Promise<number> {\n    const clientOrderId = newOrderRequest.clientOrderId || nanoid(17);\n    return this.exchangeService.addOrder(accountAddress, { ...newOrderRequest, clientOrderId });\n  }\n\n  cancelOrder(accountAddress: string, cancelOrderRequest: CancelOrderRequest): Promise<boolean> {\n    return this.exchangeService.cancelOrder(accountAddress, cancelOrderRequest);\n  }\n\n  cancelAllOrders(accountAddress: string, cancelAllOrdersRequest: CancelAllOrdersRequest): Promise<number> {\n    return this.exchangeService.cancelAllOrders(accountAddress, cancelAllOrdersRequest);\n  }\n\n  async getOrderPreview(orderPreviewParameters: OrderPreviewParameters): Promise<OrderPreview | undefined> {\n    const isFromAmount = (orderPreviewParameters.isFromAmount === undefined || orderPreviewParameters.isFromAmount === null)\n      ? true\n      : orderPreviewParameters.isFromAmount;\n    const amount = orderPreviewParameters.amount;\n\n    if (orderPreviewParameters.type !== 'SolidFillOrKill')\n      throw new Error('Only the \"SolidFillOrKill\" order type is supported at the current moment');\n\n    const [symbol, side] = this.getSymbolAndSideByOrderPreviewParameters(orderPreviewParameters);\n    const isQuoteCurrencyAmount = side === 'Sell' ? isFromAmount : !isFromAmount;\n    const exchangeSymbol = this.symbolsProvider.getSymbol(symbol);\n    if (!exchangeSymbol)\n      throw undefined;\n\n    const orderBookEntry = await this.findOrderBookEntry(symbol, side, orderPreviewParameters.type, amount, isQuoteCurrencyAmount);\n    if (!orderBookEntry)\n      return undefined;\n\n    const [from, to] = symbolsHelper.convertSymbolToFromToCurrenciesPair(\n      exchangeSymbol,\n      side,\n      amount,\n      orderBookEntry.price,\n      isQuoteCurrencyAmount\n    );\n\n    return {\n      type: orderPreviewParameters.type,\n      from,\n      to,\n      side,\n      symbol,\n    };\n  }\n\n  getMaximumLiquidity(_direction: CurrencyDirection): Promise<BigNumber> {\n    throw new Error('Not implemented');\n  }\n\n  getRewardForRedeem(_nativeTokenUsdPrice: number, _nativeTokenCurrencyPrice: number): Promise<Result<BigNumber>> {\n    throw new Error('Not implemented');\n  }\n\n  protected attachEvents() {\n    this.exchangeService.events.orderUpdated.addListener(this.handleExchangeServiceOrderUpdated);\n    this.exchangeService.events.orderBookUpdated.addListener(this.handleExchangeServiceOrderBookUpdated);\n    this.exchangeService.events.topOfBookUpdated.addListener(this.handleExchangeServiceTopOfBookUpdated);\n  }\n\n  protected detachEvents() {\n    this.exchangeService.events.orderUpdated.removeListener(this.handleExchangeServiceOrderUpdated);\n    this.exchangeService.events.orderBookUpdated.removeListener(this.handleExchangeServiceOrderBookUpdated);\n    this.exchangeService.events.topOfBookUpdated.removeListener(this.handleExchangeServiceTopOfBookUpdated);\n  }\n\n  protected handleExchangeServiceOrderUpdated = (updatedOrder: Order) => {\n    (this.events.orderUpdated as ToEventEmitter<typeof this.events.orderUpdated>).emit(updatedOrder);\n  };\n\n  protected handleExchangeServiceOrderBookUpdated = (orderBookUpdates: OrderBook) => {\n    // TODO: temporary\n    this.getOrderBook(orderBookUpdates.symbol)\n      .then(updatedOrderBook => {\n        if (!updatedOrderBook)\n          return;\n\n        this._orderBookCache.set(updatedOrderBook.symbol, updatedOrderBook);\n        (this.events.orderBookUpdated as ToEventEmitter<typeof this.events.orderBookUpdated>).emit(updatedOrderBook);\n      })\n      .catch(error => console.error(error));\n  };\n\n  protected handleExchangeServiceTopOfBookUpdated = (updatedQuotes: readonly Quote[]) => {\n    (this.events.topOfBookUpdated as ToEventEmitter<typeof this.events.topOfBookUpdated>).emit(updatedQuotes);\n  };\n\n  protected getSymbolAndSideByOrderPreviewParameters(orderPreviewParameters: OrderPreviewParameters): readonly [symbol: string, side: Side] {\n    if (orderPreviewParameters.symbol && orderPreviewParameters.side)\n      return [orderPreviewParameters.symbol, orderPreviewParameters.side];\n\n    if (orderPreviewParameters.from && orderPreviewParameters.to) {\n      const exchangeSymbols = this.symbolsProvider.getSymbolsMap();\n\n      return symbolsHelper.findSymbolAndSide(exchangeSymbols, orderPreviewParameters.from, orderPreviewParameters.to);\n    }\n\n    throw new Error('Invalid orderPreviewParameters argument passed');\n  }\n\n  protected async findOrderBookEntry(symbol: string, side: Side, orderType: OrderType, amount: BigNumber, isQuoteCurrencyAmount: boolean) {\n    if (orderType !== 'SolidFillOrKill')\n      return undefined;\n\n    const orderBook = await this.getCachedOrderBook(symbol);\n    if (!orderBook)\n      return undefined;\n\n    for (const entry of orderBook.entries) {\n      if (entry.side !== side && (isQuoteCurrencyAmount ? amount : amount.div(entry.price)).isLessThanOrEqualTo(Math.max(...entry.qtyProfile))) {\n        return entry;\n      }\n    }\n  }\n\n  protected getCachedOrderBook(symbol: string) {\n    const cachedOrderBook = this._orderBookCache.get(symbol);\n\n    return cachedOrderBook ? Promise.resolve(cachedOrderBook) : this.getOrderBook(symbol);\n  }\n}\n", "export enum DataSource {\n  Local = 1 << 0,\n  Remote = 1 << 1,\n\n  All = Local | Remote\n}\n", "export enum ImportantDataReceivingMode {\n  Local = 0,\n  Remote = 1,\n  SafeMerged = 2\n}\n", "export interface PublicEventEmitter<T extends readonly unknown[]> {\n    addListener(listener: (...args: T) => void): this;\n    removeListener(listener: (...args: T) => void): this;\n    removeAllListeners(): this;\n}\n\nexport class EventEmitter<T extends readonly unknown[]> implements PublicEventEmitter<T> {\n    private listeners: Set<(...args: T) => void> = new Set();\n\n    addListener(listener: (...args: T) => void) {\n        this.listeners.add(listener);\n        return this;\n    }\n\n    removeListener(listener: (...args: T) => void) {\n        if (this.listeners.has(listener))\n            this.listeners.delete(listener);\n        return this;\n    }\n\n    removeAllListeners() {\n        this.listeners = new Set();\n        return this;\n    }\n\n    emit(...args: T) {\n        if (!this.listeners.size)\n            return;\n\n        if (this.listeners.size === 1) {\n            this.listeners.values().next().value(...args);\n        } else {\n            // We copy listeners to prevent an unbounded loop if there is the adding of a new event handler inside the handler; \n            [...this.listeners].forEach(listener => listener(...args));\n        }\n    }\n}\n\nexport type ToEventEmitter<T> = T extends PublicEventEmitter<infer TArgs> ? EventEmitter<TArgs> : never;\nexport type ToEventEmitters<T> = T extends Record<infer K, PublicEventEmitter<infer TArgs>> ? Record<K, EventEmitter<TArgs>> : never;\n", "import type { ManagedExchangeSymbolsProvider } from './exchangeSymbolsProvider';\nimport type { ExchangeSymbol } from './models/exchangeSymbol';\n\nexport class InMemoryExchangeSymbolsProvider implements ManagedExchangeSymbolsProvider {\n  private symbolsMap: Map<ExchangeSymbol['name'], ExchangeSymbol> = new Map();\n  private symbolsCollectionCache: readonly ExchangeSymbol[] = [];\n\n  getSymbol(name: string): ExchangeSymbol | undefined {\n    return this.symbolsMap.get(name);\n  }\n\n  getSymbols(): readonly ExchangeSymbol[] {\n    return this.symbolsCollectionCache;\n  }\n\n  getSymbolsMap(): ReadonlyMap<ExchangeSymbol['name'], ExchangeSymbol> {\n    return this.symbolsMap;\n  }\n\n  setSymbols(exchangeSymbols: readonly ExchangeSymbol[]): void {\n    this.symbolsCollectionCache = exchangeSymbols;\n    this.symbolsMap = this.mapSymbolsCollectionToMap(exchangeSymbols);\n  }\n\n  protected mapSymbolsCollectionToMap(symbolsCollection: readonly ExchangeSymbol[]): Map<ExchangeSymbol['name'], ExchangeSymbol> {\n    const symbolsMap: Map<ExchangeSymbol['name'], ExchangeSymbol> = new Map();\n\n    for (const symbol of symbolsCollection)\n      symbolsMap.set(symbol.name, symbol);\n\n    return symbolsMap;\n  }\n}\n", "import { AtomexService, ImportantDataReceivingMode } from '../common/index';\nimport { EventEmitter, ToEventEmitter } from '../core/index';\nimport type { SwapsSelector } from '../exchange/index';\nimport type { Swap } from './models/index';\nimport type { SwapService, SwapServiceEvents } from './swapService';\n\nexport class SwapManager implements AtomexService {\n  readonly events: SwapServiceEvents = {\n    swapUpdated: new EventEmitter()\n  };\n\n  private _isStarted = false;\n\n  constructor(\n    protected readonly swapService: SwapService\n  ) {\n  }\n\n  get isStarted() {\n    return this._isStarted;\n  }\n\n  async start(): Promise<void> {\n    if (this.isStarted)\n      return;\n\n    this.attachEvents();\n    await this.swapService.start();\n\n    this._isStarted = true;\n  }\n\n  stop(): void {\n    if (!this.isStarted)\n      return;\n\n    this.detachEvents();\n    this.swapService.stop();\n\n    this._isStarted = false;\n  }\n\n  getSwap(swapId: number, accountAddress: string, mode?: ImportantDataReceivingMode): Promise<Swap | undefined>;\n  getSwap(swapId: number, accountAddresses: string[], mode?: ImportantDataReceivingMode): Promise<Swap | undefined>;\n  getSwap(swapId: number, addressOrAddresses: string | string[], _mode = ImportantDataReceivingMode.SafeMerged): Promise<Swap | undefined> {\n    return (this.swapService.getSwap as (swapId: number, addressOrAddresses: string | string[]) => Promise<Swap>)(swapId, addressOrAddresses);\n  }\n\n  getSwaps(accountAddress: string, selector?: SwapsSelector, mode?: ImportantDataReceivingMode): Promise<Swap[]>;\n  getSwaps(accountAddresses: string[], selector?: SwapsSelector, mode?: ImportantDataReceivingMode): Promise<Swap[]>;\n  getSwaps(addressOrAddresses: string | string[], selector?: SwapsSelector, _mode = ImportantDataReceivingMode.SafeMerged): Promise<Swap[]> {\n    return (this.swapService.getSwaps as (addressOrAddresses: string | string[], selector?: SwapsSelector) => Promise<Swap[]>)(addressOrAddresses, selector);\n  }\n\n  protected attachEvents() {\n    this.swapService.events.swapUpdated.addListener(this.handleSwapServiceSwapUpdated);\n  }\n\n  protected detachEvents() {\n    this.swapService.events.swapUpdated.removeListener(this.handleSwapServiceSwapUpdated);\n  }\n\n  protected handleSwapServiceSwapUpdated = (updatedSwap: Swap) => {\n    (this.events.swapUpdated as ToEventEmitter<typeof this.events.swapUpdated>).emit(updatedSwap);\n  };\n}\n", "import { SigningType } from '@airgap/beacon-sdk';\nimport type { BeaconWallet } from '@taquito/beacon-wallet';\n\nimport type { AtomexSignature, Signer } from '../../blockchain/index';\nimport type { AtomexNetwork } from '../../common/index';\nimport { TezosAtomexSigningDataType } from '../models/index';\nimport { decodePublicKey, signingUtils } from '../utils/index';\nimport { decodeSignature } from '../utils/signing';\n\nexport class BeaconWalletTezosSigner implements Signer {\n  readonly blockchain = 'tezos';\n\n  constructor(\n    readonly atomexNetwork: AtomexNetwork,\n    protected readonly beaconWallet: BeaconWallet\n  ) {\n  }\n\n  getAddress(): Promise<string> {\n    return this.beaconWallet.getPKH();\n  }\n\n  async getPublicKey(): Promise<string | undefined> {\n    return (await this.beaconWallet.client.getActiveAccount())?.publicKey;\n  }\n\n  async sign(message: string): Promise<AtomexSignature> {\n    const [address, publicKey, signature] = await Promise.all([\n      this.getAddress(),\n      this.getPublicKey(),\n      this.beaconWallet.client.requestSignPayload({\n        payload: signingUtils.getWalletMichelineSigningData(message),\n        signingType: SigningType.MICHELINE,\n      })\n    ]);\n\n    if (!publicKey)\n      throw new Error('BeaconWallet: public key is unavailable');\n\n    const algorithm = signingUtils.getTezosSigningAlgorithm(publicKey);\n    const publicKeyBytes = decodePublicKey(publicKey);\n    const signatureBytes = decodeSignature(signature.signature);\n\n    return {\n      address,\n      algorithm,\n      publicKeyBytes,\n      signatureBytes,\n      signingDataType: TezosAtomexSigningDataType.WalletMicheline\n    };\n  }\n}\n", "import { b58cdecode, prefix, validatePkAndExtractPrefix } from '@taquito/utils';\n\nimport { Buffer } from '../../native';\n\nexport const decodePublicKey = (publicKey: string) => {\n  const keyPrefix = validatePkAndExtractPrefix(publicKey);\n  const decodedKeyBytes = b58cdecode(publicKey, prefix[keyPrefix]);\n\n  return Buffer.from(decodedKeyBytes).toString('hex');\n};\nexport * as signingUtils from './signing';\n", "import { b58cdecode, prefix, Prefix } from '@taquito/utils';\n\nimport { converters, textUtils } from '../../utils/index';\nimport type { SigPrefix } from '../models/index';\n\n// 'Tezos Signed Message: '\nconst tezosSignedMessagePrefixBytes = '54657a6f73205369676e6564204d6573736167653a20';\nconst getMichelineSigningData = (message: string, prefixBytes?: string) => {\n  const messageBytes = converters.stringToHexString(message);\n  const signedMessageBytes = prefixBytes ? (prefixBytes + messageBytes) : messageBytes;\n  const messageLength = textUtils.padStart((signedMessageBytes.length / 2).toString(16), 8, '0');\n\n  return '0501' + messageLength + signedMessageBytes;\n};\n\nexport const getRawSigningData = (message: string) => converters.stringToHexString(message);\nexport const getRawMichelineSigningData = (message: string) => getMichelineSigningData(message);\nexport const getWalletMichelineSigningData = (message: string) => getMichelineSigningData(message, tezosSignedMessagePrefixBytes);\n\nexport const getTezosSigningAlgorithm = (addressOrPublicKey: string) => {\n  const prefix = addressOrPublicKey.substring(0, addressOrPublicKey.startsWith('tz') ? 3 : 4);\n\n  switch (prefix) {\n    case Prefix.TZ1:\n    case Prefix.EDPK:\n      return 'Ed25519:Blake2b';\n\n    case Prefix.TZ2:\n    case Prefix.SPPK:\n      return 'Blake2bWithEcdsa:Secp256k1';\n\n    case Prefix.TZ3:\n    case Prefix.P2PK:\n      return 'Blake2bWithEcdsa:Secp256r1';\n\n    default:\n      throw new Error(`Unexpected address/public key prefix: ${prefix} (${addressOrPublicKey})`);\n  }\n};\n\nexport const decodeSignature = (signature: string) => {\n  const signaturePrefix = (signature.startsWith('sig')\n    ? signature.substring(0, 3)\n    : signature.substring(0, 5)) as SigPrefix;\n  const decodedKeyBytes = b58cdecode(signature, prefix[signaturePrefix]);\n\n  return Buffer.from(decodedKeyBytes).toString('hex');\n};\n", "import type { TempleWallet } from '@temple-wallet/dapp';\n\nimport type { AtomexSignature, Signer } from '../../blockchain/index';\nimport type { AtomexNetwork } from '../../common/index';\nimport { TezosAtomexSigningDataType } from '../models/index';\nimport { decodePublicKey, signingUtils } from '../utils/index';\nimport { decodeSignature } from '../utils/signing';\n\nexport class TempleWalletTezosSigner implements Signer {\n  readonly blockchain = 'tezos';\n\n  constructor(\n    readonly atomexNetwork: AtomexNetwork,\n    protected readonly templeWallet: TempleWallet\n  ) {\n  }\n\n  getAddress(): Promise<string> {\n    return this.templeWallet.getPKH();\n  }\n\n  getPublicKey(): string | undefined {\n    return this.templeWallet.permission?.publicKey;\n  }\n\n  async sign(message: string): Promise<AtomexSignature> {\n    const [address, publicKey, signature] = await Promise.all([\n      this.getAddress(),\n      this.getPublicKey(),\n      this.templeWallet.sign(signingUtils.getWalletMichelineSigningData(message))\n    ]);\n\n    if (!publicKey)\n      throw new Error('TempleWallet: public key is unavailable');\n\n    const algorithm = signingUtils.getTezosSigningAlgorithm(publicKey);\n    const publicKeyBytes = decodePublicKey(publicKey);\n    const signatureBytes = decodeSignature(signature);\n\n    return {\n      address,\n      algorithm,\n      publicKeyBytes,\n      signatureBytes,\n      signingDataType: TezosAtomexSigningDataType.WalletMicheline\n    };\n  }\n}\n", "import type { BeaconWallet } from '@taquito/beacon-wallet';\nimport type { TempleWallet } from '@temple-wallet/dapp';\n\nimport type { AtomexSignature, Signer } from '../../blockchain/index';\nimport type { AtomexNetwork } from '../../common/index';\nimport { BeaconWalletTezosSigner } from './beaconWalletTezosSigner';\nimport { TempleWalletTezosSigner } from './templeWalletTezosSigner';\n\nexport class WalletTezosSigner implements Signer {\n  readonly blockchain = 'tezos';\n\n  protected readonly internalSigner: Signer;\n\n  constructor(\n    readonly atomexNetwork: AtomexNetwork,\n    protected readonly wallet: TempleWallet | BeaconWallet\n  ) {\n    this.internalSigner = this.createInternalSigner();\n  }\n\n  getAddress(): Promise<string> | string {\n    return this.internalSigner.getAddress();\n  }\n\n  getPublicKey(): Promise<string | undefined> | string | undefined {\n    return this.internalSigner.getPublicKey();\n  }\n\n  sign(message: string): Promise<AtomexSignature> {\n    return this.internalSigner.sign(message);\n  }\n\n  protected createInternalSigner() {\n    if ((this.wallet as BeaconWallet).client?.name !== undefined)\n      return new BeaconWalletTezosSigner(this.atomexNetwork, (this.wallet as BeaconWallet));\n    else if ((this.wallet as TempleWallet).permission !== undefined && (this.wallet as TempleWallet).connected !== undefined)\n      return new TempleWalletTezosSigner(this.atomexNetwork, (this.wallet as TempleWallet));\n    else\n      throw new Error('Unknown Tezos wallet');\n  }\n}\n", "import { InMemorySigner } from '@taquito/signer';\n\nimport type { AtomexSignature, Signer } from '../blockchain/index';\nimport type { AtomexNetwork } from '../common/index';\nimport { decodePublicKey, signingUtils } from './utils/index';\n\nexport class InMemoryTezosSigner implements Signer {\n  readonly blockchain = 'tezos';\n\n  protected readonly internalInMemorySigner: InMemorySigner;\n\n  constructor(readonly atomexNetwork: AtomexNetwork, secretKey: string) {\n    this.internalInMemorySigner = new InMemorySigner(secretKey);\n  }\n\n  getAddress(): Promise<string> {\n    return this.internalInMemorySigner.publicKeyHash();\n  }\n\n  getPublicKey(): Promise<string> {\n    return this.internalInMemorySigner.publicKey();\n  }\n\n  async sign(message: string): Promise<AtomexSignature> {\n    const messageBytes = signingUtils.getRawSigningData(message);\n\n    const [address, publicKey, rawSignature] = await Promise.all([\n      this.getAddress(),\n      this.getPublicKey(),\n      this.internalInMemorySigner.sign(messageBytes)\n    ]);\n\n    const publicKeyBytes = decodePublicKey(publicKey);\n    const signatureBytes = rawSignature.sbytes.substring(rawSignature.bytes.length);\n    const algorithm = signingUtils.getTezosSigningAlgorithm(publicKey);\n\n    return {\n      address,\n      algorithm,\n      publicKeyBytes,\n      signatureBytes\n    };\n  }\n}\n", "import type { AtomexBlockchainNetworkOptions } from '../atomex/models/atomexOptions';\nimport type { TezosCurrency, TezosFA12Currency, TezosFA2Currency } from './models/index';\n\nconst tezosNativeCurrency: TezosCurrency = {\n  id: 'XTZ',\n  name: 'Tezos',\n  symbol: 'XTZ',\n  blockchain: 'tezos',\n  decimals: 6,\n  type: 'native'\n};\n\nconst tzBtcCurrency: TezosFA12Currency = {\n  id: 'TZBTC',\n  name: 'tzBTC',\n  symbol: 'tzBTC',\n  blockchain: 'tezos',\n  type: 'fa1.2',\n  contractAddress: 'KT1PWx2mnDueood7fEmfbBDKx1D9BAnnXitn',\n  decimals: 8,\n};\n\nconst usdtCurrency: TezosFA2Currency = {\n  id: 'USDT_XTZ',\n  name: 'Tether USD',\n  symbol: 'USDt',\n  blockchain: 'tezos',\n  type: 'fa2',\n  tokenId: 0,\n  contractAddress: 'KT1XnTn74bUtxHfDtBmm2bGZAQfhPbvKWR8o',\n  decimals: 6,\n};\n\nexport const tezosMainnetCurrencies: AtomexBlockchainNetworkOptions['currencies'] = [\n  tezosNativeCurrency,\n  tzBtcCurrency,\n  usdtCurrency\n];\n\nexport const tezosTestnetCurrencies: AtomexBlockchainNetworkOptions['currencies'] = [\n  tezosNativeCurrency,\n  ({ ...tzBtcCurrency, contractAddress: 'KT1DM4k79uSx5diQnwqDiF4XeA86aCBxBD35' } as TezosFA12Currency),\n  ({ ...usdtCurrency, contractAddress: 'KT1BWvRQnVVowZZLGkct9A7sdj5YEe8CdUhR' } as TezosFA2Currency)\n];\n", "import type BigNumber from 'bignumber.js';\n\nimport type { BalancesProvider } from '../../blockchain/index';\nimport type { Currency } from '../../index';\n\nexport class TezosBalancesProvider implements BalancesProvider {\n  getBalance(_address: string, _currency: Currency): Promise<BigNumber> {\n    throw new Error('Method not implemented.');\n  }\n}\n", "import type { SwapTransactionsProvider, Transaction } from '../../blockchain/index';\nimport type { Swap } from '../../index';\n\nexport class TezosSwapTransactionsProvider implements SwapTransactionsProvider {\n  private _isStarted = false;\n\n  get isStarted() {\n    return this._isStarted;\n  }\n\n  async start() {\n    if (this.isStarted)\n      return;\n\n    this._isStarted = true;\n  }\n\n  stop(): void {\n    if (!this.isStarted)\n      return;\n\n    this._isStarted = false;\n  }\n\n  getSwapTransactions(_swap: Swap): Promise<readonly Transaction[]> {\n    throw new Error('Method not implemented.');\n  }\n}\n", "import type { BlockchainToolkitProvider, Signer } from '../../blockchain/index';\n\nexport class TezosBlockchainToolkitProvider implements BlockchainToolkitProvider {\n  getReadonlyToolkit(_blockchain: string, _toolkitId: string): Promise<unknown> {\n    throw new Error('Method not implemented.');\n  }\n  getToolkit(_blockchain: string, _address: string, _toolkitId: string): Promise<unknown> {\n    throw new Error('Method not implemented.');\n  }\n  addSigner(_signer: Signer): Promise<boolean> {\n    throw new Error('Method not implemented.');\n  }\n  removeSigner(_signer: Signer): Promise<boolean> {\n    throw new Error('Method not implemented.');\n  }\n}\n", "import type { DeepRequired } from '../../core/index';\n\ntype QueryParams = { [key: string]: string | number | boolean | null | undefined };\ntype Payload = { [key: string]: unknown };\n\nexport interface RequestOptions {\n  urlPath: string;\n  method?: 'GET' | 'POST' | 'DELETE'\n  authToken?: string;\n  params?: QueryParams;\n  payload?: Payload;\n}\n\nexport class HttpClient {\n  constructor(\n    protected readonly baseUrl: string\n  ) { }\n\n  async request<T>(options: RequestOptions): Promise<T | undefined> {\n    const url = new URL(options.urlPath, this.baseUrl);\n\n    if (options.params)\n      this.setSearchParams(url, options.params);\n\n    const response = await fetch(url.toString(), {\n      headers: this.createHeaders(options),\n      method: options.method || 'GET',\n      body: options.payload ? JSON.stringify(options.payload) : undefined\n    });\n\n    if (response.status === 404)\n      return undefined;\n\n    if (!response.ok) {\n      const errorBody = await response.text();\n      throw Error(errorBody);\n    }\n\n    return await response.json();\n  }\n\n  private setSearchParams(url: URL, params: DeepRequired<RequestOptions['params']>) {\n    for (const key in params) {\n      const value = params[key];\n      if (value !== null && value !== undefined)\n        url.searchParams.set(key, String(value));\n    }\n  }\n\n  private createHeaders(options: RequestOptions): { [key: string]: string } {\n    const headers: { [key: string]: string } = {};\n    if (options.authToken)\n      headers['Authorization'] = `Bearer ${options.authToken}`;\n\n    if (options.method === 'POST' && options.payload)\n      headers['Content-Type'] = 'application/json';\n\n    return headers;\n  }\n}\n", "import BigNumber from 'bignumber.js';\n\nimport type { Transaction } from '../blockchain/models/index';\nimport type { CurrenciesProvider } from '../common/index';\nimport { ExchangeSymbol, ExchangeSymbolsProvider, NewOrderRequest, Order, OrderBook, OrderPreview, Quote, symbolsHelper } from '../exchange/index';\nimport type { Swap, SwapParticipantTrade } from '../swaps/index';\nimport type {\n  OrderBookDto, OrderDto, QuoteDto, SwapDto, SymbolDto,\n  TradeDto, TransactionDto, WebSocketOrderBookEntryDto, WebSocketOrderDataDto\n} from './dtos';\n\nexport const isOrderPreview = (orderBody: NewOrderRequest['orderBody']): orderBody is OrderPreview => {\n  return typeof orderBody.symbol === 'string' && typeof orderBody.side === 'string'\n    && orderBody.from !== undefined && typeof orderBody.from !== 'string'\n    && orderBody.to !== undefined && typeof orderBody.to !== 'string';\n};\n\nexport const mapQuoteDtosToQuotes = (quoteDtos: QuoteDto[]): Quote[] => {\n  const quotes: Quote[] = quoteDtos.map(quoteDto => mapQuoteDtoToQuote(quoteDto));\n\n  return quotes;\n};\n\nexport const mapQuoteDtoToQuote = (quoteDto: QuoteDto): Quote => {\n  const [quoteCurrency, baseCurrency] = symbolsHelper.getQuoteBaseCurrenciesBySymbol(quoteDto.symbol);\n\n  const quote: Quote = {\n    ask: new BigNumber(quoteDto.ask),\n    bid: new BigNumber(quoteDto.bid),\n    symbol: quoteDto.symbol,\n    timeStamp: new Date(quoteDto.timeStamp),\n    quoteCurrency,\n    baseCurrency\n  };\n\n  return quote;\n};\n\nexport const mapSymbolDtoToSymbol = (symbolDto: SymbolDto, currenciesProvider: CurrenciesProvider, defaultDecimals = 9): ExchangeSymbol => {\n  const [quoteCurrency, baseCurrency] = symbolsHelper.getQuoteBaseCurrenciesBySymbol(symbolDto.name);\n  const baseCurrencyDecimals = currenciesProvider.getCurrency(baseCurrency)?.decimals;\n  const quoteCurrencyDecimals = currenciesProvider.getCurrency(quoteCurrency)?.decimals;\n\n  const preparedBaseCurrencyDecimals = baseCurrencyDecimals ? Math.min(baseCurrencyDecimals, defaultDecimals) : defaultDecimals;\n  const preparedQuoteCurrencyDecimals = quoteCurrencyDecimals ? Math.min(quoteCurrencyDecimals, defaultDecimals) : defaultDecimals;\n\n  return {\n    name: symbolDto.name,\n    baseCurrency,\n    quoteCurrency,\n    minimumQty: new BigNumber(symbolDto.minimumQty),\n    decimals: {\n      baseCurrency: preparedBaseCurrencyDecimals,\n      quoteCurrency: preparedQuoteCurrencyDecimals,\n      price: defaultDecimals\n    }\n  };\n};\n\nexport const mapSymbolDtosToSymbols = (\n  symbolDtos: readonly SymbolDto[],\n  currenciesProvider: CurrenciesProvider,\n  defaultDecimals?: number\n): ExchangeSymbol[] => {\n  return symbolDtos.map(symbolDto => mapSymbolDtoToSymbol(symbolDto, currenciesProvider, defaultDecimals));\n};\n\nexport const mapOrderBookDtoToOrderBook = (orderBookDto: OrderBookDto): OrderBook => {\n  const [quoteCurrency, baseCurrency] = symbolsHelper.getQuoteBaseCurrenciesBySymbol(orderBookDto.symbol);\n\n  const orderBook: OrderBook = {\n    updateId: orderBookDto.updateId,\n    symbol: orderBookDto.symbol,\n    quoteCurrency,\n    baseCurrency,\n    entries: orderBookDto.entries.map(orderBookEntryDto => ({\n      side: orderBookEntryDto.side,\n      price: new BigNumber(orderBookEntryDto.price),\n      qtyProfile: orderBookEntryDto.qtyProfile\n    }))\n  };\n\n  return orderBook;\n};\n\nexport const mapWebSocketOrderBookEntryDtoToOrderBook = (orderBookEntryDtos: WebSocketOrderBookEntryDto[]): OrderBook => {\n  const firstOrderBookEntry = orderBookEntryDtos[0];\n  if (!firstOrderBookEntry)\n    throw new Error('Unexpected dto');\n\n  const [quoteCurrency, baseCurrency] = symbolsHelper.getQuoteBaseCurrenciesBySymbol(firstOrderBookEntry.symbol);\n\n  const orderBook: OrderBook = {\n    updateId: firstOrderBookEntry.updateId,\n    symbol: firstOrderBookEntry.symbol,\n    quoteCurrency,\n    baseCurrency,\n    entries: orderBookEntryDtos.map(orderBookEntryDto => ({\n      side: orderBookEntryDto.side,\n      price: new BigNumber(orderBookEntryDto.price),\n      qtyProfile: orderBookEntryDto.qtyProfile\n    }))\n  };\n\n  return orderBook;\n};\n\nexport const mapOrderDtoToOrder = (orderDto: OrderDto, exchangeSymbolsProvider: ExchangeSymbolsProvider): Order => {\n  const exchangeSymbol = exchangeSymbolsProvider.getSymbol(orderDto.symbol);\n  if (!exchangeSymbol)\n    throw new Error(`\"${orderDto.symbol}\" symbol not found`);\n\n  const [from, to] = symbolsHelper.convertSymbolToFromToCurrenciesPair(exchangeSymbol, orderDto.side, orderDto.qty, orderDto.price);\n\n  return {\n    id: orderDto.id,\n    from,\n    to,\n    clientOrderId: orderDto.clientOrderId,\n    side: orderDto.side,\n    symbol: orderDto.symbol,\n    leaveQty: new BigNumber(orderDto.leaveQty),\n    timeStamp: new Date(orderDto.timeStamp),\n    type: orderDto.type,\n    status: orderDto.status,\n    swapIds: orderDto.swaps?.map(swap => swap.id) || [],\n  };\n};\n\nexport const mapOrderDtosToOrders = (orderDtos: OrderDto[], exchangeSymbolsProvider: ExchangeSymbolsProvider): Order[] => {\n  return orderDtos.map(orderDto => mapOrderDtoToOrder(orderDto, exchangeSymbolsProvider));\n};\n\nexport const mapTransactionDtosToTransactions = (transactionDtos: TransactionDto[]): Transaction[] => {\n  const transactions = transactionDtos.map(transactionDto => ({\n    id: transactionDto.txId,\n    blockId: transactionDto.blockHeight,\n    confirmations: transactionDto.confirmations,\n    currencyId: transactionDto.currency,\n    status: transactionDto.status,\n    type: transactionDto.type\n  }));\n\n  return transactions;\n};\n\nexport const mapSwapDtoToSwap = (swapDto: SwapDto, exchangeSymbolsProvider: ExchangeSymbolsProvider): Swap => {\n  const exchangeSymbol = exchangeSymbolsProvider.getSymbol(swapDto.symbol);\n  if (!exchangeSymbol)\n    throw new Error(`\"${swapDto.symbol}\" symbol not found`);\n\n  const [from, to] = symbolsHelper.convertSymbolToFromToCurrenciesPair(exchangeSymbol, swapDto.side, swapDto.qty, swapDto.price);\n\n  const swap: Swap = {\n    isInitiator: swapDto.isInitiator,\n    secret: swapDto.secret,\n    secretHash: swapDto.secretHash,\n    id: Number(swapDto.id),\n    from,\n    to,\n    trade: {\n      qty: new BigNumber(swapDto.qty),\n      price: new BigNumber(swapDto.price),\n      side: swapDto.side,\n      symbol: swapDto.symbol\n    },\n    timeStamp: new Date(swapDto.timeStamp),\n    counterParty: {\n      status: swapDto.counterParty.status,\n      transactions: mapTransactionDtosToTransactions(swapDto.counterParty.transactions),\n      requisites: {\n        ...swapDto.counterParty.requisites,\n        rewardForRedeem: new BigNumber(swapDto.counterParty.requisites.rewardForRedeem),\n      },\n      trades: mapTradeDtosToTrades(swapDto.counterParty.trades)\n    },\n    user: {\n      status: swapDto.user.status,\n      transactions: mapTransactionDtosToTransactions(swapDto.user.transactions),\n      requisites: {\n        ...swapDto.user.requisites,\n        rewardForRedeem: new BigNumber(swapDto.user.requisites.rewardForRedeem),\n      },\n      trades: mapTradeDtosToTrades(swapDto.user.trades)\n    },\n  };\n\n  return swap;\n};\n\nexport const mapTradeDtosToTrades = (tradeDtos: TradeDto[]): SwapParticipantTrade[] => {\n  const trades = tradeDtos.map(tradeDto => ({\n    orderId: tradeDto.orderId,\n    price: new BigNumber(tradeDto.price),\n    qty: new BigNumber(tradeDto.qty),\n  }));\n\n  return trades;\n};\n\nexport const mapSwapDtosToSwaps = (swapDtos: SwapDto[], exchangeSymbolsProvider: ExchangeSymbolsProvider): Swap[] => {\n  return swapDtos.map(swapDto => mapSwapDtoToSwap(swapDto, exchangeSymbolsProvider));\n};\n\nexport const mapWebSocketOrderDtoToOrder = (orderDto: WebSocketOrderDataDto, exchangeSymbolsProvider: ExchangeSymbolsProvider): Order => {\n  const exchangeSymbol = exchangeSymbolsProvider.getSymbol(orderDto.symbol);\n  if (!exchangeSymbol)\n    throw new Error(`\"${orderDto.symbol}\" symbol not found`);\n\n  const [from, to] = symbolsHelper.convertSymbolToFromToCurrenciesPair(exchangeSymbol, orderDto.side, orderDto.qty, orderDto.price);\n\n  const order: Order = {\n    id: orderDto.id,\n    clientOrderId: orderDto.clientOrderId,\n    side: orderDto.side,\n    status: orderDto.status,\n    leaveQty: new BigNumber(orderDto.leaveQty),\n    swapIds: orderDto.swaps,\n    symbol: orderDto.symbol,\n    type: orderDto.type,\n    timeStamp: new Date(orderDto.timeStamp),\n    from,\n    to\n  };\n\n  return order;\n};\n", "import type BigNumber from 'bignumber.js';\n\nimport type { AuthorizationManager } from '../../authorization/index';\nimport type { Transaction } from '../../blockchain/index';\nimport type { AtomexNetwork, CancelAllSide, CurrenciesProvider, Side } from '../../common/index';\nimport { EventEmitter } from '../../core';\nimport {\n  Order, OrderBook, Quote, ExchangeSymbol, NewOrderRequest,\n  OrdersSelector, CancelOrderRequest,\n  CancelAllOrdersRequest, SwapsSelector, CurrencyDirection, symbolsHelper, ExchangeSymbolsProvider\n} from '../../exchange/index';\nimport type { Swap } from '../../swaps/index';\nimport type { AtomexClient } from '../atomexClient';\nimport type { CreatedOrderDto, OrderBookDto, OrderDto, QuoteDto, SwapDto, SymbolDto } from '../dtos';\nimport {\n  isOrderPreview,\n  mapOrderBookDtoToOrderBook, mapOrderDtosToOrders, mapOrderDtoToOrder,\n  mapQuoteDtosToQuotes, mapSwapDtosToSwaps, mapSwapDtoToSwap, mapSymbolDtosToSymbols\n} from '../helpers';\nimport { HttpClient } from './httpClient';\n\nexport interface RestAtomexClientOptions {\n  atomexNetwork: AtomexNetwork;\n  authorizationManager: AuthorizationManager;\n  currenciesProvider: CurrenciesProvider;\n  exchangeSymbolsProvider: ExchangeSymbolsProvider;\n  apiBaseUrl: string;\n}\n\nexport class RestAtomexClient implements AtomexClient {\n  readonly atomexNetwork: AtomexNetwork;\n\n  readonly events: AtomexClient['events'] = {\n    swapUpdated: new EventEmitter(),\n    orderUpdated: new EventEmitter(),\n    orderBookUpdated: new EventEmitter(),\n    topOfBookUpdated: new EventEmitter()\n  };\n\n  protected readonly authorizationManager: AuthorizationManager;\n  protected readonly currenciesProvider: CurrenciesProvider;\n  protected readonly exchangeSymbolsProvider: ExchangeSymbolsProvider;\n  protected readonly apiBaseUrl: string;\n  protected readonly httpClient: HttpClient;\n\n  private _isStarted = false;\n\n  constructor(options: RestAtomexClientOptions) {\n    this.atomexNetwork = options.atomexNetwork;\n    this.authorizationManager = options.authorizationManager;\n    this.currenciesProvider = options.currenciesProvider;\n    this.exchangeSymbolsProvider = options.exchangeSymbolsProvider;\n    this.apiBaseUrl = options.apiBaseUrl;\n    this.httpClient = new HttpClient(this.apiBaseUrl);\n  }\n\n  get isStarted() {\n    return this._isStarted;\n  }\n\n  async start() {\n    if (this.isStarted)\n      return;\n\n    this._isStarted = true;\n  }\n\n  stop(): void {\n    if (!this.isStarted)\n      return;\n\n    this._isStarted = false;\n  }\n\n  async getOrder(accountAddress: string, orderId: number): Promise<Order | undefined> {\n    const urlPath = `/v1/Orders/${orderId}`;\n    const authToken = this.getRequiredAuthToken(accountAddress);\n    const orderDto = await this.httpClient.request<OrderDto>({ urlPath, authToken });\n\n    return orderDto ? mapOrderDtoToOrder(orderDto, this.exchangeSymbolsProvider) : undefined;\n  }\n\n  async getOrders(accountAddress: string, selector?: OrdersSelector | undefined): Promise<Order[]> {\n    const urlPath = '/v1/Orders';\n    const authToken = this.getRequiredAuthToken(accountAddress);\n    const params = {\n      ...selector,\n      sortAsc: undefined,\n      sort: selector?.sortAsc !== undefined\n        ? selector.sortAsc ? 'Asc' : 'Desc'\n        : undefined,\n    };\n\n    const orderDtos = await this.httpClient.request<OrderDto[]>({ urlPath, authToken, params });\n\n    return orderDtos ? mapOrderDtosToOrders(orderDtos, this.exchangeSymbolsProvider) : [];\n  }\n\n  async getSymbols(): Promise<ExchangeSymbol[]> {\n    const urlPath = '/v1/Symbols';\n    const symbolDtos = await this.httpClient.request<SymbolDto[]>({ urlPath });\n\n    return symbolDtos ? mapSymbolDtosToSymbols(symbolDtos, this.currenciesProvider) : [];\n  }\n\n  getTopOfBook(symbols?: string[]): Promise<Quote[]>;\n  getTopOfBook(directions?: CurrencyDirection[]): Promise<Quote[]>;\n  async getTopOfBook(symbolsOrDirections?: string[] | CurrencyDirection[]): Promise<Quote[]> {\n    const urlPath = '/v1/MarketData/quotes';\n    let symbols: string[] | undefined = undefined;\n\n    if (symbolsOrDirections?.length) {\n      if (typeof symbolsOrDirections[0] === 'string')\n        symbols = symbolsOrDirections as string[];\n      else {\n        const exchangeSymbols = this.exchangeSymbolsProvider.getSymbolsMap();\n        symbols = (symbolsOrDirections as CurrencyDirection[]).map(d => symbolsHelper.findSymbolAndSide(exchangeSymbols, d.from, d.to)[0]);\n      }\n    }\n\n    const params = { symbols: symbols?.join(',') };\n\n    const quoteDtos = await this.httpClient.request<QuoteDto[]>({ urlPath, params });\n\n    return quoteDtos ? mapQuoteDtosToQuotes(quoteDtos) : [];\n  }\n\n  getOrderBook(symbol: string): Promise<OrderBook | undefined>;\n  getOrderBook(direction: CurrencyDirection): Promise<OrderBook | undefined>;\n  async getOrderBook(symbolOrDirection: string | CurrencyDirection): Promise<OrderBook | undefined> {\n    const urlPath = '/v1/MarketData/book';\n    let symbol: string;\n\n    if (typeof symbolOrDirection === 'string')\n      symbol = symbolOrDirection;\n    else {\n      const exchangeSymbols = this.exchangeSymbolsProvider.getSymbolsMap();\n      [symbol] = symbolsHelper.findSymbolAndSide(exchangeSymbols, symbolOrDirection.from, symbolOrDirection.to);\n    }\n\n    const params = { symbol };\n    const orderBookDto = await this.httpClient.request<OrderBookDto>({ urlPath, params });\n\n    return orderBookDto ? mapOrderBookDtoToOrderBook(orderBookDto) : undefined;\n  }\n\n  async addOrder(accountAddress: string, newOrderRequest: NewOrderRequest): Promise<number> {\n    const urlPath = '/v1/Orders';\n    const authToken = this.getRequiredAuthToken(accountAddress);\n    let symbol: string | undefined = undefined;\n    let side: Side | undefined = undefined;\n\n    if (newOrderRequest.orderBody.symbol && newOrderRequest.orderBody.side)\n      [symbol, side] = [newOrderRequest.orderBody.symbol, newOrderRequest.orderBody.side];\n    else if (typeof newOrderRequest.orderBody.from === 'string' && typeof newOrderRequest.orderBody.to === 'string') {\n      const exchangeSymbols = this.exchangeSymbolsProvider.getSymbolsMap();\n      [symbol, side] = symbolsHelper.findSymbolAndSide(exchangeSymbols, newOrderRequest.orderBody.from, newOrderRequest.orderBody.to);\n    }\n    else\n      throw new Error('Invalid newOrderRequest argument passed');\n\n    let amountBigNumber: BigNumber;\n    let priceBigNumber: BigNumber;\n    if (isOrderPreview(newOrderRequest.orderBody)) {\n      amountBigNumber = newOrderRequest.orderBody.from.amount;\n      priceBigNumber = newOrderRequest.orderBody.from.price;\n    }\n    else {\n      amountBigNumber = newOrderRequest.orderBody.fromAmount;\n      priceBigNumber = newOrderRequest.orderBody.price;\n    }\n\n    // TODO: move to the mapper\n    const payload = {\n      clientOrderId: newOrderRequest.clientOrderId,\n      symbol,\n      side,\n      type: newOrderRequest.orderBody.type,\n      requisites: newOrderRequest.requisites ? {\n        secretHash: newOrderRequest.requisites.secretHash,\n        receivingAddress: newOrderRequest.requisites.receivingAddress,\n        refundAddress: newOrderRequest.requisites.refundAddress,\n        rewardForRedeem: newOrderRequest.requisites.rewardForRedeem.toNumber(),\n        lockTime: newOrderRequest.requisites.lockTime,\n        baseCurrencyContract: newOrderRequest.requisites.baseCurrencyContract,\n        quoteCurrencyContract: newOrderRequest.requisites.quoteCurrencyContract\n      } : undefined,\n      proofsOfFunds: newOrderRequest.proofsOfFunds,\n      qty: amountBigNumber.toNumber(),\n      price: priceBigNumber.toNumber()\n    };\n\n    const newOrderDto = await this.httpClient.request<CreatedOrderDto>({\n      urlPath,\n      authToken,\n      method: 'POST',\n      payload\n    });\n\n    if (newOrderDto === undefined)\n      throw new Error('Unexpected response dto');\n\n    return newOrderDto.orderId;\n  }\n\n  async cancelOrder(accountAddress: string, cancelOrderRequest: CancelOrderRequest): Promise<boolean> {\n    const urlPath = `/v1/Orders/${cancelOrderRequest.orderId}`;\n    const authToken = this.getRequiredAuthToken(accountAddress);\n    let symbol: string | undefined = undefined;\n    let side: Side | undefined = undefined;\n\n    if (cancelOrderRequest.symbol && cancelOrderRequest.side)\n      [symbol, side] = [cancelOrderRequest.symbol, cancelOrderRequest.side];\n    else if (cancelOrderRequest.from && cancelOrderRequest.to) {\n      const exchangeSymbols = this.exchangeSymbolsProvider.getSymbolsMap();\n      [symbol, side] = symbolsHelper.findSymbolAndSide(exchangeSymbols, cancelOrderRequest.from, cancelOrderRequest.to);\n    }\n    else\n      throw new Error('Invalid cancelOrderRequest argument passed');\n\n    const params = { symbol, side };\n\n    const isSuccess = await this.httpClient.request<boolean>({\n      urlPath,\n      authToken,\n      params,\n      method: 'DELETE'\n    });\n\n    if (isSuccess === undefined)\n      throw new Error('Unexpected response dto');\n\n    return isSuccess;\n  }\n\n  async cancelAllOrders(accountAddress: string, cancelAllOrdersRequest: CancelAllOrdersRequest): Promise<number> {\n    const urlPath = '/v1/Orders';\n    const authToken = this.getRequiredAuthToken(accountAddress);\n\n    let symbol: string | undefined = undefined;\n    let side: CancelAllSide | undefined = undefined;\n\n    if (cancelAllOrdersRequest.symbol && cancelAllOrdersRequest.side)\n      [symbol, side] = [cancelAllOrdersRequest.symbol, cancelAllOrdersRequest.side];\n    else if (cancelAllOrdersRequest.from && cancelAllOrdersRequest.to) {\n      const exchangeSymbols = this.exchangeSymbolsProvider.getSymbolsMap();\n      [symbol, side] = symbolsHelper.findSymbolAndSide(exchangeSymbols, cancelAllOrdersRequest.from, cancelAllOrdersRequest.to);\n\n      if (cancelAllOrdersRequest.cancelAllDirections)\n        side = 'All';\n    }\n    else\n      throw new Error('Invalid cancelAllOrdersRequest argument passed');\n\n    const canceledOrdersCount = await this.httpClient.request<number>({\n      urlPath,\n      authToken,\n      params: {\n        symbol,\n        side,\n        forAllConnections: cancelAllOrdersRequest.forAllConnections\n      },\n      method: 'DELETE'\n    });\n\n    if (canceledOrdersCount === undefined)\n      throw new Error('Unexpected response dto');\n\n    return canceledOrdersCount;\n  }\n\n  getSwapTransactions(_swap: Swap): Promise<readonly Transaction[]> {\n    throw new Error('Method not implemented.');\n  }\n\n  async getSwap(swapId: number, accountAddress: string): Promise<Swap | undefined>;\n  async getSwap(swapId: number, accountAddresses: string[]): Promise<Swap | undefined>;\n  async getSwap(swapId: number, addressOrAddresses: string | string[]): Promise<Swap | undefined> {\n    const urlPath = `/v1/Swaps/${swapId}`;\n\n    const userIds = this.getUserIds(addressOrAddresses);\n    const params = {\n      userIds: userIds.join(',')\n    };\n\n    const swapDto = await this.httpClient.request<SwapDto>({\n      urlPath,\n      params\n    });\n\n    return swapDto ? mapSwapDtoToSwap(swapDto, this.exchangeSymbolsProvider) : undefined;\n  }\n\n  async getSwaps(accountAddress: string, selector?: SwapsSelector): Promise<Swap[]>;\n  async getSwaps(accountAddresses: string[], selector?: SwapsSelector): Promise<Swap[]>;\n  async getSwaps(addressOrAddresses: string | string[], selector?: SwapsSelector): Promise<Swap[]> {\n    const urlPath = '/v1/Swaps';\n\n    const userIds = this.getUserIds(addressOrAddresses);\n    const params = {\n      ...selector,\n      sortAsc: undefined,\n      sort: selector?.sortAsc !== undefined\n        ? selector.sortAsc ? 'Asc' : 'Desc'\n        : undefined,\n      userIds: userIds.join(',')\n    };\n\n    const swapDtos = await this.httpClient.request<SwapDto[]>({\n      urlPath,\n      params\n    });\n\n    return swapDtos ? mapSwapDtosToSwaps(swapDtos, this.exchangeSymbolsProvider) : [];\n  }\n\n  private getUserIds(addressOrAddresses: string | string[]) {\n    const accountAddresses = Array.isArray(addressOrAddresses) ? addressOrAddresses : [addressOrAddresses];\n\n    const userIds = accountAddresses\n      .map(address => this.authorizationManager.getAuthToken(address)?.userId)\n      .filter(userId => userId);\n\n    if (!userIds.length)\n      throw new Error('Incorrect accountAddresses');\n\n    return userIds;\n  }\n\n  private getRequiredAuthToken(accountAddress: string): string {\n    const authToken = this.authorizationManager.getAuthToken(accountAddress)?.value;\n\n    if (!authToken)\n      throw new Error(`Cannot find auth token for address: ${accountAddress}`);\n\n    return authToken;\n  }\n}\n", "import { EventEmitter } from '../../core/eventEmitter';\nimport type { WebSocketRequestDto, WebSocketResponseDto } from '../dtos';\n\nexport interface WebSocketClientEvents {\n  messageReceived: EventEmitter<readonly [message: WebSocketResponseDto]>;\n  closed: EventEmitter<readonly [socket: WebSocketClient, event: CloseEvent]>;\n}\n\nexport class WebSocketClient {\n  readonly events: WebSocketClientEvents = {\n    messageReceived: new EventEmitter(),\n    closed: new EventEmitter()\n  };\n\n  protected _socket: WebSocket | undefined;\n\n  protected get socket(): WebSocket {\n    if (!this._socket)\n      throw new Error('Internal websocket is not created. Use the connect method first');\n\n    return this._socket;\n  }\n\n  constructor(\n    protected readonly url: string | URL,\n    protected readonly authToken?: string,\n  ) {\n  }\n\n  async connect(): Promise<void> {\n    this.disconnect();\n    return new Promise(resolve => {\n      const protocols = this.authToken ? ['access_token', this.authToken] : undefined;\n      this._socket = new WebSocket(this.url, protocols);\n      this.socket.addEventListener('message', this.onMessageReceived);\n      this.socket.addEventListener('error', this.onError);\n      this.socket.addEventListener('close', this.onClosed);\n\n      this.socket.addEventListener('open', () => resolve());\n    });\n  }\n\n  disconnect() {\n    if (this._socket) {\n      this.socket.removeEventListener('message', this.onMessageReceived);\n      this.socket.removeEventListener('error', this.onError);\n      this.socket.removeEventListener('close', this.onClosed);\n      this.socket.close();\n    }\n  }\n\n  subscribe(stream: string) {\n    const message: WebSocketRequestDto = {\n      method: 'subscribe',\n      data: stream,\n      requestId: Date.now()\n    };\n\n    this.socket.send(JSON.stringify(message));\n  }\n\n  unsubscribe(stream: string) {\n    const message: WebSocketRequestDto = {\n      method: 'unsubscribe',\n      data: stream,\n      requestId: Date.now()\n    };\n\n    this.socket.send(JSON.stringify(message));\n  }\n\n  protected onMessageReceived = (event: MessageEvent<string>) => {\n    this.events.messageReceived.emit(JSON.parse(event.data));\n  };\n\n  protected onError(event: Event) {\n    throw new Error(`Websocket received error: ${JSON.stringify(event)}`);\n  }\n\n  protected onClosed = (event: CloseEvent) => {\n    this.events.closed.emit(this, event);\n  };\n}\n", "import type { AuthorizationManager, AuthToken } from '../../authorization/index';\nimport { EventEmitter } from '../../core/index';\nimport type { WebSocketResponseDto } from '../dtos';\nimport { WebSocketClient } from './webSocketClient';\n\nexport interface ExchangeWebSocketClientEvents {\n  messageReceived: EventEmitter<readonly [message: WebSocketResponseDto]>;\n}\n\nexport class ExchangeWebSocketClient {\n  protected static readonly EXCHANGE_URL_PATH = '/ws/exchange';\n\n  readonly events: ExchangeWebSocketClientEvents = {\n    messageReceived: new EventEmitter()\n  };\n\n  protected readonly sockets: Map<string, WebSocketClient> = new Map();\n\n  private _isStarted = false;\n\n  constructor(\n    protected readonly webSocketApiBaseUrl: string,\n    protected readonly authorizationManager: AuthorizationManager\n  ) {\n  }\n\n  get isStarted() {\n    return this._isStarted;\n  }\n\n  async start() {\n    if (this.isStarted)\n      return;\n\n    this.subscribeOnAuthEvents();\n\n    this._isStarted = true;\n  }\n\n  stop() {\n    if (!this.isStarted)\n      return;\n\n    this.sockets.forEach((_, userId) => {\n      this.removeSocket(userId);\n    });\n\n    this._isStarted = false;\n  }\n\n  protected subscribeOnAuthEvents() {\n    this.authorizationManager.events.authorized.addListener(this.onAuthorized);\n    this.authorizationManager.events.unauthorized.addListener(this.onUnauthorized);\n  }\n\n  protected onAuthorized = async (authToken: AuthToken) => {\n    this.removeSocket(authToken.userId);\n\n    const socket = new WebSocketClient(new URL(ExchangeWebSocketClient.EXCHANGE_URL_PATH, this.webSocketApiBaseUrl), authToken.value);\n    socket.events.messageReceived.addListener(this.onSocketMessageReceived);\n    socket.events.closed.addListener(this.onClosed);\n\n    this.sockets.set(authToken.userId, socket);\n    await socket.connect();\n  };\n\n  protected onUnauthorized = (authToken: AuthToken) => {\n    this.removeSocket(authToken.userId);\n  };\n\n  protected removeSocket(userId: string) {\n    const socket = this.sockets.get(userId);\n\n    if (socket) {\n      socket.events.messageReceived.removeListener(this.onSocketMessageReceived);\n      socket.events.closed.removeListener(this.onClosed);\n      this.sockets.delete(userId);\n      socket.disconnect();\n    }\n  }\n\n  protected onSocketMessageReceived = (message: WebSocketResponseDto) => {\n    this.events.messageReceived.emit(message);\n  };\n\n  protected onClosed = (socket: WebSocketClient, _event: CloseEvent) => {\n    setTimeout(() => {\n      socket.connect();\n    }, 1000);\n  };\n}\n", "import { EventEmitter } from '../../core/index';\nimport type { WebSocketResponseDto } from '../dtos';\nimport { WebSocketClient } from './webSocketClient';\n\nexport interface MarketDataWebSocketClientEvents {\n  messageReceived: EventEmitter<readonly [message: WebSocketResponseDto]>;\n}\n\nexport class MarketDataWebSocketClient {\n  protected static readonly MARKET_DATA_URL_PATH = '/ws/marketdata';\n  protected static readonly TOP_OF_BOOK_STREAM = 'topOfBook';\n  protected static readonly ORDER_BOOK_STREAM = 'orderBook';\n\n  readonly events: MarketDataWebSocketClientEvents = {\n    messageReceived: new EventEmitter()\n  };\n\n  protected socket: WebSocketClient;\n\n  private _isStarted = false;\n\n  constructor(\n    protected readonly webSocketApiBaseUrl: string\n  ) {\n    this.socket = new WebSocketClient(new URL(MarketDataWebSocketClient.MARKET_DATA_URL_PATH, this.webSocketApiBaseUrl));\n  }\n\n  get isStarted() {\n    return this._isStarted;\n  }\n\n  async start(): Promise<void> {\n    if (this.isStarted)\n      return;\n\n    this.socket.events.messageReceived.addListener(this.onSocketMessageReceived);\n    this.socket.events.closed.addListener(this.onSocketClosed);\n    await this.socket.connect();\n\n    this.subscribeOnStreams(this.socket);\n\n    this._isStarted = true;\n  }\n\n  stop() {\n    if (!this.isStarted)\n      return;\n\n    this.socket.events.messageReceived.removeListener(this.onSocketMessageReceived);\n    this.socket.events.closed.removeListener(this.onSocketClosed);\n    this.socket.disconnect();\n\n    this._isStarted = false;\n  }\n\n  protected subscribeOnStreams(socket: WebSocketClient) {\n    socket.subscribe(MarketDataWebSocketClient.TOP_OF_BOOK_STREAM);\n    socket.subscribe(MarketDataWebSocketClient.ORDER_BOOK_STREAM);\n  }\n\n  protected onSocketClosed = (socket: WebSocketClient, _event: CloseEvent) => {\n    setTimeout(async () => {\n      await socket.connect();\n      this.subscribeOnStreams(socket);\n    }, 1000);\n  };\n\n  protected onSocketMessageReceived = (message: WebSocketResponseDto) => {\n    this.events.messageReceived.emit(message);\n  };\n}\n", "import type { AuthorizationManager } from '../../authorization/index';\nimport type { Transaction } from '../../blockchain/index';\nimport type { AtomexNetwork, CurrenciesProvider } from '../../common/index';\nimport { EventEmitter, type ToEventEmitter } from '../../core';\nimport type {\n  Order, OrderBook, Quote, ExchangeSymbol, NewOrderRequest,\n  OrdersSelector, CancelOrderRequest,\n  CancelAllOrdersRequest, SwapsSelector, CurrencyDirection, ExchangeSymbolsProvider\n} from '../../exchange/index';\nimport type { Swap } from '../../swaps/index';\nimport type { AtomexClient } from '../atomexClient';\nimport type { WebSocketResponseDto } from '../dtos';\nimport { mapQuoteDtosToQuotes, mapSwapDtoToSwap, mapWebSocketOrderBookEntryDtoToOrderBook, mapWebSocketOrderDtoToOrder } from '../helpers';\nimport { ExchangeWebSocketClient } from './exchangeWebSocketClient';\nimport { MarketDataWebSocketClient } from './marketDataWebSocketClient';\n\nexport interface WebSocketAtomexClientOptions {\n  atomexNetwork: AtomexNetwork;\n  authorizationManager: AuthorizationManager;\n  currenciesProvider: CurrenciesProvider;\n  exchangeSymbolsProvider: ExchangeSymbolsProvider;\n  webSocketApiBaseUrl: string;\n}\n\nexport class WebSocketAtomexClient implements AtomexClient {\n  readonly atomexNetwork: AtomexNetwork;\n  readonly events: AtomexClient['events'] = {\n    swapUpdated: new EventEmitter(),\n    orderUpdated: new EventEmitter(),\n    orderBookUpdated: new EventEmitter(),\n    topOfBookUpdated: new EventEmitter()\n  };\n\n  protected readonly authorizationManager: AuthorizationManager;\n  protected readonly exchangeSymbolsProvider: ExchangeSymbolsProvider;\n  protected readonly currenciesProvider: CurrenciesProvider;\n  protected readonly webSocketApiBaseUrl: string;\n  protected readonly marketDataWebSocketClient: MarketDataWebSocketClient;\n  protected readonly exchangeWebSocketClient: ExchangeWebSocketClient;\n\n  private _isStarted = false;\n\n  constructor(options: WebSocketAtomexClientOptions) {\n    this.atomexNetwork = options.atomexNetwork;\n    this.authorizationManager = options.authorizationManager;\n    this.currenciesProvider = options.currenciesProvider;\n    this.exchangeSymbolsProvider = options.exchangeSymbolsProvider;\n    this.webSocketApiBaseUrl = options.webSocketApiBaseUrl;\n\n    this.exchangeWebSocketClient = new ExchangeWebSocketClient(this.webSocketApiBaseUrl, this.authorizationManager);\n    this.marketDataWebSocketClient = new MarketDataWebSocketClient(this.webSocketApiBaseUrl);\n  }\n\n  get isStarted() {\n    return this._isStarted;\n  }\n\n  async start() {\n    if (this.isStarted)\n      return;\n\n    this.exchangeWebSocketClient.events.messageReceived.addListener(this.onSocketMessageReceived);\n    this.marketDataWebSocketClient.events.messageReceived.addListener(this.onSocketMessageReceived);\n\n    await Promise.all([\n      this.exchangeWebSocketClient.start(),\n      this.marketDataWebSocketClient.start()\n    ]);\n\n    this._isStarted = true;\n  }\n\n  stop(): void {\n    if (!this.isStarted)\n      return;\n\n    this.exchangeWebSocketClient.events.messageReceived.removeListener(this.onSocketMessageReceived);\n    this.marketDataWebSocketClient.events.messageReceived.removeListener(this.onSocketMessageReceived);\n\n    this.exchangeWebSocketClient.stop();\n    this.marketDataWebSocketClient.stop();\n\n    this._isStarted = false;\n  }\n\n  getOrder(_accountAddress: string, _orderId: number): Promise<Order | undefined> {\n    throw new Error('Method not implemented.');\n  }\n\n  getOrders(_accountAddress: string, _selector?: OrdersSelector | undefined): Promise<Order[]> {\n    throw new Error('Method not implemented.');\n  }\n\n  getSymbols(): Promise<ExchangeSymbol[]> {\n    throw new Error('Method not implemented.');\n  }\n\n  getTopOfBook(symbols?: string[]): Promise<Quote[]>;\n  getTopOfBook(directions?: CurrencyDirection[]): Promise<Quote[]>;\n  getTopOfBook(_symbolsOrDirections?: string[] | CurrencyDirection[]): Promise<Quote[]> {\n    throw new Error('Method not implemented.');\n  }\n\n  getOrderBook(symbol: string): Promise<OrderBook | undefined>;\n  getOrderBook(direction: CurrencyDirection): Promise<OrderBook | undefined>;\n  async getOrderBook(_symbolOrDirection: string | CurrencyDirection): Promise<OrderBook | undefined> {\n    throw new Error('Method not implemented.');\n  }\n\n  addOrder(_accountAddress: string, _newOrderRequest: NewOrderRequest): Promise<number> {\n    throw new Error('Method not implemented.');\n  }\n\n  cancelOrder(_accountAddress: string, _cancelOrderRequest: CancelOrderRequest): Promise<boolean> {\n    throw new Error('Method not implemented.');\n  }\n\n  cancelAllOrders(_accountAddress: string, _cancelAllOrdersRequest: CancelAllOrdersRequest): Promise<number> {\n    throw new Error('Method not implemented.');\n  }\n\n  getSwapTransactions(_swap: Swap): Promise<readonly Transaction[]> {\n    throw new Error('Method not implemented.');\n  }\n\n  getSwap(swapId: number, accountAddress: string): Promise<Swap | undefined>;\n  getSwap(swapId: number, accountAddresses: string[]): Promise<Swap | undefined>;\n  getSwap(_swapId: number, _addressOrAddresses: string | string[]): Promise<Swap | undefined> {\n    throw new Error('Method not implemented.');\n  }\n\n  getSwaps(accountAddress: string, selector?: SwapsSelector): Promise<Swap[]>;\n  getSwaps(accountAddresses: string[], selector?: SwapsSelector): Promise<Swap[]>;\n  getSwaps(_addressOrAddresses: string | string[], _selector?: SwapsSelector): Promise<Swap[]> {\n    throw new Error('Method not implemented.');\n  }\n\n  protected readonly onSocketMessageReceived = (message: WebSocketResponseDto) => {\n    switch (message.event) {\n      case 'order':\n        (this.events.orderUpdated as ToEventEmitter<typeof this.events.orderUpdated>).emit(mapWebSocketOrderDtoToOrder(message.data, this.exchangeSymbolsProvider));\n        break;\n\n      case 'swap':\n        (this.events.swapUpdated as ToEventEmitter<typeof this.events.swapUpdated>).emit(mapSwapDtoToSwap(message.data, this.exchangeSymbolsProvider));\n        break;\n\n      case 'topOfBook':\n        (this.events.topOfBookUpdated as ToEventEmitter<typeof this.events.topOfBookUpdated>).emit(mapQuoteDtosToQuotes(message.data));\n        break;\n\n      case 'entries':\n        (this.events.orderBookUpdated as ToEventEmitter<typeof this.events.orderBookUpdated>).emit(mapWebSocketOrderBookEntryDtoToOrderBook(message.data));\n        break;\n    }\n  };\n}\n", "import type { Transaction } from '../blockchain/index';\nimport type { AtomexNetwork } from '../common/index';\nimport type {\n  Order, OrderBook, Quote, ExchangeSymbol, NewOrderRequest,\n  OrdersSelector, CancelOrderRequest, CancelAllOrdersRequest,\n  SwapsSelector, CurrencyDirection\n} from '../exchange/index';\nimport type { Swap } from '../swaps/index';\nimport { atomexUtils } from '../utils';\nimport type { AtomexClient } from './atomexClient';\n\nexport class MixedApiAtomexClient implements AtomexClient {\n  readonly events: AtomexClient['events'];\n\n  private _isStarted = false;\n\n  constructor(\n    readonly atomexNetwork: AtomexNetwork,\n    protected readonly restAtomexClient: AtomexClient,\n    protected readonly webSocketAtomexClient: AtomexClient\n  ) {\n    atomexUtils.ensureNetworksAreSame(this, restAtomexClient);\n    atomexUtils.ensureNetworksAreSame(this, webSocketAtomexClient);\n\n    this.events = {\n      swapUpdated: this.webSocketAtomexClient.events.swapUpdated,\n      orderBookUpdated: this.webSocketAtomexClient.events.orderBookUpdated,\n      orderUpdated: this.webSocketAtomexClient.events.orderUpdated,\n      topOfBookUpdated: this.webSocketAtomexClient.events.topOfBookUpdated\n    };\n  }\n\n  get isStarted() {\n    return this._isStarted;\n  }\n\n  async start() {\n    if (this.isStarted)\n      return;\n\n    await Promise.all([\n      this.webSocketAtomexClient.start(),\n      this.restAtomexClient.start()\n    ]);\n\n    this._isStarted = true;\n  }\n\n  stop(): void {\n    if (!this.isStarted)\n      return;\n\n    this.webSocketAtomexClient.stop();\n    this.restAtomexClient.stop();\n\n    this._isStarted = false;\n  }\n\n  getOrder(accountAddress: string, orderId: number): Promise<Order | undefined> {\n    return this.restAtomexClient.getOrder(accountAddress, orderId);\n  }\n\n  getOrders(accountAddress: string, selector?: OrdersSelector | undefined): Promise<Order[]> {\n    return this.restAtomexClient.getOrders(accountAddress, selector);\n  }\n\n  getSymbols(): Promise<ExchangeSymbol[]> {\n    return this.restAtomexClient.getSymbols();\n  }\n\n  getTopOfBook(symbols?: string[]): Promise<Quote[]>;\n  getTopOfBook(directions?: CurrencyDirection[]): Promise<Quote[]>;\n  getTopOfBook(symbolsOrDirections?: string[] | CurrencyDirection[]): Promise<Quote[]> {\n    return (this.restAtomexClient.getTopOfBook as (symbolsOrDirections?: string[] | CurrencyDirection[]) => Promise<Quote[]>)(symbolsOrDirections);\n  }\n\n  getOrderBook(symbol: string): Promise<OrderBook | undefined>;\n  getOrderBook(direction: CurrencyDirection): Promise<OrderBook | undefined>;\n  async getOrderBook(symbolOrDirection: string | CurrencyDirection): Promise<OrderBook | undefined> {\n    return (this.restAtomexClient.getOrderBook as (symbolOrDirection: string | CurrencyDirection) => Promise<OrderBook | undefined>)(symbolOrDirection);\n  }\n\n  addOrder(accountAddress: string, newOrderRequest: NewOrderRequest): Promise<number> {\n    return this.restAtomexClient.addOrder(accountAddress, newOrderRequest);\n  }\n\n  cancelOrder(accountAddress: string, cancelOrderRequest: CancelOrderRequest): Promise<boolean> {\n    return this.restAtomexClient.cancelOrder(accountAddress, cancelOrderRequest);\n  }\n\n  cancelAllOrders(accountAddress: string, cancelAllOrdersRequest: CancelAllOrdersRequest): Promise<number> {\n    return this.restAtomexClient.cancelAllOrders(accountAddress, cancelAllOrdersRequest);\n  }\n\n  getSwapTransactions(swap: Swap): Promise<readonly Transaction[]> {\n    return this.restAtomexClient.getSwapTransactions(swap);\n  }\n\n  getSwap(swapId: number, accountAddress: string): Promise<Swap | undefined>;\n  getSwap(swapId: number, accountAddresses: string[]): Promise<Swap | undefined>;\n  getSwap(swapId: number, addressOrAddresses: string | string[]): Promise<Swap | undefined> {\n    return (this.restAtomexClient.getSwap as (swapId: number, addressOrAddresses: string | string[]) => Promise<Swap | undefined>)(swapId, addressOrAddresses);\n  }\n\n  getSwaps(accountAddress: string, selector?: SwapsSelector): Promise<Swap[]>;\n  getSwaps(accountAddresses: string[], selector?: SwapsSelector): Promise<Swap[]>;\n  getSwaps(addressOrAddresses: string | string[], selector?: SwapsSelector): Promise<Swap[]> {\n    return (this.restAtomexClient.getSwaps as (addressOrAddresses: string | string[], selector?: SwapsSelector) => Promise<Swap[]>)(addressOrAddresses, selector);\n  }\n}\n", "import type { AtomexContext } from '../../atomex/index';\nimport { MixedApiAtomexClient, RestAtomexClient, WebSocketAtomexClient } from '../../clients/index';\nimport type { DeepReadonly } from '../../core/index';\n\nexport type ExchangeServiceDefaultComponentOptions = DeepReadonly<{\n  apiBaseUrl: string;\n  webSocketApiBaseUrl: string;\n}>;\n\nexport const createDefaultExchangeService = (\n  atomexContext: AtomexContext,\n  options: ExchangeServiceDefaultComponentOptions\n) => {\n  return new MixedApiAtomexClient(\n    atomexContext.atomexNetwork,\n    new RestAtomexClient({\n      atomexNetwork: atomexContext.atomexNetwork,\n      authorizationManager: atomexContext.managers.authorizationManager,\n      currenciesProvider: atomexContext.providers.currenciesProvider,\n      exchangeSymbolsProvider: atomexContext.providers.exchangeSymbolsProvider,\n      apiBaseUrl: options.apiBaseUrl,\n    }),\n    new WebSocketAtomexClient({\n      atomexNetwork: atomexContext.atomexNetwork,\n      authorizationManager: atomexContext.managers.authorizationManager,\n      currenciesProvider: atomexContext.providers.currenciesProvider,\n      exchangeSymbolsProvider: atomexContext.providers.exchangeSymbolsProvider,\n      webSocketApiBaseUrl: options.webSocketApiBaseUrl\n    })\n  );\n};\n", "export enum AuthTokenSource {\n  Local = 1 << 0,\n  Remote = 1 << 1,\n\n  All = Local | Remote\n}\n", "import type { SignersManager } from '../blockchain/index';\nimport type { AtomexService, AtomexNetwork } from '../common/index';\nimport { EventEmitter, type ToEventEmitters, type PublicEventEmitter } from '../core/index';\nimport type { AuthorizationManagerStore } from '../stores/index';\nimport { atomexUtils, prepareTimeoutDuration } from '../utils/index';\nimport {\n  AuthenticationRequestData, AuthenticationResponseData, AuthorizationManagerOptions,\n  AuthToken, AuthTokenData, AuthTokenSource, AuthorizationParameters\n} from './models/index';\n\ninterface AuthorizationManagerEvents {\n  readonly authorized: PublicEventEmitter<readonly [authToken: AuthToken]>;\n  readonly unauthorized: PublicEventEmitter<readonly [authToken: AuthToken]>;\n  readonly authTokenExpiring: PublicEventEmitter<readonly [expiringAuthToken: AuthToken]>;\n  readonly authTokenExpired: PublicEventEmitter<readonly [expiredAuthToken: AuthToken]>;\n}\n\nexport class AuthorizationManager implements AtomexService {\n  readonly events: AuthorizationManagerEvents = {\n    authorized: new EventEmitter(),\n    unauthorized: new EventEmitter(),\n    authTokenExpiring: new EventEmitter(),\n    authTokenExpired: new EventEmitter()\n  };\n\n  protected static readonly DEFAULT_AUTH_MESSAGE = 'Signing in ';\n  protected static readonly DEFAULT_GET_AUTH_TOKEN_URI = '/v1/token';\n  protected static readonly DEFAULT_EXPIRING_NOTIFICATION_TIME_IN_SECONDS = 60;\n\n  readonly atomexNetwork: AtomexNetwork;\n\n  protected readonly signersManager: SignersManager;\n  protected readonly store: AuthorizationManagerStore;\n  protected readonly authorizationUrl: URL;\n  protected readonly expiringNotificationTimeInSeconds: number;\n\n  private readonly _authTokenData: Map<string, AuthTokenData> = new Map();\n\n  private _isStarted = false;\n\n  constructor(options: AuthorizationManagerOptions) {\n    this.atomexNetwork = options.atomexNetwork;\n    this.store = options.store;\n    this.signersManager = options.signersManager;\n\n    atomexUtils.ensureNetworksAreSame(this, this.signersManager);\n\n    this.authorizationUrl = new URL(AuthorizationManager.DEFAULT_GET_AUTH_TOKEN_URI, options.authorizationBaseUrl);\n    this.expiringNotificationTimeInSeconds = options.expiringNotificationTimeInSeconds || AuthorizationManager.DEFAULT_EXPIRING_NOTIFICATION_TIME_IN_SECONDS;\n  }\n\n  get isStarted() {\n    return this._isStarted;\n  }\n\n  async start(): Promise<void> {\n    if (this.isStarted)\n      return;\n\n    this._isStarted = true;\n  }\n\n  stop(): void {\n    if (!this.isStarted)\n      return;\n\n    for (const authTokenDataTuple of this.authTokenData)\n      this.untrackAuthToken(authTokenDataTuple[1].watcherId);\n\n    this._isStarted = false;\n  }\n\n  protected get authTokenData(): ReadonlyMap<string, AuthTokenData> {\n    return this._authTokenData;\n  }\n\n  getAuthToken(address: string): AuthToken | undefined {\n    return this.authTokenData.get(address)?.authToken;\n  }\n\n  async authorize({\n    address,\n    authTokenSource = AuthTokenSource.All,\n    blockchain,\n    authMessage = AuthorizationManager.DEFAULT_AUTH_MESSAGE\n  }: AuthorizationParameters): Promise<AuthToken | undefined> {\n    if ((authTokenSource & AuthTokenSource.Local) === AuthTokenSource.Local) {\n      const authToken = this.getAuthToken(address) || (await this.loadAuthTokenFromStore(address));\n\n      if (authToken && !this.isTokenExpiring(authToken))\n        return authToken;\n    }\n\n    if ((authTokenSource & AuthTokenSource.Remote) !== AuthTokenSource.Remote)\n      return undefined;\n\n    const signer = await this.signersManager.findSigner(address, blockchain);\n    if (!signer)\n      throw new Error(`Not found: the corresponding signer by the ${address} address`);\n\n    const timeStamp = this.getAuthorizationTimeStamp(authMessage);\n    const atomexSignature = await signer.sign(authMessage + timeStamp);\n\n    if (atomexSignature.address !== address)\n      throw new Error('Invalid address in the signed data');\n\n    const authenticationResponseData = await this.requestAuthToken({\n      message: authMessage,\n      publicKey: atomexSignature.publicKeyBytes,\n      algorithm: atomexSignature.algorithm,\n      signingDataType: atomexSignature.signingDataType,\n      signature: atomexSignature.signatureBytes,\n      timeStamp\n    });\n\n    const authToken: AuthToken = {\n      value: authenticationResponseData.token,\n      userId: authenticationResponseData.id,\n      address,\n      expired: new Date(authenticationResponseData.expires)\n    };\n\n    await this.registerAuthToken(authToken, true);\n\n    return authToken;\n  }\n\n  async unauthorize(address: string): Promise<boolean> {\n    const authToken = this.getAuthToken(address);\n\n    return authToken ? this.unregisterAuthToken(authToken) : false;\n  }\n\n  protected async loadAuthTokenFromStore(address: string): Promise<AuthToken | undefined> {\n    const authToken = await this.store.getAuthToken(address);\n\n    if (!authToken)\n      return undefined;\n\n    return await this.registerAuthToken(authToken, false);\n  }\n\n  protected async registerAuthToken(authToken: AuthToken, isNeedSave: boolean): Promise<AuthToken | undefined> {\n    const watcherId = this.trackAuthToken(authToken);\n    if (!watcherId)\n      return;\n\n    const authTokenData = {\n      authToken,\n      watcherId\n    };\n    this._authTokenData.set(authToken.address, authTokenData);\n\n    if (isNeedSave)\n      authToken = await this.store.upsertAuthToken(authToken.address, authToken);\n\n    (this.events as ToEventEmitters<this['events']>).authorized.emit(authToken);\n    return authToken;\n  }\n\n  protected async unregisterAuthToken(authToken: AuthToken): Promise<boolean> {\n    const authTokenData = this._authTokenData.get(authToken.address);\n    if (!authTokenData)\n      return false;\n\n    this.untrackAuthToken(authTokenData.watcherId);\n    const result = (await this.store.removeAuthToken(authToken) && this._authTokenData.delete(authToken.address));\n\n    if (result)\n      (this.events as ToEventEmitters<this['events']>).unauthorized.emit(authToken);\n\n    return result;\n  }\n\n  protected trackAuthToken(authToken: AuthToken): AuthTokenData['watcherId'] {\n    const tokenDuration = authToken.expired.getTime() - Date.now();\n    if (tokenDuration <= 0) {\n      this.store.removeAuthToken(authToken);\n      (this.events as ToEventEmitters<this['events']>).authTokenExpired.emit(authToken);\n\n      return;\n    }\n\n    const expiringTokenDuration = tokenDuration - (this.expiringNotificationTimeInSeconds * 1000);\n    const watcherId = setTimeout(this.authTokenExpiringTimeoutCallback, prepareTimeoutDuration(expiringTokenDuration), authToken);\n\n    return watcherId;\n  }\n\n  protected untrackAuthToken(authTokenWatcherId: AuthTokenData['watcherId']) {\n    clearTimeout(authTokenWatcherId);\n  }\n\n  protected getAuthorizationTimeStamp(_authMessage: string): number {\n    return Date.now();\n  }\n\n  protected async requestAuthToken(requestData: AuthenticationRequestData): Promise<AuthenticationResponseData> {\n    const response = await fetch(this.authorizationUrl.href, {\n      method: 'POST',\n      headers: {\n        'Accept': 'application/json',\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify(requestData)\n    });\n\n    if (!response.ok)\n      throw new Error(await response.text());\n\n    return response.json();\n  }\n\n  protected authTokenExpiringTimeoutCallback = (authToken: AuthToken) => {\n    const authTokenData = this._authTokenData.get(authToken.address);\n    if (!authTokenData)\n      return;\n\n    clearTimeout(authTokenData.watcherId);\n    const duration = authToken.expired.getTime() - Date.now();\n    const newWatcherId = setTimeout(this.authTokenExpiredTimeoutCallback, prepareTimeoutDuration(duration), authToken);\n\n    this._authTokenData.set(authToken.address, {\n      ...authTokenData,\n      watcherId: newWatcherId\n    });\n    (this.events as ToEventEmitters<this['events']>).authTokenExpiring.emit(authToken);\n  };\n\n  protected authTokenExpiredTimeoutCallback = (authToken: AuthToken) => {\n    this.unregisterAuthToken(authToken);\n    (this.events as ToEventEmitters<this['events']>).authTokenExpired.emit(authToken);\n  };\n\n  protected isTokenExpiring(authToken: AuthToken) {\n    return (authToken.expired.getTime() - Date.now()) <= (this.expiringNotificationTimeInSeconds * 1000);\n  }\n}\n", "import type { AuthToken } from '../../authorization/index';\nimport type { SerializedAuthToken } from './serializedAuthToken';\nimport type { SerializedAuthTokenMapper } from './serializedAuthTokenMapper';\n\nexport class DefaultSerializedAuthTokenMapper implements SerializedAuthTokenMapper {\n  mapAuthTokenToSerializedAuthToken(authToken: AuthToken): SerializedAuthToken | null {\n    return {\n      a: authToken.address,\n      u: authToken.userId,\n      e: authToken.expired.getTime(),\n      v: authToken.value\n    };\n  }\n\n  mapSerializedAuthTokenToAuthToken(serializedAuthToken: SerializedAuthToken): AuthToken | null {\n    return {\n      address: serializedAuthToken.a,\n      userId: serializedAuthToken.u,\n      expired: new Date(serializedAuthToken.e),\n      value: serializedAuthToken.v\n    };\n  }\n}\n", "import type { AuthToken } from '../../index';\nimport type { SerializedAuthTokenMapper } from './serializedAuthTokenMapper';\nimport type { StoreStrategy } from './storeStrategy';\n\nexport class MultipleKeysStoreStrategy implements StoreStrategy {\n  protected static readonly DefaultKeyPrefix = 'authToken:';\n\n  constructor(\n    protected readonly localStorage: Storage,\n    protected readonly serializedAuthTokenMapper: SerializedAuthTokenMapper,\n    readonly keyPrefix: string = MultipleKeysStoreStrategy.DefaultKeyPrefix\n  ) {\n  }\n\n  getAuthToken(address: string): AuthToken | undefined {\n    const rawAuthToken = localStorage.getItem(this.getKey(address));\n\n    return (rawAuthToken && this.serializedAuthTokenMapper.mapSerializedAuthTokenToAuthToken(JSON.parse(rawAuthToken))\n      || undefined);\n  }\n\n  getAuthTokens(addresses: string[]): AuthToken[] {\n    return addresses.map(address => this.getAuthToken(address))\n      .filter(Boolean) as AuthToken[];\n  }\n\n  upsertAuthToken(address: string, authToken: AuthToken): AuthToken {\n    const serializedAuthToken = this.serializedAuthTokenMapper.mapAuthTokenToSerializedAuthToken(authToken);\n    if (!serializedAuthToken)\n      throw new Error(`The authToken of the ${address} address can't be stored: serialization is failed`);\n\n    localStorage.setItem(this.getKey(address), JSON.stringify(serializedAuthToken));\n\n    return authToken;\n  }\n\n  removeAuthToken(address: string): boolean {\n    localStorage.removeItem(this.getKey(address));\n\n    return true;\n  }\n\n  protected getKey(address: string) {\n    return this.keyPrefix + address;\n  }\n}\n", "import type { AuthToken } from '../../index';\nimport type { SerializedAuthToken } from './serializedAuthToken';\nimport type { SerializedAuthTokenMapper } from './serializedAuthTokenMapper';\nimport type { StoreStrategy } from './storeStrategy';\n\ninterface AuthTokensStoreObject {\n  [address: string]: SerializedAuthToken;\n}\n\nexport class SingleKeyStoreStrategy implements StoreStrategy {\n  protected static readonly DefaultKeyPrefix = 'authTokens';\n\n  constructor(\n    protected readonly localStorage: Storage,\n    protected readonly serializedAuthTokenMapper: SerializedAuthTokenMapper,\n    readonly keyPrefix: string = SingleKeyStoreStrategy.DefaultKeyPrefix\n  ) {\n  }\n\n  protected get key() {\n    return this.keyPrefix;\n  }\n\n  getAuthToken(address: string): AuthToken | undefined {\n    const serializedAuthTokensStoreObject = this.getSerializedAuthTokensStoreObject();\n\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return serializedAuthTokensStoreObject[address] && (this.serializedAuthTokenMapper.mapSerializedAuthTokenToAuthToken(serializedAuthTokensStoreObject[address]!)\n      || undefined);\n  }\n\n  getAuthTokens(addresses: string[]): AuthToken[] {\n    const serializedAuthTokensStoreObject = this.getSerializedAuthTokensStoreObject();\n\n    return Object.values(serializedAuthTokensStoreObject)\n      .map(serializedAuthToken => this.serializedAuthTokenMapper.mapSerializedAuthTokenToAuthToken(serializedAuthToken))\n      .filter((authToken): authToken is AuthToken => !!authToken && addresses.indexOf(authToken.address) > -1);\n  }\n\n  upsertAuthToken(address: string, authToken: AuthToken): AuthToken {\n    const serializedAuthTokensStoreObject = this.getSerializedAuthTokensStoreObject();\n    const serializedAuthToken = this.serializedAuthTokenMapper.mapAuthTokenToSerializedAuthToken(authToken);\n    if (!serializedAuthToken)\n      throw new Error(`The authToken of the ${address} address can't be stored: serialization is failed`);\n\n    serializedAuthTokensStoreObject[address] = serializedAuthToken;\n    this.localStorage.setItem(this.key, JSON.stringify(serializedAuthTokensStoreObject));\n\n    return authToken;\n  }\n\n  removeAuthToken(address: string): boolean {\n    const serializedAuthTokensStoreObject = this.getSerializedAuthTokensStoreObject();\n\n    if (!serializedAuthTokensStoreObject[address])\n      return false;\n\n    delete serializedAuthTokensStoreObject[address];\n\n    if (Object.keys(serializedAuthTokensStoreObject).length)\n      this.localStorage.setItem(this.key, JSON.stringify(serializedAuthTokensStoreObject));\n    else\n      this.localStorage.removeItem(this.key);\n\n    return true;\n  }\n\n  protected getSerializedAuthTokensStoreObject(): AuthTokensStoreObject {\n    const rawAuthTokens = this.localStorage.getItem(this.key);\n    if (!rawAuthTokens)\n      return {};\n\n    return JSON.parse(rawAuthTokens);\n  }\n}\n", "import type { AuthToken } from '../../authorization/index';\nimport type { AuthorizationManagerStore } from '../../stores/index';\nimport { DefaultSerializedAuthTokenMapper } from './defaultSerializedAuthTokenMapper';\nimport { MultipleKeysStoreStrategy } from './multipleKeysStoreStrategy';\nimport type { SerializedAuthTokenMapper } from './serializedAuthTokenMapper';\nimport { SingleKeyStoreStrategy } from './singleKeyStoreStrategy';\nimport type { StoreStrategy } from './storeStrategy';\n\nexport type PreDefinedStoreStrategyName = 'single-key' | 'multiple-keys';\n\nexport class LocalStorageAuthorizationManagerStore implements AuthorizationManagerStore {\n  protected readonly storeStrategy: StoreStrategy;\n\n  constructor(\n    storeStrategy: PreDefinedStoreStrategyName | StoreStrategy = 'single-key',\n    serializedAuthTokenMapper: SerializedAuthTokenMapper = new DefaultSerializedAuthTokenMapper()\n  ) {\n    this.storeStrategy = typeof storeStrategy === 'string'\n      ? this.createPreDefinedStoreStrategy(storeStrategy, serializedAuthTokenMapper)\n      : storeStrategy;\n  }\n\n  getAuthToken(address: string): Promise<AuthToken | undefined> {\n    return Promise.resolve(this.storeStrategy.getAuthToken(address));\n  }\n\n  getAuthTokens(...addresses: string[]): Promise<AuthToken[]> {\n    return Promise.resolve(this.storeStrategy.getAuthTokens(addresses));\n  }\n\n  upsertAuthToken(address: string, authToken: AuthToken): Promise<AuthToken> {\n    return Promise.resolve(this.storeStrategy.upsertAuthToken(address, authToken));\n  }\n\n  removeAuthToken(authToken: AuthToken): Promise<boolean>;\n  removeAuthToken(address: string): Promise<boolean>;\n  removeAuthToken(addressOrAuthToken: AuthToken | string): Promise<boolean> {\n    const address = typeof addressOrAuthToken === 'string'\n      ? addressOrAuthToken\n      : addressOrAuthToken.address;\n\n    return Promise.resolve(this.storeStrategy.removeAuthToken(address));\n  }\n\n  private createPreDefinedStoreStrategy(strategyName: PreDefinedStoreStrategyName, serializedAuthTokenMapper: SerializedAuthTokenMapper) {\n    switch (strategyName) {\n      case 'single-key':\n        return new SingleKeyStoreStrategy(globalThis.localStorage, serializedAuthTokenMapper);\n      case 'multiple-keys':\n        return new MultipleKeysStoreStrategy(globalThis.localStorage, serializedAuthTokenMapper);\n      default:\n        throw new Error(`Unknown the store strategy name: ${strategyName}`);\n    }\n  }\n}\n", "import type { AuthToken } from '../authorization/index';\nimport type { AuthorizationManagerStore } from './authorizationManagerStore';\n\nexport class InMemoryAuthorizationManagerStore implements AuthorizationManagerStore {\n  protected readonly authTokensMap: Map<string, AuthToken> = new Map();\n\n  getAuthToken(address: string): Promise<AuthToken | undefined> {\n    return Promise.resolve(this.authTokensMap.get(address));\n  }\n\n  getAuthTokens(...addresses: string[]): Promise<AuthToken[]> {\n    return Promise.resolve(\n      addresses.reduce(\n        (result, address) => {\n          const authToken = this.authTokensMap.get(address);\n          if (authToken)\n            result.push(authToken);\n\n          return result;\n        },\n        [] as AuthToken[]\n      )\n    );\n  }\n\n  upsertAuthToken(address: string, authToken: AuthToken): Promise<AuthToken> {\n    this.authTokensMap.set(address, authToken);\n\n    return Promise.resolve(authToken);\n  }\n\n  removeAuthToken(authToken: AuthToken): Promise<boolean>;\n  removeAuthToken(address: string): Promise<boolean>;\n  removeAuthToken(addressOrAuthToken: AuthToken | string): Promise<boolean> {\n    const address = typeof addressOrAuthToken === 'string'\n      ? addressOrAuthToken\n      : addressOrAuthToken.address;\n\n    return Promise.resolve(this.authTokensMap.delete(address));\n  }\n}\n", "import type { AtomexContext } from '../../atomex/index';\nimport { AuthorizationManager } from '../../authorization/index';\nimport { LocalStorageAuthorizationManagerStore, type PreDefinedStoreStrategyName } from '../../browser/index';\nimport type { DeepReadonly } from '../../core/index';\nimport { InMemoryAuthorizationManagerStore } from '../../stores/index';\nimport type { AtomexBuilderOptions } from '../atomexBuilderOptions';\n\nexport type RequiredAuthorizationManagerDefaultComponentOptions = Pick<AuthorizationManagerDefaultComponentOptions, never>;\n\nexport type AuthorizationManagerDefaultComponentOptions = DeepReadonly<{\n  authorizationBaseUrl: string;\n  store: {\n    node: {\n      //\n    },\n    browser: {\n      storeStrategy: PreDefinedStoreStrategyName;\n    }\n  }\n}>;\n\nexport const createDefaultAuthorizationManager = (\n  atomexContext: AtomexContext,\n  options: AuthorizationManagerDefaultComponentOptions,\n  _builderOptions: DeepReadonly<AtomexBuilderOptions>\n) => {\n  const environment = globalThis.window ? 'browser' : 'node';\n\n  return new AuthorizationManager({\n    atomexNetwork: atomexContext.atomexNetwork,\n    signersManager: atomexContext.managers.signersManager,\n    authorizationBaseUrl: options.authorizationBaseUrl,\n    store: environment === 'browser'\n      ? new LocalStorageAuthorizationManagerStore(options.store.browser.storeStrategy)\n      : new InMemoryAuthorizationManagerStore()\n  });\n};\n", "import type { DeepReadonly } from '../core/index';\nimport type { AuthorizationManagerDefaultComponentOptions } from './atomexComponents';\nimport type { ExchangeServiceDefaultComponentOptions } from './atomexComponents/exchangeService';\n\ntype AtomexConfigNetworkSection = DeepReadonly<{\n  authorization: AuthorizationManagerDefaultComponentOptions,\n  exchange: ExchangeServiceDefaultComponentOptions\n}>;\n\nexport type AtomexConfig = DeepReadonly<{\n  mainnet: AtomexConfigNetworkSection,\n  testnet: AtomexConfigNetworkSection,\n}>;\n\nconst atomexApiBaseUrl = 'https://api.atomex.me';\nconst atomexMainnetConfig: AtomexConfigNetworkSection = {\n  authorization: {\n    authorizationBaseUrl: atomexApiBaseUrl,\n    store: {\n      node: {},\n      browser: {\n        storeStrategy: 'single-key'\n      }\n    }\n  },\n  exchange: {\n    apiBaseUrl: atomexApiBaseUrl,\n    webSocketApiBaseUrl: 'wss://ws.api.atomex.me'\n  }\n};\n\nconst atomexTestApiBaseUrl = 'https://api.test.atomex.me';\nconst atomexTestnetConfig: AtomexConfigNetworkSection = {\n  authorization: {\n    authorizationBaseUrl: atomexTestApiBaseUrl,\n    store: {\n      node: {},\n      browser: {\n        storeStrategy: 'single-key'\n      }\n    }\n  },\n  exchange: {\n    apiBaseUrl: atomexTestApiBaseUrl,\n    webSocketApiBaseUrl: 'wss://ws.api.test.atomex.me'\n  }\n};\n\nexport const config: AtomexConfig = {\n  mainnet: atomexMainnetConfig,\n  testnet: atomexTestnetConfig\n};\n", "import { Atomex, AtomexContext } from '../atomex/index';\nimport type { AtomexBlockchainOptions } from '../atomex/models/index';\nimport type { AuthorizationManager } from '../authorization/index';\nimport { AtomexBlockchainProvider, SignersManager } from '../blockchain/index';\nimport type { DeepReadonly } from '../core/index';\nimport { EthereumBalancesProvider, EthereumBlockchainToolkitProvider, ethereumMainnetCurrencies, EthereumSwapTransactionsProvider, ethereumTestnetCurrencies } from '../ethereum/index';\nimport { ExchangeManager, InMemoryExchangeSymbolsProvider } from '../exchange/index';\nimport { SwapManager } from '../swaps/swapManager';\nimport { TezosBalancesProvider, TezosBlockchainToolkitProvider, tezosMainnetCurrencies, TezosSwapTransactionsProvider, tezosTestnetCurrencies } from '../tezos/index';\nimport type { AtomexBuilderOptions } from './atomexBuilderOptions';\nimport { createDefaultExchangeService } from './atomexComponents/exchangeService';\nimport { AuthorizationManagerDefaultComponentOptions, createDefaultAuthorizationManager } from './atomexComponents/index';\nimport { config } from './atomexConfig';\nimport type { ControlledAtomexContext } from './controlledAtomexContext';\nimport type { CustomAtomexComponentFactory } from './customAtomexComponentFactory';\n\nexport class AtomexBuilder {\n  protected customAuthorizationManagerFactory?: CustomAtomexComponentFactory<AuthorizationManager, AuthorizationManagerDefaultComponentOptions>;\n  protected customSignersManagerFactory?: CustomAtomexComponentFactory<SignersManager>;\n  protected customExchangeManagerFactory?: CustomAtomexComponentFactory<ExchangeManager>;\n\n  private get controlledAtomexContext(): ControlledAtomexContext {\n    return this.atomexContext;\n  }\n\n  constructor(\n    protected readonly options: DeepReadonly<AtomexBuilderOptions>,\n    protected readonly atomexContext: AtomexContext = new AtomexContext(options.atomexNetwork)\n  ) {\n  }\n\n  useAuthorizationManager(customAuthorizationManagerFactory: NonNullable<AtomexBuilder['customAuthorizationManagerFactory']>): AtomexBuilder {\n    this.customAuthorizationManagerFactory = customAuthorizationManagerFactory;\n    return this;\n  }\n\n  useSignersManager(customSignersManagerFactory: NonNullable<AtomexBuilder['customSignersManagerFactory']>): AtomexBuilder {\n    this.customSignersManagerFactory = customSignersManagerFactory;\n    return this;\n  }\n\n  useExchangeManager(customExchangeManagerFactory: NonNullable<AtomexBuilder['customExchangeManagerFactory']>): AtomexBuilder {\n    this.customExchangeManagerFactory = customExchangeManagerFactory;\n    return this;\n  }\n\n  build(): Atomex {\n    const blockchainProvider = new AtomexBlockchainProvider();\n    this.controlledAtomexContext.providers.blockchainProvider = blockchainProvider;\n    this.controlledAtomexContext.providers.currenciesProvider = blockchainProvider;\n    this.controlledAtomexContext.providers.exchangeSymbolsProvider = this.createExchangeSymbolsProvider();\n    this.controlledAtomexContext.managers.signersManager = this.createSignersManager();\n    this.controlledAtomexContext.managers.authorizationManager = this.createAuthorizationManager();\n    const atomexClient = this.createDefaultExchangeService();\n    this.controlledAtomexContext.services.exchangeService = atomexClient;\n    this.controlledAtomexContext.services.swapService = atomexClient;\n    this.controlledAtomexContext.managers.exchangeManager = this.createExchangeManager();\n    this.controlledAtomexContext.managers.swapManager = this.createSwapManager();\n    const blockchains = this.createDefaultBlockchainOptions();\n\n    return new Atomex({\n      atomexContext: this.atomexContext,\n      managers: {\n        signersManager: this.atomexContext.managers.signersManager,\n        authorizationManager: this.atomexContext.managers.authorizationManager,\n        exchangeManager: this.atomexContext.managers.exchangeManager,\n        swapManager: this.atomexContext.managers.swapManager\n      },\n      blockchains\n    });\n  }\n\n  protected createExchangeSymbolsProvider() {\n    return new InMemoryExchangeSymbolsProvider();\n  }\n\n  protected createAuthorizationManager() {\n    const defaultAuthorizationManagerOptions = config[this.atomexContext.atomexNetwork].authorization;\n\n    return this.customAuthorizationManagerFactory\n      ? this.customAuthorizationManagerFactory(this.atomexContext, defaultAuthorizationManagerOptions, this.options)\n      : createDefaultAuthorizationManager(this.atomexContext, defaultAuthorizationManagerOptions, this.options);\n  }\n\n  protected createSignersManager() {\n    return this.customSignersManagerFactory\n      ? this.customSignersManagerFactory(this.atomexContext, this.options)\n      : new SignersManager(this.atomexContext.atomexNetwork);\n  }\n\n  protected createDefaultExchangeService() {\n    const defaultExchangeManagerOptions = config[this.atomexContext.atomexNetwork].exchange;\n\n    return createDefaultExchangeService(this.atomexContext, defaultExchangeManagerOptions);\n  }\n\n  protected createExchangeManager() {\n    return this.customExchangeManagerFactory\n      ? this.customExchangeManagerFactory(this.atomexContext, this.options)\n      : new ExchangeManager(this.atomexContext.services.exchangeService, this.atomexContext.providers.exchangeSymbolsProvider);\n  }\n\n  protected createSwapManager() {\n    return new SwapManager(this.atomexContext.services.swapService);\n  }\n\n  protected createDefaultBlockchainOptions(): Record<string, AtomexBlockchainOptions> {\n    return {\n      tezos: this.createDefaultTezosBlockchainOptions(),\n      ethereum: this.createDefaultEthereumBlockchainOptions()\n    };\n  }\n\n  protected createDefaultTezosBlockchainOptions(): AtomexBlockchainOptions {\n    const balancesProvider = new TezosBalancesProvider();\n    const swapTransactionsProvider = new TezosSwapTransactionsProvider();\n    const blockchainToolkitProvider = new TezosBlockchainToolkitProvider();\n\n    const tezosOptions: AtomexBlockchainOptions = {\n      mainnet: {\n        currencies: tezosMainnetCurrencies,\n        balancesProvider,\n        swapTransactionsProvider,\n        blockchainToolkitProvider,\n        currencyOptions: {}\n      },\n      testnet: {\n        currencies: tezosTestnetCurrencies,\n        balancesProvider,\n        swapTransactionsProvider,\n        blockchainToolkitProvider,\n        currencyOptions: {}\n      }\n    };\n\n    return tezosOptions;\n  }\n\n  protected createDefaultEthereumBlockchainOptions(): AtomexBlockchainOptions {\n    const balancesProvider = new EthereumBalancesProvider();\n    const swapTransactionsProvider = new EthereumSwapTransactionsProvider();\n    const blockchainToolkitProvider = new EthereumBlockchainToolkitProvider();\n\n    const ethereumOptions: AtomexBlockchainOptions = {\n      mainnet: {\n        currencies: ethereumMainnetCurrencies,\n        balancesProvider,\n        swapTransactionsProvider,\n        blockchainToolkitProvider,\n        currencyOptions: {}\n      },\n      testnet: {\n        currencies: ethereumTestnetCurrencies,\n        balancesProvider,\n        swapTransactionsProvider,\n        blockchainToolkitProvider,\n        currencyOptions: {}\n      }\n    };\n\n    return ethereumOptions;\n  }\n}\n", "import type { Atomex } from '../atomex/index';\nimport type { DeepReadonly } from '../core/index';\nimport { AtomexBuilder } from './atomexBuilder';\nimport type { AtomexBuilderOptions } from './atomexBuilderOptions';\n\nexport const createDefaultMainnetAtomex = (options?: DeepReadonly<Omit<AtomexBuilderOptions, 'atomexNetwork'>>): Atomex => {\n  const builder = new AtomexBuilder({ ...options, atomexNetwork: 'mainnet' });\n\n  return builder.build();\n};\n\nexport const createDefaultTestnetAtomex = (options?: DeepReadonly<Omit<AtomexBuilderOptions, 'atomexNetwork'>>): Atomex => {\n  const builder = new AtomexBuilder({ ...options, atomexNetwork: 'testnet' });\n\n  return builder.build();\n};\n", "export * from './atomex';\nexport * from './ethereum';\nexport * from './helpers';\nexport * from './tezos';\nexport * from './fa12';\nexport * from './fa2';\n", "export default {\n  api: {\n    mainnet: {\n      baseUrl: 'https://api.atomex.me'\n    },\n    testnet: {\n      baseUrl: 'https://api.test.atomex.me'\n    },\n    localhost: {\n      baseUrl: 'http://127.0.0.1:5000'\n    }\n  },\n  blockchains: {\n    ethereum: {\n      rpc: {\n        mainnet: {\n          chainID: 1,\n          rpc: 'https://mainnet.infura.io/v3/7cd728d2d3384719a630d836f1693c5c',\n          blockTime: 10\n        },\n        testnet: {\n          chainID: 5,\n          rpc: 'https://goerli.infura.io/v3/7cd728d2d3384719a630d836f1693c5c',\n          blockTime: 10\n        }\n      }\n    },\n    tezos: {\n      rpc: {\n        mainnet: {\n          chainID: 'NetXdQprcVkpaWU',\n          rpc: 'https://rpc.tzkt.io/mainnet/',\n          blockTime: 30,\n          minimalFees: 100,\n          minimalNanotezPerGasUnit: 0.1,\n          minimalNanotezPerByte: 1,\n          costPerByte: 250\n        },\n        testnet: {\n          chainID: 'NetXnHfVqm9iesp',\n          rpc: 'https://rpc.tzkt.io/ithacanet/',\n          blockTime: 15,\n          minimalFees: 100,\n          minimalNanotezPerGasUnit: 0.1,\n          minimalNanotezPerByte: 1,\n          costPerByte: 250\n        }\n      }\n    }\n  },\n  currencies: {\n    ETH: {\n      contracts: {\n        mainnet: {\n          address: '0xe9c251cbb4881f9e056e40135e7d3ea9a7d037df',\n          gasLimit: 200000\n        },\n        testnet: {\n          address: '0x512fe6B803bA327DCeFBF2Cec7De333f761B0f2b',\n          gasLimit: 170000\n        },\n        abi: [\n          {\n            anonymous: false,\n            inputs: [\n              {\n                indexed: true,\n                internalType: 'bytes32',\n                name: '_hashedSecret',\n                type: 'bytes32'\n              }\n            ],\n            name: 'Activated',\n            type: 'event'\n          },\n          {\n            anonymous: false,\n            inputs: [\n              {\n                indexed: true,\n                internalType: 'bytes32',\n                name: '_hashedSecret',\n                type: 'bytes32'\n              },\n              {\n                indexed: false,\n                internalType: 'address',\n                name: '_sender',\n                type: 'address'\n              },\n              {\n                indexed: false,\n                internalType: 'uint256',\n                name: '_value',\n                type: 'uint256'\n              }\n            ],\n            name: 'Added',\n            type: 'event'\n          },\n          {\n            anonymous: false,\n            inputs: [\n              {\n                indexed: true,\n                internalType: 'bytes32',\n                name: '_hashedSecret',\n                type: 'bytes32'\n              },\n              {\n                indexed: true,\n                internalType: 'address',\n                name: '_participant',\n                type: 'address'\n              },\n              {\n                indexed: false,\n                internalType: 'address',\n                name: '_initiator',\n                type: 'address'\n              },\n              {\n                indexed: false,\n                internalType: 'uint256',\n                name: '_refundTimestamp',\n                type: 'uint256'\n              },\n              {\n                indexed: false,\n                internalType: 'uint256',\n                name: '_countdown',\n                type: 'uint256'\n              },\n              {\n                indexed: false,\n                internalType: 'uint256',\n                name: '_value',\n                type: 'uint256'\n              },\n              {\n                indexed: false,\n                internalType: 'uint256',\n                name: '_payoff',\n                type: 'uint256'\n              },\n              {\n                indexed: false,\n                internalType: 'bool',\n                name: '_active',\n                type: 'bool'\n              }\n            ],\n            name: 'Initiated',\n            type: 'event'\n          },\n          {\n            anonymous: false,\n            inputs: [\n              {\n                indexed: true,\n                internalType: 'bytes32',\n                name: '_hashedSecret',\n                type: 'bytes32'\n              },\n              {\n                indexed: false,\n                internalType: 'bytes32',\n                name: '_secret',\n                type: 'bytes32'\n              }\n            ],\n            name: 'Redeemed',\n            type: 'event'\n          },\n          {\n            anonymous: false,\n            inputs: [\n              {\n                indexed: true,\n                internalType: 'bytes32',\n                name: '_hashedSecret',\n                type: 'bytes32'\n              }\n            ],\n            name: 'Refunded',\n            type: 'event'\n          },\n          {\n            constant: true,\n            inputs: [\n              {\n                internalType: 'bytes32',\n                name: '',\n                type: 'bytes32'\n              }\n            ],\n            name: 'swaps',\n            outputs: [\n              {\n                internalType: 'bytes32',\n                name: 'hashedSecret',\n                type: 'bytes32'\n              },\n              {\n                internalType: 'address payable',\n                name: 'initiator',\n                type: 'address'\n              },\n              {\n                internalType: 'address payable',\n                name: 'participant',\n                type: 'address'\n              },\n              {\n                internalType: 'uint256',\n                name: 'refundTimestamp',\n                type: 'uint256'\n              },\n              {\n                internalType: 'uint256',\n                name: 'countdown',\n                type: 'uint256'\n              },\n              {\n                internalType: 'uint256',\n                name: 'value',\n                type: 'uint256'\n              },\n              {\n                internalType: 'uint256',\n                name: 'payoff',\n                type: 'uint256'\n              },\n              {\n                internalType: 'bool',\n                name: 'active',\n                type: 'bool'\n              },\n              {\n                internalType: 'enum Atomex.State',\n                name: 'state',\n                type: 'uint8'\n              }\n            ],\n            payable: false,\n            stateMutability: 'view',\n            type: 'function'\n          },\n          {\n            constant: false,\n            inputs: [\n              {\n                internalType: 'bytes32',\n                name: '_hashedSecret',\n                type: 'bytes32'\n              },\n              {\n                internalType: 'address payable',\n                name: '_participant',\n                type: 'address'\n              },\n              {\n                internalType: 'uint256',\n                name: '_refundTimestamp',\n                type: 'uint256'\n              },\n              {\n                internalType: 'uint256',\n                name: '_payoff',\n                type: 'uint256'\n              }\n            ],\n            name: 'initiate',\n            outputs: [],\n            payable: true,\n            stateMutability: 'payable',\n            type: 'function'\n          },\n          {\n            constant: false,\n            inputs: [\n              {\n                internalType: 'bytes32',\n                name: '_hashedSecret',\n                type: 'bytes32'\n              }\n            ],\n            name: 'add',\n            outputs: [],\n            payable: true,\n            stateMutability: 'payable',\n            type: 'function'\n          },\n          {\n            constant: false,\n            inputs: [\n              {\n                internalType: 'bytes32',\n                name: '_hashedSecret',\n                type: 'bytes32'\n              }\n            ],\n            name: 'activate',\n            outputs: [],\n            payable: false,\n            stateMutability: 'nonpayable',\n            type: 'function'\n          },\n          {\n            constant: false,\n            inputs: [\n              {\n                internalType: 'bytes32',\n                name: '_hashedSecret',\n                type: 'bytes32'\n              },\n              {\n                internalType: 'bytes32',\n                name: '_secret',\n                type: 'bytes32'\n              }\n            ],\n            name: 'redeem',\n            outputs: [],\n            payable: false,\n            stateMutability: 'nonpayable',\n            type: 'function'\n          },\n          {\n            constant: false,\n            inputs: [\n              {\n                internalType: 'bytes32',\n                name: '_hashedSecret',\n                type: 'bytes32'\n              }\n            ],\n            name: 'refund',\n            outputs: [],\n            payable: false,\n            stateMutability: 'nonpayable',\n            type: 'function'\n          }\n        ]\n      },\n      decimals: {\n        original: 18,\n        displayed: 4\n      },\n      blockchain: 'ethereum'\n    },\n    XTZ: {\n      contracts: {\n        mainnet: {\n          address: 'KT1VG2WtYdSWz5E7chTeAdDPZNy2MpP8pTfL',\n          redeemTxSize: 133,\n          initiateTxSize: 200,\n          gasLimit: 15000\n        },\n        testnet: {\n          address: 'KT1SJMtHZFSPva5AzQEx5btBuQ8BjvXqort3',\n          redeemTxSize: 133,\n          initiateTxSize: 200,\n          gasLimit: 85000\n        },\n        entrypoints: {\n          default: {\n            prim: 'or',\n            args: [\n              {\n                prim: 'or',\n                args: [\n                  {\n                    prim: 'pair',\n                    args: [\n                      {\n                        prim: 'address',\n                        annots: [\n                          '%participant'\n                        ]\n                      },\n                      {\n                        prim: 'pair',\n                        args: [\n                          {\n                            prim: 'pair',\n                            args: [\n                              {\n                                prim: 'bytes',\n                                annots: [\n                                  '%hashed_secret'\n                                ]\n                              },\n                              {\n                                prim: 'timestamp',\n                                annots: [\n                                  '%refund_time'\n                                ]\n                              }\n                            ]\n                          },\n                          {\n                            prim: 'mutez',\n                            annots: [\n                              '%payoff'\n                            ]\n                          }\n                        ],\n                        annots: [\n                          '%settings'\n                        ]\n                      }\n                    ],\n                    annots: [\n                      ':initiate',\n                      '%initiate'\n                    ]\n                  },\n                  {\n                    prim: 'bytes',\n                    annots: [\n                      ':hashed_secret',\n                      '%add'\n                    ]\n                  }\n                ],\n                annots: [\n                  '%fund'\n                ]\n              },\n              {\n                prim: 'or',\n                args: [\n                  {\n                    prim: 'bytes',\n                    annots: [\n                      ':secret',\n                      '%redeem'\n                    ]\n                  },\n                  {\n                    prim: 'bytes',\n                    annots: [\n                      ':hashed_secret',\n                      '%refund'\n                    ]\n                  }\n                ],\n                annots: [\n                  '%withdraw'\n                ]\n              }\n            ]\n          },\n          withdraw: {\n            prim: 'or',\n            args: [\n              {\n                prim: 'bytes',\n                annots: [\n                  ':secret',\n                  '%redeem'\n                ]\n              },\n              {\n                prim: 'bytes',\n                annots: [\n                  ':hashed_secret',\n                  '%refund'\n                ]\n              }\n            ]\n          },\n          refund: {\n            prim: 'bytes',\n            annots: [\n              ':hashed_secret'\n            ]\n          },\n          redeem: {\n            prim: 'bytes',\n            annots: [\n              ':secret'\n            ]\n          },\n          initiate: {\n            prim: 'pair',\n            args: [\n              {\n                prim: 'address',\n                annots: [\n                  '%participant'\n                ]\n              },\n              {\n                prim: 'pair',\n                args: [\n                  {\n                    prim: 'pair',\n                    args: [\n                      {\n                        prim: 'bytes',\n                        annots: [\n                          '%hashed_secret'\n                        ]\n                      },\n                      {\n                        prim: 'timestamp',\n                        annots: [\n                          '%refund_time'\n                        ]\n                      }\n                    ]\n                  },\n                  {\n                    prim: 'mutez',\n                    annots: [\n                      '%payoff'\n                    ]\n                  }\n                ],\n                annots: [\n                  '%settings'\n                ]\n              }\n            ],\n            annots: [\n              ':initiate'\n            ]\n          },\n          fund: {\n            prim: 'or',\n            args: [\n              {\n                prim: 'pair',\n                args: [\n                  {\n                    prim: 'address',\n                    annots: [\n                      '%participant'\n                    ]\n                  },\n                  {\n                    prim: 'pair',\n                    args: [\n                      {\n                        prim: 'pair',\n                        args: [\n                          {\n                            prim: 'bytes',\n                            annots: [\n                              '%hashed_secret'\n                            ]\n                          },\n                          {\n                            prim: 'timestamp',\n                            annots: [\n                              '%refund_time'\n                            ]\n                          }\n                        ]\n                      },\n                      {\n                        prim: 'mutez',\n                        annots: [\n                          '%payoff'\n                        ]\n                      }\n                    ],\n                    annots: [\n                      '%settings'\n                    ]\n                  }\n                ],\n                annots: [\n                  ':initiate',\n                  '%initiate'\n                ]\n              },\n              {\n                prim: 'bytes',\n                annots: [\n                  ':hashed_secret',\n                  '%add'\n                ]\n              }\n            ]\n          },\n          add: {\n            prim: 'bytes',\n            annots: [\n              ':hashed_secret'\n            ]\n          }\n        }\n      },\n      decimals: {\n        original: 6,\n        displayed: 3\n      },\n      blockchain: 'tezos'\n    },\n    TZBTC: {\n      contracts: {\n        mainnet: {\n          address: 'KT1Ap287P1NzsnToSJdA4aqSNjPomRaHBZSr',\n          tokenAddress: 'KT1PWx2mnDueood7fEmfbBDKx1D9BAnnXitn',\n          redeemTxSize: 133,\n          initiateTxSize: 250,\n          gasLimit: 100000\n        },\n        testnet: {\n          address: 'KT1Jj1jzDQbDRHt4u7M73DUrBDV1napRbNFr',\n          tokenAddress: '',\n          redeemTxSize: 133,\n          initiateTxSize: 250,\n          gasLimit: 100000\n        },\n        entrypoints: {\n          default: {\n            prim: 'or',\n            args: [\n              {\n                prim: 'or',\n                args: [\n                  {\n                    prim: 'pair',\n                    args: [\n                      {\n                        prim: 'pair',\n                        args: [\n                          {\n                            prim: 'pair',\n                            args: [\n                              {\n                                prim: 'bytes',\n                                annots: [\n                                  '%hashedSecret'\n                                ]\n                              },\n                              {\n                                prim: 'address',\n                                annots: [\n                                  '%participant'\n                                ]\n                              }\n                            ]\n                          },\n                          {\n                            prim: 'pair',\n                            args: [\n                              {\n                                prim: 'nat',\n                                annots: [\n                                  '%payoffAmount'\n                                ]\n                              },\n                              {\n                                prim: 'timestamp',\n                                annots: [\n                                  '%refundTime'\n                                ]\n                              }\n                            ]\n                          }\n                        ]\n                      },\n                      {\n                        prim: 'pair',\n                        args: [\n                          {\n                            prim: 'address',\n                            annots: [\n                              '%tokenAddress'\n                            ]\n                          },\n                          {\n                            prim: 'nat',\n                            annots: [\n                              '%totalAmount'\n                            ]\n                          }\n                        ]\n                      }\n                    ],\n                    annots: [\n                      '%initiate'\n                    ]\n                  },\n                  {\n                    prim: 'bytes',\n                    annots: [\n                      '%redeem'\n                    ]\n                  }\n                ]\n              },\n              {\n                prim: 'bytes',\n                annots: [\n                  '%refund'\n                ]\n              }\n            ]\n          },\n          refund: {\n            prim: 'bytes'\n          },\n          redeem: {\n            prim: 'bytes'\n          },\n          initiate: {\n            prim: 'pair',\n            args: [\n              {\n                prim: 'pair',\n                args: [\n                  {\n                    prim: 'pair',\n                    args: [\n                      {\n                        prim: 'bytes',\n                        annots: [\n                          '%hashedSecret'\n                        ]\n                      },\n                      {\n                        prim: 'address',\n                        annots: [\n                          '%participant'\n                        ]\n                      }\n                    ]\n                  },\n                  {\n                    prim: 'nat',\n                    annots: [\n                      '%payoffAmount'\n                    ]\n                  },\n                  {\n                    prim: 'timestamp',\n                    annots: [\n                      '%refundTime'\n                    ]\n                  }\n                ]\n              },\n              {\n                prim: 'address',\n                annots: [\n                  '%tokenAddress'\n                ]\n              },\n              {\n                prim: 'nat',\n                annots: [\n                  '%totalAmount'\n                ]\n              }\n            ]\n          }\n        }\n      },\n      decimals: {\n        original: 8,\n        displayed: 4\n      },\n      blockchain: 'tezos'\n    },\n    USDT_XTZ: {\n      contracts: {\n        mainnet: {\n          address: 'KT1Ays1Chwx3ArnHGoQXchUgDsvKe9JboUjj',\n          tokenAddress: 'KT1XnTn74bUtxHfDtBmm2bGZAQfhPbvKWR8o',\n          redeemTxSize: 20000,\n          initiateTxSize: 20000,\n          gasLimit: 400000\n        },\n        testnet: {\n          address: 'KT1HHjNxi3okxxGJT1SPPhpcs3gMQt8hqixY',\n          tokenAddress: 'KT1BWvRQnVVowZZLGkct9A7sdj5YEe8CdUhR',\n          redeemTxSize: 20000,\n          initiateTxSize: 20000,\n          gasLimit: 400000\n        },\n        entrypoints: {\n          default: {\n            prim: 'or',\n            args: [\n              {\n                prim: 'or',\n                args: [\n                  {\n                    prim: 'pair',\n                    args: [\n                      {\n                        prim: 'pair',\n                        args: [\n                          {\n                            prim: 'pair',\n                            args: [\n                              {\n                                prim: 'bytes',\n                                annots: [\n                                  '%hashedSecret'\n                                ]\n                              },\n                              {\n                                prim: 'address',\n                                annots: [\n                                  '%participant'\n                                ]\n                              }\n                            ]\n                          },\n                          {\n                            prim: 'pair',\n                            args: [\n                              {\n                                prim: 'nat',\n                                annots: [\n                                  '%payoffAmount'\n                                ]\n                              },\n                              {\n                                prim: 'timestamp',\n                                annots: [\n                                  '%refundTime'\n                                ]\n                              }\n                            ]\n                          }\n                        ]\n                      },\n                      {\n                        prim: 'pair',\n                        args: [\n                          {\n                            prim: 'pair',\n                            args: [\n                              {\n                                prim: 'address',\n                                annots: [\n                                  '%tokenAddress'\n                                ]\n                              },\n                              {\n                                prim: 'nat',\n                                annots: [\n                                  '%tokenId'\n                                ]\n                              }\n                            ]\n                          },\n                          {\n                            prim: 'nat',\n                            annots: [\n                              '%totalAmount'\n                            ]\n                          }\n                        ]\n                      }\n                    ],\n                    annots: [\n                      '%initiate'\n                    ]\n                  },\n                  {\n                    prim: 'bytes',\n                    annots: [\n                      '%redeem'\n                    ]\n                  }\n                ]\n              },\n              {\n                prim: 'bytes',\n                annots: [\n                  '%refund'\n                ]\n              }\n            ]\n          },\n          refund: {\n            prim: 'bytes'\n          },\n          redeem: {\n            prim: 'bytes'\n          },\n          initiate: {\n            prim: 'pair',\n            args: [\n              {\n                prim: 'pair',\n                args: [\n                  {\n                    prim: 'pair',\n                    args: [\n                      {\n                        prim: 'bytes',\n                        annots: [\n                          '%hashedSecret'\n                        ]\n                      },\n                      {\n                        prim: 'address',\n                        annots: [\n                          '%participant'\n                        ]\n                      }\n                    ]\n                  },\n                  {\n                    prim: 'nat',\n                    annots: [\n                      '%payoffAmount'\n                    ]\n                  },\n                  {\n                    prim: 'timestamp',\n                    annots: [\n                      '%refundTime'\n                    ]\n                  }\n                ]\n              },\n              {\n                prim: 'pair',\n                args: [\n                  {\n                    prim: 'address',\n                    annots: [\n                      '%tokenAddress'\n                    ]\n                  },\n                  {\n                    prim: 'nat',\n                    annots: [\n                      '%tokenId'\n                    ]\n                  }\n                ]\n              },\n              {\n                prim: 'nat',\n                annots: [\n                  '%totalAmount'\n                ]\n              }\n            ]\n          }\n        }\n      },\n      decimals: {\n        original: 6,\n        displayed: 4\n      },\n      blockchain: 'tezos'\n    }\n  }\n};\n", "import type { AuthorizationManager } from '../authorization';\nimport config from './config';\nimport type {\n  AddOrderRequest,\n  AddSwapRequisites,\n  AuthTokenRequest,\n  AuthTokenResponse,\n  BookQuote,\n  GetOrdersRequest,\n  GetSwapsRequest,\n  Order,\n  OrderBook,\n  OrderPreview,\n  Side,\n  Swap,\n  SymbolData,\n  CurrencyConfig,\n} from './types';\n\ninterface Query {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  [key: string]: any;\n}\n\nexport class Atomex {\n  private _network: 'mainnet' | 'testnet';\n  private _baseUrl: string;\n  private _authToken?: string;\n  private _authorizationManager?: AuthorizationManager;\n\n  constructor(\n    network: 'mainnet' | 'testnet',\n    baseUrl: string,\n    authToken?: string,\n  ) {\n    this._network = network;\n    this._baseUrl = baseUrl;\n    this._authToken = authToken;\n  }\n\n  static create(network: 'mainnet' | 'testnet' | 'localhost'): Atomex {\n    return new Atomex(\n      network == 'mainnet' ? 'mainnet' : 'testnet',\n      config.api[network].baseUrl,\n    );\n  }\n\n  setAuthorizationManager(authorizationManager: AuthorizationManager) {\n    this._authorizationManager = authorizationManager;\n  }\n\n  private getLocalAuthToken(address: string) {\n    const authToken = this._authorizationManager?.getAuthToken(address);\n\n    return authToken?.value;\n  }\n\n  /**\n   * Initialize Atomex authorization token\n   *\n   * @remarks the token can be generated using [[getAuthToken]]\n   *\n   * @param authToken Atomex authorization token with expiration time\n   */\n  setAuthToken(authToken: string) {\n    this._authToken = authToken;\n  }\n\n  private async makeRequest<T>(\n    method: 'get' | 'post' | 'delete',\n    path: string,\n    auth: boolean | string = false,\n    params?: Query,\n    payload?: Query,\n  ): Promise<T> {\n    const url = new URL(path, this._baseUrl);\n    if (params !== undefined) {\n      Object.keys(params).forEach(key =>\n        url.searchParams.append(key, params[key]),\n      );\n    }\n\n    const headers: Record<string, string> = {};\n    if (auth) {\n      const authToken = typeof auth === 'string' ? this.getLocalAuthToken(auth) : this._authToken;\n\n      if (!authToken)\n        throw new Error('Auth token is undefined');\n\n      headers['Authorization'] = `Bearer ${authToken}`;\n    }\n\n    let body = undefined;\n    if (method === 'post' && payload !== undefined) {\n      body = JSON.stringify(payload);\n      headers['Content-Type'] = 'application/json';\n    }\n\n    const response = await fetch(url.toString(), {\n      method,\n      headers,\n      body,\n    });\n    if (response.ok) {\n      return response.json();\n    } else {\n      const errBody = await response.text();\n      throw Error(errBody);\n    }\n  }\n\n  /**\n   * Get Atomex authorization token\n   *\n   * @remarks the message details can be generated using [[getAuthMessage]]\n   *\n   * @param authRequest details of the message, timeStamp and signed message with the algorithm used\n   * @returns atomex authorization token with expiration time\n   */\n  async getAuthToken(\n    authRequest: AuthTokenRequest,\n  ): Promise<AuthTokenResponse> {\n    return this.makeRequest('post', '/v1/Token', false, {}, authRequest);\n  }\n\n  /**\n   * Get list of all available symbols in Atomex\n   *\n   * @returns list of all the symbols and their minimum qty.\n   */\n  async getSymbols(): Promise<SymbolData[]> {\n    return this.makeRequest('get', '/v1/Symbols', false);\n  }\n\n  /**\n   * Get Top of Book Quotes for all or specific Symbols\n   *\n   * @param symbolList an array of Symbols eg. `ETH/BTC` , `XTZ/ETH`. A list of all symbols can be found using [[getSymbols]]\n   * @returns a list of Book Quotes\n   */\n  async getQuotes(symbolList?: string[]): Promise<BookQuote[]> {\n    const symbols =\n      symbolList !== undefined && symbolList.length > 0\n        ? symbolList.join(',')\n        : 'All';\n    return this.makeRequest('get', '/v1/MarketData/quotes', false, { symbols });\n  }\n\n  /**\n   * Get the Order Book for a particular Symbol\n   *\n   * @param symbol a symbol eg. `ETH/BTC`. A list of all symbols can be found using [[getSymbols]]\n   * @returns an order book containing all orders for the particular symbol\n   */\n  async getOrderBook(symbol: string): Promise<OrderBook> {\n    return this.makeRequest('get', '/v1/MarketData/book', false, { symbol });\n  }\n\n  /**\n   * Create a new Order in Atomex\n   *\n   * @param addOrderRequest details of the order being placed\n   * @returns order id\n   */\n  async addOrder(addOrderRequest: AddOrderRequest): Promise<number> {\n    const [baseConfig, quoteConfig] = this.splitSymbol(\n      addOrderRequest.symbol,\n    ).map(x => this.getCurrencyConfig(x)) as [CurrencyConfig, CurrencyConfig];\n    const query: Query = addOrderRequest;\n    query.requisites = {\n      baseCurrencyContract: baseConfig.contractAddress,\n      quoteCurrencyContract: quoteConfig.contractAddress,\n      ...query.requisites,\n    };\n\n    return this.makeRequest<Record<string, number>>(\n      'post',\n      '/v1/Orders',\n      addOrderRequest.requisites?.receivingAddress || true,\n      {},\n      query,\n    ).then(res => res['orderId']!);\n  }\n\n  /**\n   * Query and filter all available orders in Atomex\n   *\n   * @param {string?} address\n   * @param getOrdersRequest optional filters for querying all orders\n   * @returns list of orders\n   */\n  async getOrders(address?: string, getOrdersRequest?: GetOrdersRequest): Promise<Order[]> {\n    return this.makeRequest('get', '/v1/Orders', address || true, { ...getOrdersRequest });\n  }\n\n  /**\n   * Query specific Order using Order ID\n   *\n   * @param orderID order id to query\n   * @param {string?} address\n   * @returns details of requested order\n   */\n  async getOrder(orderID: string, address?: string): Promise<Order> {\n    return this.makeRequest('get', `/v1/Orders/${orderID}`, address || true);\n  }\n\n  /**\n   * Cancel an order request in Atomex\n   *\n   * @param orderID id of order to cancel\n   * @param symbol symbol used in the order. A list of all symbols can be found using [[getSymbols]]\n   * @param side side of the order `Buy` or `Sell`\n   * @param {string?} address\n   * @returns true/false value depending on operation success\n   */\n  async cancelOrder(\n    orderID: string,\n    symbol: string,\n    side: Side,\n    address: string,\n  ): Promise<boolean> {\n    return this.makeRequest<Record<string, boolean>>(\n      'delete',\n      `/v1/Orders/${orderID}`,\n      address || true,\n      { symbol, side },\n    ).then(res => res['result']!);\n  }\n\n  /**\n   * Add Requisites to a Swap in Atomex\n   *\n   * @param swapID id of swap\n   * @param swapRequisites swap requisites being updated\n   * @returns true/false depending on operation success\n   */\n  async addSwapRequisites(\n    swapID: string,\n    swapRequisites: AddSwapRequisites,\n  ): Promise<boolean> {\n    return this.makeRequest<Record<string, boolean>>(\n      'post',\n      `/v1/Swaps/${swapID}/requisites`,\n      swapRequisites?.receivingAddress || true,\n      {},\n      swapRequisites,\n    ).then(res => res['result']!);\n  }\n\n  /**\n   * Query and filter all available swaps in Atomex\n   *\n   * \n   * @param {string?} address\n   * @param getSwapsRequest filters for querying all swaps\n   * @returns a list of swaps\n   */\n  async getSwaps(address?: string, getSwapsRequest?: GetSwapsRequest): Promise<Swap[]> {\n    return this.makeRequest('get', '/v1/Swaps', address || true, { ...getSwapsRequest });\n  }\n\n  /**\n   * Query specific Swap using Swap ID\n   *\n   * @param swapID Atomex internal swap id\n   * @param {string?} address\n   * @returns details of swap requested\n   */\n  async getSwap(swapID: string, address?: string): Promise<Swap> {\n    return this.makeRequest('get', `/v1/Swaps/${swapID}`, address || true);\n  }\n\n  /**\n   * Returns an approximate preview of the requested amount and expected receive amount\n   *\n   * @param orderBook order-book received from [[getOrderBook]]\n   * @param side side for the transaction Buy/Sell\n   * @param amount amount received/sent\n   * @param direction direction for the order - Send/Receive\n   */\n  getOrderPreview(\n    orderBook: OrderBook,\n    side: Side,\n    amount: number,\n    direction: 'Send' | 'Receive',\n  ): OrderPreview {\n    const availablePrices = orderBook.entries\n      .filter(entry => {\n        if (entry.side == side) {\n          return false;\n        }\n        const getOrderSize = () => {\n          switch (side + direction) {\n            case 'BuySend':\n            case 'SellReceive':\n              return amount / entry.price;\n            default:\n              return amount;\n          }\n        };\n        return getOrderSize() <= Math.max(...entry.qtyProfile);\n      })\n      .map(entry => entry.price);\n\n    if (availablePrices.length == 0) {\n      throw new Error(\n        `No matching order found (${direction} ${amount} / ${side})`,\n      );\n    }\n\n    const bestPrice =\n      side == 'Buy'\n        ? Math.min(...availablePrices)\n        : Math.max(...availablePrices);\n    const getExpectedAmount = () => {\n      switch (side + direction) {\n        case 'BuySend':\n        case 'SellReceive':\n          return amount / bestPrice;\n        default:\n          return amount * bestPrice;\n      }\n    };\n    return {\n      price: bestPrice,\n      amountSent: direction == 'Send' ? amount : getExpectedAmount(),\n      amountReceived: direction == 'Receive' ? amount : getExpectedAmount(),\n    };\n  }\n\n  /**\n   * Split Atomex trading pair to base and quote currencies\n   *\n   * @param symbol Atomex trading pair {baseCurrency}/{quoteCurrency}\n   */\n  splitSymbol(symbol: string): [baseCurrency: string, quoteCurrency: string] {\n    const [baseCurrency, quoteCurrency] = symbol.split('/', 2);\n    if (!baseCurrency || !quoteCurrency)\n      throw new Error('Symbol is invalid');\n\n    return [baseCurrency, quoteCurrency];\n  }\n\n  /**\n   * Get currency & network specific configuration\n   *\n   * @param currency L1/L2 token symbol (uppercase)\n   */\n  getCurrencyConfig(currency: string): CurrencyConfig {\n    const currencyEntry = Object.entries(config.currencies).find(\n      ([k, _v]) => k == currency,\n    );\n    if (currencyEntry == undefined) {\n      throw new Error(`No matching config section for ${currency}`);\n    }\n    return {\n      blockchain: currencyEntry[1].blockchain,\n      decimals: currencyEntry[1].decimals.original,\n      displayDecimals: currencyEntry[1].decimals.displayed,\n      contractAddress: currencyEntry[1].contracts[this._network].address,\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      tokenAddress: (currencyEntry[1].contracts[this._network] as any).tokenAddress\n    };\n  }\n\n  /**\n   * Formatting an amount based on currency\n   *\n   * @param amount Amount received / sent\n   * @param currency L1/L2 token symbol (uppercase)\n   */\n  formatAmount(amount: number | string, currency: string): number {\n    const cfg = this.getCurrencyConfig(currency);\n    return typeof amount === 'string'\n      ? parseFloat(parseFloat(amount).toFixed(cfg.displayDecimals))\n      : parseFloat(amount.toFixed(cfg.displayDecimals));\n  }\n\n  /**\n   * Get order side for a particular trading pair given the bridge direction\n   *\n   * @param symbol Atomex trading pair {baseCurrency}/{quoteCurrency}\n   * @param fromCurrency Currency to send\n   * @param toCurrency Currency to receive\n   */\n  getOrderSide(\n    symbol: string,\n    fromCurrency: string,\n    toCurrency: string,\n  ): Side {\n    const [baseCurrency, quoteCurrency] = this.splitSymbol(symbol);\n\n    if (baseCurrency === fromCurrency && quoteCurrency === toCurrency)\n      return 'Sell';\n\n    if (quoteCurrency === fromCurrency && baseCurrency === toCurrency)\n      return 'Buy';\n\n    throw new Error(`Mismatch ${fromCurrency} => ${toCurrency} (${symbol})`);\n  }\n\n  /**\n   * Get maximum available liquidity\n   *\n   * @param orderBook order-book received from [[getOrderBook]]\n   * @param side order side Buy/Sell\n   */\n  getMaxOrderSize(orderBook: OrderBook, side: Side): number {\n    return Math.max(\n      ...orderBook.entries\n        .filter(entry => entry.side != side)\n        .map(entry => Math.max(...entry.qtyProfile)),\n    );\n  }\n}\n", "/* eslint-disable @typescript-eslint/ban-types */\nimport BigNumber from 'bignumber.js';\nimport elliptic from 'elliptic';\nimport Web3 from 'web3';\nimport type { Transaction } from 'web3-core';\nimport type { Contract } from 'web3-eth-contract';\nimport type { AbiInput, AbiItem } from 'web3-utils';\n\nimport type { Atomex } from '../atomex';\nimport config from './config';\nimport { Helpers, now } from './helpers';\nimport type {\n  AuthMessage,\n  InitiateParameters,\n  PartialTransactionBody,\n  RedeemFees,\n  SwapTransactionStatus,\n} from './types';\n\nexport interface Function {\n  types: AbiInput[];\n  signature: string;\n}\n\n/**\n * Ethereum Util class for Ethereum related Atomex helper functions\n */\nexport class EthereumHelpers extends Helpers {\n  private _web3: Web3;\n  private _contract: Contract;\n  private _timeBetweenBlocks: number;\n  private _functions: Map<string, Function>;\n  private _gasLimit: number;\n\n  constructor(\n    atomex: Atomex,\n    web3: Web3,\n    jsonInterface: AbiItem[],\n    contractAddress: string,\n    timeBetweenBlocks: number,\n    gasLimit: number,\n  ) {\n    super(atomex);\n    this._web3 = web3;\n    this._contract = this.createContract(jsonInterface, contractAddress);\n    this._timeBetweenBlocks = timeBetweenBlocks;\n    this._gasLimit = gasLimit;\n    this._functions = new Map<string, Function>();\n    this.initializeFunctions(jsonInterface);\n  }\n\n  private initializeFunctions(jsonInterface: AbiItem[]) {\n    jsonInterface.forEach(item => {\n      if (item.type === 'function') {\n        this._functions.set(item.name!, {\n          types: item.inputs!,\n          signature: this._web3.eth.abi.encodeFunctionSignature(item as AbiItem),\n        });\n      }\n    });\n  }\n\n  /**\n   * Connects to the supported ethereum chain\n   *\n   * @param newAtomex instance of new Atomex class\n   * @param network networks supported by atomex, can be either mainnet or testnet\n   * @param rpcUri optional rpc endpoint to create eth chain client\n   * @returns chain id of the connected chain\n   */\n  static async create(\n    newAtomex: Atomex,\n    network: 'mainnet' | 'testnet',\n    rpcUri?: string,\n  ): Promise<EthereumHelpers> {\n    const networkSettings = config.blockchains.ethereum.rpc[network];\n    if (rpcUri !== undefined) {\n      networkSettings.rpc = rpcUri;\n    }\n\n    const web3 = new Web3(networkSettings.rpc);\n    const chainID = await web3.eth.getChainId();\n    if (networkSettings.chainID !== chainID) {\n      throw new Error(\n        `Wrong chain ID: expected ${networkSettings.chainID}, actual ${chainID}`,\n      );\n    }\n\n    return new EthereumHelpers(\n      newAtomex,\n      web3,\n      config.currencies.ETH.contracts.abi as AbiItem[],\n      config.currencies.ETH.contracts[network].address,\n      networkSettings.blockTime,\n      config.currencies.ETH.contracts[network].gasLimit,\n    );\n  }\n\n  getAuthMessage(message: string, _address?: string): AuthMessage {\n    const nowMillis = Date.now();\n    return {\n      message,\n      timestamp: nowMillis,\n      msgToSign: message + nowMillis.toString(),\n      algorithm: 'Keccak256WithEcdsa:Geth2940',\n    };\n  }\n\n  buildInitiateTransaction(\n    initiateParameters: InitiateParameters,\n  ): PartialTransactionBody {\n    if (initiateParameters.refundTimestamp < now()) {\n      throw new Error(\n        `Swap timestamp is in the past: ${initiateParameters.refundTimestamp}`,\n      );\n    }\n\n    const data: string = this._contract.methods\n      .initiate(\n        '0x' + initiateParameters.secretHash,\n        initiateParameters.receivingAddress,\n        initiateParameters.refundTimestamp,\n        initiateParameters.rewardForRedeem.toString(10),\n      )\n      .encodeABI();\n    return {\n      data,\n      contractAddr: this._contract.options.address,\n      amount: initiateParameters.netAmount.plus(initiateParameters.rewardForRedeem),\n    };\n  }\n\n  buildRedeemTransaction(\n    secret: string,\n    hashedSecret: string,\n  ): PartialTransactionBody {\n    const data = this._contract.methods\n      .redeem(hashedSecret, secret)\n      .encodeABI();\n    return {\n      data,\n      contractAddr: this._contract.options.address,\n    };\n  }\n\n  buildRefundTransaction(secretHash: string): PartialTransactionBody {\n    const data = this._contract.methods.refund(secretHash).encodeABI();\n    return {\n      data,\n      contractAddr: this._contract.options.address,\n    };\n  }\n\n  /**\n   * Get the tx data for Atomex Contract Activate Swap call\n   *\n   * @param hashedSecret hashedSecret to identify swap\n   * @returns contract address and tx data that can be used to make a contract call\n   */\n  buildActivateTransaction(secretHash: string): PartialTransactionBody {\n    const data: string = this._contract.methods\n      .activate(secretHash)\n      .encodeABI();\n    return {\n      data,\n      contractAddr: this._contract.options.address,\n    };\n  }\n\n  parseInitiateParameters(transaction: Transaction): InitiateParameters {\n    const initiateMethod = this._functions.get('initiate')!;\n\n    if (!transaction.input.startsWith(initiateMethod.signature)) {\n      throw new Error(`Unexpected method signature: ${transaction.input}`);\n    }\n\n    const params = this._web3.eth.abi.decodeParameters(\n      initiateMethod.types,\n      transaction.input.slice(initiateMethod.signature.length),\n    );\n\n    return {\n      secretHash: params['_hashedSecret'].slice(2),\n      receivingAddress: params['_participant'],\n      refundTimestamp: parseInt(params['_refundTimestamp']),\n      rewardForRedeem: new BigNumber(\n        this._web3.utils.toBN(params['_payoff']).toString(),\n      ),\n      netAmount: new BigNumber(\n        this._web3.utils\n          .toBN(transaction.value)\n          .sub(this._web3.utils.toBN(params['_payoff']))\n          .toString(),\n      ),\n    };\n  }\n\n  async validateInitiateTransaction(\n    _blockHeight: number,\n    txId: string,\n    secretHash: string,\n    receivingAddress: string,\n    amount: BigNumber | number,\n    payoff: BigNumber | number,\n    minRefundTimestamp: number,\n    minConfirmations = 2,\n  ): Promise<SwapTransactionStatus> {\n    amount = new BigNumber(amount);\n    payoff = new BigNumber(payoff);\n\n    const netAmount = amount.minus(payoff);\n    const transaction = await this.getTransaction(txId);\n\n    try {\n      if (!transaction)\n        throw new Error(`Failed to retrieve transaction: ${txId}`);\n\n      const errors: string[] = [];\n      if (transaction.to?.toLowerCase() !== this._contract.options.address.toLowerCase())\n        errors.push(`Wrong contract address: expect ${this._contract.options.address}, actual ${transaction.to}`);\n\n\n      const initiateParameters = this.parseInitiateParameters(transaction);\n      if (initiateParameters.secretHash !== secretHash)\n        errors.push(`Secret hash: expect ${secretHash}, actual ${initiateParameters.secretHash}`);\n\n      if (initiateParameters.receivingAddress.toLowerCase() !== receivingAddress.toLowerCase())\n        errors.push(`Receiving address: expect ${receivingAddress}, actual ${initiateParameters.receivingAddress}`);\n\n      if (!initiateParameters.netAmount.isEqualTo(netAmount))\n        errors.push(`Net amount: expect ${netAmount.toString(10)}, actual ${initiateParameters.netAmount.toString(10)}`);\n\n      if (initiateParameters.refundTimestamp < minRefundTimestamp)\n        errors.push(`Refund timestamp: minimum ${minRefundTimestamp}, actual ${initiateParameters.refundTimestamp}`);\n\n      if (errors.length) {\n        const errorMessage = errors.reduce(\n          (result, error, index) => `${result}\\n\\t${index + 1}. ${error};`,\n          `Initiate transaction that satisfies the expected criteria is not found in ${txId} contents:`\n        );\n        throw new Error(errorMessage);\n      }\n    } catch (e: any) {\n      return {\n        status: 'Invalid',\n        message: e.message,\n        confirmations: 0,\n        nextBlockETA: 0,\n      };\n    }\n\n    const latestBlock = await this.getBlock('latest');\n    const confirmations = latestBlock.number - (transaction.blockNumber || latestBlock.number);\n\n    const res: SwapTransactionStatus = {\n      status: transaction.blockNumber !== undefined ? 'Included' : 'Pending',\n      confirmations,\n      nextBlockETA: parseInt(latestBlock.timestamp.toString()) + this._timeBetweenBlocks,\n    };\n\n    if (confirmations >= minConfirmations) {\n      res.status = 'Confirmed';\n    }\n\n    return res;\n  }\n\n  private hexSlice(i: number, j: number, bs: string) {\n    return '0x' + bs.slice(i * 2 + 2, j * 2 + 2);\n  }\n\n  private getVRS(signature: string) {\n    const vals = [\n      this.hexSlice(64, (signature.length - 2) / 2, signature),\n      this.hexSlice(0, 32, signature),\n      this.hexSlice(32, 64, signature),\n    ] as const;\n\n    return {\n      v: parseInt(vals[0].slice(2), 16),\n      r: vals[1].slice(2),\n      s: vals[2].slice(2),\n    };\n  }\n\n  /**\n   * Recover Ethereum Account Public Key from RLC signature\n   *\n   * @param msg original message, `msgToSign` parameter generated using [[getAuthMessage]]\n   * @param signature signed message\n   * @returns ethereum public key\n   */\n  recoverPublicKey(msg: string, signature: string) {\n    const hash = this._web3.eth.accounts.hashMessage(msg);\n    const vrs = this.getVRS(signature);\n    const secp256k1 = new elliptic.ec('secp256k1');\n    const ecPublicKey = secp256k1.recoverPubKey(\n      Buffer.from(hash.slice(2), 'hex'),\n      vrs,\n      vrs.v < 2 ? vrs.v : 1 - (vrs.v % 2),\n    );\n    return '0x' + ecPublicKey.encode('hex', false);\n  }\n\n  encodePublicKey(pubKey: string): string {\n    if (pubKey.startsWith('0x')) {\n      return pubKey.slice(2);\n    }\n    return pubKey;\n  }\n\n  encodeSignature(signature: string): string {\n    const vrs = this.getVRS(signature);\n    return vrs.r.padStart(64, '0') + vrs.s.padStart(64, '0');\n  }\n\n  async estimateInitiateFees(source: string): Promise<number> {\n    const dummyTx = {\n      receivingAddress: '0x0000000000000000000000000000000000000000',\n      secretHash:\n        '0000000000000000000000000000000000000000000000000000000000000000',\n      refundTimestamp: 2147483647,\n      rewardForRedeem: new BigNumber(0),\n      netAmount: new BigNumber(0),\n    };\n    const txData = this.buildInitiateTransaction(dummyTx);\n    const gasPrice = await this._web3.eth.getGasPrice();\n    const gasEstimate = await this._web3.eth.estimateGas({\n      from: source,\n      to: txData.contractAddr,\n      data: txData.data,\n      value: txData.amount?.toString(10),\n    });\n    const fee = parseInt(gasPrice) * gasEstimate;\n    return fee;\n  }\n\n  async estimateRedeemFees(_recipient: string): Promise<RedeemFees> {\n    const gasPrice = await this._web3.eth.getGasPrice();\n    const fee = parseInt(gasPrice) * this._gasLimit;\n    return {\n      totalCost: fee,\n      rewardForRedeem: 2 * fee,\n    };\n  }\n\n  isValidAddress(address: string): boolean {\n    return this._web3.utils.isAddress(address);\n  }\n\n  private getTransaction(txId: string) {\n    return this._web3.eth.getTransaction(txId);\n  }\n\n  private getBlock(blockId: string | number) {\n    return this._web3.eth.getBlock(blockId);\n  }\n\n  private createContract(jsonInterface: AbiItem[], contractAddress: string) {\n    return new this._web3.eth.Contract(jsonInterface, contractAddress);\n  }\n}\n", "import type BigNumber from 'bignumber.js';\n\nimport type { Atomex } from '../atomex';\nimport type { Swap } from '../swaps';\nimport { converters } from '../utils';\nimport type {\n  AuthMessage,\n  InitiateParameters,\n  PartialTransactionBody,\n  RedeemFees,\n  SwapTransactionStatus,\n} from './types';\n\nexport abstract class Helpers {\n  constructor(readonly atomex: Atomex) {\n  }\n\n  /**\n   * Get the details needed for `getAuthToken` request\n   *\n   * @remarks the `msgToSign` value needs to be signed before being used for Auth\n   * @param message message to include for the Atomex Authentication message\n   * @param address required for Tezos blockchain, in order to determine the EC algorithm\n   * @returns details required for Atomex Auth\n   */\n  abstract getAuthMessage(\n    message: string,\n    address?: string,\n  ): AuthMessage;\n\n  /**\n   * Get the tx data for Atomex Contract Initiate Swap call\n   *\n   * @param swapDetails details of the swap being initiated\n   * @returns contract address and tx data that can be used to make a contract call\n   */\n  abstract buildInitiateTransaction(\n    initiateParameters: InitiateParameters,\n  ): PartialTransactionBody;\n\n  /**\n   * Get the tx data for Atomex Contract Redeem Swap call\n   *\n   * @param secret secret that can used to verify and redeem the funds\n   * @returns contract address and tx data that can be used to make a contract call\n   */\n  abstract buildRedeemTransaction(\n    secret: string,\n    hashedSecret: string,\n  ): PartialTransactionBody;\n\n  /**\n   * Get the tx data for Atomex Contract Refund Swap call\n   *\n   * @param secretHash secretHash to identify swap\n   * @returns contract address and tx data that can be used to make a contract call\n   */\n  abstract buildRefundTransaction(\n    secretHash: string,\n  ): PartialTransactionBody;\n\n  /**\n   * Validate the Swap Details on chain using the tx detail from Atomex\n   * [does not check tx status, use status provided by atomex]\n   *\n   * @param blockHeight block height of the block where the tx is present\n   * @param txID operation/tx hash to identify blockchain transaction\n   * @param expectedData expected swap details that will be used for validation\n   * @param confirmations no. of tx confirmations required\n   * @returns status of tx, current no. of confirms and est. next block generation timestamp.\n   * No. of confirmations and block timestamp is only returned when `status:Included`\n   */\n  abstract validateInitiateTransaction(\n    blockHeight: number,\n    txID: string,\n    secretHash: string,\n    receivingAddress: string,\n    amount: BigNumber | number,\n    payoff: BigNumber | number,\n    minRefundTimestamp: number,\n    minConfirmations: number,\n  ): Promise<SwapTransactionStatus>;\n\n  /**\n   * Encodes Signature in a form compliant with Atomex\n   *\n   * @param signature signature to encode\n   * @returns encoded signature\n   */\n  abstract encodeSignature(signature: string): string;\n\n  /**\n   * Encodes Public Key in a form compliant with Atomex\n   *\n   * @param publicKey public key\n   * @returns encoded public key\n   */\n  abstract encodePublicKey(publicKey: string): string;\n\n  /**\n   * Estimates Initiate fees for a Swap\n   *\n   * @param source the initiator address\n   * @returns the initiate fees for Swap\n   */\n  abstract estimateInitiateFees(source: string): Promise<number>;\n\n  /**\n   * Estimates Miner Fee and Reward for Redeem to be used in a Swap\n   *\n   * @param recipient the counter-party address\n   * @returns the minerFee and the rewardForRedeem\n   */\n  abstract estimateRedeemFees(recipient: string): Promise<RedeemFees>;\n\n  /**\n   * Check validity of an account address\n   * \n   * @param address account address\n   * @returns true if valid, else false\n   */\n  abstract isValidAddress(address: string): boolean;\n\n  validateInitiateTransactionBySwap(swap: Swap): Promise<SwapTransactionStatus> {\n    const initiateTransaction = swap.counterParty.transactions.find(transaction => transaction.type === 'Lock');\n    if (!initiateTransaction)\n      return Promise.resolve({\n        status: 'NotFound',\n        confirmations: 0,\n        nextBlockETA: 0\n      });\n\n    const toCurrency = this.atomex.getCurrency(swap.to.currencyId);\n    if (!toCurrency)\n      throw new Error(`Config of the \"${swap.to.currencyId}\" not found`);\n\n    return this.validateInitiateTransaction(\n      initiateTransaction.blockId,\n      initiateTransaction.id,\n      swap.secretHash,\n      swap.user.requisites.receivingAddress,\n      converters.tokensAmountToNat(swap.to.amount, toCurrency.decimals),\n      converters.tokensAmountToNat(swap.user.requisites.rewardForRedeem, toCurrency.decimals),\n      0,\n      2\n    );\n  }\n}\n\nexport const dt2ts = (isoTime: Date | string): number =>\n  Math.round(new Date(isoTime).getTime() / 1000);\n\nexport const now = (): number => Math.round(Date.now() / 1000);\n", "import { ParameterSchema } from '@taquito/michelson-encoder';\nimport {\n  BlockResponse,\n  OperationContentsAndResultTransaction,\n  OpKind,\n} from '@taquito/rpc';\nimport { TezosToolkit } from '@taquito/taquito';\nimport {\n  b58cdecode,\n  prefix,\n  validateAddress,\n  ValidationResult,\n} from '@taquito/utils';\nimport BigNumber from 'bignumber.js';\n\nimport type { Atomex } from '../atomex';\nimport config from './config';\nimport { dt2ts, Helpers, now } from './helpers';\nimport type {\n  Algorithm,\n  AuthMessage,\n  InitiateParameters,\n  PartialTransactionBody,\n  RedeemFees,\n  SwapTransactionStatus,\n  TezosBasedCurrency,\n  Network\n} from './types';\n\nconst formatTimestamp = (timestamp: number) => {\n  return new Date(timestamp * 1000).toISOString().slice(0, -5) + 'Z';\n};\n\n/**\n * Tezos Util class for Tezos related Atomex helper functions\n */\nexport class TezosHelpers extends Helpers {\n  protected _tezos: TezosToolkit;\n  protected _contractAddress: string;\n  protected _timeBetweenBlocks: number;\n  protected _entrypoints: Map<string, ParameterSchema>;\n  protected _gasLimit: number;\n  protected _minimalFees: number;\n  protected _minimalNanotezPerGasUnit: number;\n  protected _minimalNanotezPerByte: number;\n  protected _costPerByte: number;\n  protected _redeemTxSize: number;\n  protected _initiateTxSize: number;\n\n  constructor(\n    atomex: Atomex,\n    tezos: TezosToolkit,\n    entrypoints: Record<string, any>,\n    contractAddress: string,\n    timeBetweenBlocks: number,\n    gasLimit: number,\n    minimalFees: number,\n    minimalNanotezPerGasUnit: number,\n    minimalNanotezPerByte: number,\n    costPerByte: number,\n    redeemTxSize: number,\n    initiateTxSize: number,\n  ) {\n    super(atomex);\n    this._tezos = tezos;\n    this._contractAddress = contractAddress;\n    this._timeBetweenBlocks = timeBetweenBlocks;\n    this._gasLimit = gasLimit;\n    this._minimalFees = minimalFees;\n    this._minimalNanotezPerGasUnit = minimalNanotezPerGasUnit;\n    this._minimalNanotezPerByte = minimalNanotezPerByte;\n    this._costPerByte = costPerByte;\n    this._redeemTxSize = redeemTxSize;\n    this._initiateTxSize = initiateTxSize;\n    this._entrypoints = new Map<string, ParameterSchema>(\n      Object.entries(entrypoints).map(([name, typeExpr]) => {\n        return [name, new ParameterSchema(typeExpr)];\n      }),\n    );\n  }\n\n  /**\n   * Connects to the supported tezos chain\n   *\n   * @param newAtomex instance of new Atomex class\n   * @param network networks supported by atomex, can be either mainnet or testnet\n   * @param currency either native currency (XTZ) or any supported FA1.2/FA2 token symbol\n   * @param rpcUri optional rpc endpoint to create tezos chain client\n   * @returns chain id of the connected chain\n   */\n  static async create(\n    newAtomex: Atomex,\n    network: Network,\n    currency: TezosBasedCurrency = 'XTZ',\n    rpcUri?: string,\n  ): Promise<TezosHelpers> {\n    const networkSettings = config.blockchains.tezos.rpc[network];\n    if (rpcUri !== undefined) {\n      networkSettings.rpc = rpcUri;\n    }\n\n    const tezos = new TezosToolkit(networkSettings.rpc);\n    const chainID = await tezos.rpc.getChainId();\n    if (networkSettings.chainID !== chainID.toString()) {\n      throw new Error(\n        `Wrong chain ID: expected ${networkSettings.chainID}, actual ${chainID}`,\n      );\n    }\n\n    return new TezosHelpers(\n      newAtomex,\n      tezos,\n      config.currencies[currency].contracts.entrypoints,\n      config.currencies[currency].contracts[network].address,\n      config.blockchains.tezos.rpc[network].blockTime,\n      config.currencies[currency].contracts[network].gasLimit,\n      config.blockchains.tezos.rpc[network].minimalFees,\n      config.blockchains.tezos.rpc[network].minimalNanotezPerGasUnit,\n      config.blockchains.tezos.rpc[network].minimalNanotezPerByte,\n      config.blockchains.tezos.rpc[network].costPerByte,\n      config.currencies[currency].contracts[network].redeemTxSize,\n      config.currencies[currency].contracts[network].initiateTxSize,\n    );\n  }\n\n  private getTezosAlgorithm(prefix?: string): Algorithm {\n    switch (prefix) {\n      case 'tz1':\n        return 'Ed25519:Blake2b';\n      case 'tz2':\n        return 'Blake2bWithEcdsa:Secp256k1';\n      case 'tz3':\n        return 'Blake2bWithEcdsa:Secp256r1';\n      default:\n        throw new Error(`Unexpected address prefix: ${prefix}`);\n    }\n  }\n\n  getAuthMessage(message: string, address: string): AuthMessage {\n    const nowMillis = Date.now();\n    return {\n      message,\n      timestamp: nowMillis,\n      msgToSign: message + nowMillis.toString(),\n      algorithm: this.getTezosAlgorithm(address.slice(0, 3)),\n    };\n  }\n\n  buildInitiateTransaction(\n    initiateParameters: InitiateParameters,\n  ): PartialTransactionBody {\n    if (initiateParameters.refundTimestamp < now()) {\n      throw new Error(\n        `Swap timestamp is in the past: ${initiateParameters.refundTimestamp}`,\n      );\n    }\n\n    const parameter = this._entrypoints\n      .get('initiate')\n      ?.Encode(\n        initiateParameters.receivingAddress,\n        initiateParameters.secretHash,\n        formatTimestamp(initiateParameters.refundTimestamp),\n        initiateParameters.rewardForRedeem,\n      );\n    return {\n      data: {\n        entrypoint: 'initiate',\n        value: parameter,\n      },\n      contractAddr: this._contractAddress,\n      amount: initiateParameters.netAmount.plus(initiateParameters.rewardForRedeem),\n    };\n  }\n\n  buildRedeemTransaction(\n    secret: string,\n    _hashedSecret = '',\n  ): PartialTransactionBody {\n    return {\n      data: {\n        entrypoint: 'redeem',\n        value: this._entrypoints.get('redeem')?.Encode(secret),\n      },\n      contractAddr: this._contractAddress,\n    };\n  }\n\n  buildRefundTransaction(secretHash: string): PartialTransactionBody {\n    return {\n      data: {\n        entrypoint: 'refund',\n        value: this._entrypoints.get('refund')?.Encode(secretHash),\n      },\n      contractAddr: this._contractAddress,\n    };\n  }\n\n  /**\n   * Get Block level\n   *\n   * @param blockLevel block level to identify the block\n   * @returns level of the block and block generation time\n   */\n  getBlockDetails(block: BlockResponse) {\n    return {\n      level: block.metadata.level_info!.level,\n      timestamp: dt2ts(block.header.timestamp),\n    };\n  }\n\n  parseInitiateParameters(\n    content: OperationContentsAndResultTransaction,\n  ): InitiateParameters {\n    if (content.parameters === undefined) {\n      throw new Error('Parameters are undefined');\n    }\n\n    const params = this._entrypoints\n      .get(content.parameters.entrypoint)\n      ?.Execute(content.parameters.value);\n    if (params === undefined) {\n      throw new Error(\n        `Unexpected entrypoint: ${content.parameters.entrypoint}`,\n      );\n    }\n\n    const initiateParams = (() => {\n      switch (content.parameters.entrypoint) {\n        case 'initiate':\n          return params;\n        case 'fund':\n        case 'default':\n          return params['initiate'];\n        default:\n          throw new Error(\n            `Unexpected entrypoint: ${content.parameters.entrypoint}`,\n          );\n      }\n    })();\n\n    return {\n      secretHash: initiateParams['settings']['hashed_secret'],\n      receivingAddress: initiateParams['participant'],\n      refundTimestamp: dt2ts(initiateParams['settings']['refund_time']),\n      netAmount: new BigNumber(content.amount).minus(initiateParams['settings']['payoff']),\n      rewardForRedeem: new BigNumber(initiateParams['settings']['payoff']),\n    };\n  }\n\n  findContractCall(\n    block: BlockResponse,\n    txID: string,\n  ): OperationContentsAndResultTransaction[] {\n    const opg = block.operations[3]?.find(opg => opg.hash == txID);\n    if (opg === undefined) {\n      throw new Error(`Operation not found: ${txID} @ ${block.hash}`);\n    }\n\n    const contents = (\n      opg.contents.filter(c => c.kind == 'transaction' && c.destination == this._contractAddress)\n    ) as OperationContentsAndResultTransaction[];\n    if (contents.length === 0) {\n      throw new Error('Unsupported contract version is used');\n    }\n\n    return contents;\n  }\n\n  async validateInitiateTransaction(\n    blockHeight: number,\n    txID: string,\n    secretHash: string,\n    receivingAddress: string,\n    amount: BigNumber | number,\n    payoff: BigNumber | number,\n    minRefundTimestamp: number,\n    minConfirmations = 2,\n  ): Promise<SwapTransactionStatus> {\n    amount = new BigNumber(amount);\n    payoff = new BigNumber(payoff);\n\n    const netAmount = amount.minus(payoff);\n    const block = await this.getBlock(blockHeight);\n\n    try {\n      let errors: string[] = [];\n      const tx = this.findContractCall(block, txID).find(content => {\n        errors = [];\n\n        const initiateParameters = this.parseInitiateParameters(content);\n        if (initiateParameters.secretHash !== secretHash)\n          errors.push(`Secret hash: expect ${secretHash}, actual ${initiateParameters.secretHash}. Counter = ${content.counter}`);\n\n        if (initiateParameters.receivingAddress.toLowerCase() !== receivingAddress.toLowerCase())\n          errors.push(`Receiving address: expect ${receivingAddress}, actual ${initiateParameters.receivingAddress}. Counter = ${content.counter}`);\n\n        if (!initiateParameters.netAmount.isEqualTo(netAmount))\n          errors.push(`Net amount: expect ${netAmount.toString(10)}, actual ${initiateParameters.netAmount.toString(10)}. Counter = ${content.counter}`);\n\n        if (initiateParameters.refundTimestamp < minRefundTimestamp)\n          errors.push(`Refund timestamp: minimum ${minRefundTimestamp}, actual ${initiateParameters.refundTimestamp}. Counter = ${content.counter}`);\n\n        return !errors.length;\n      }, this);\n\n      if (!tx) {\n        const errorMessage = errors.reduce(\n          (result, error, index) => `${result}\\n\\t${index + 1}. ${error};`,\n          `Initiate transaction that satisfies the expected criteria is not found in ${txID} contents:`\n        );\n        throw new Error(errorMessage);\n      }\n    } catch (e: any) {\n      return {\n        status: 'Invalid',\n        message: e.message,\n        confirmations: 0,\n        nextBlockETA: 0,\n      };\n    }\n\n    const headDetails = this.getBlockDetails(\n      await this.getBlock('head')\n    );\n    const txBlockDetails = this.getBlockDetails(block);\n    const confirmations = headDetails.level! - txBlockDetails.level!;\n\n    const res: SwapTransactionStatus = {\n      status: 'Included',\n      confirmations,\n      nextBlockETA: headDetails.timestamp + this._timeBetweenBlocks,\n    };\n\n    if (confirmations >= minConfirmations) {\n      res.status = 'Confirmed';\n    }\n\n    return res;\n  }\n\n  encodePublicKey(pubKey: string): string {\n    const curve = pubKey.substring(0, 2);\n    switch (curve) {\n      case 'ed':\n        return Buffer.from(b58cdecode(pubKey, prefix['edpk'])).toString('hex');\n      case 'p2':\n        return Buffer.from(b58cdecode(pubKey, prefix['p2pk'])).toString('hex');\n      case 'sp':\n        return Buffer.from(b58cdecode(pubKey, prefix['sppk'])).toString('hex');\n      default:\n        throw new Error('Unsupported Public Key Type');\n    }\n  }\n\n  encodeSignature(signature: string): string {\n    const pref = signature.startsWith('sig')\n      ? signature.substring(0, 3)\n      : signature.substring(0, 5);\n    if (Object.prototype.hasOwnProperty.call(prefix, pref)) {\n      return Buffer.from(\n        b58cdecode(\n          signature,\n          Object.getOwnPropertyDescriptor(prefix, pref)?.value,\n        ),\n      ).toString('hex');\n    }\n    throw new Error('Unsupported Signature Type');\n  }\n\n  calcFees(gas = 0, storageDiff = 0, txSize = 0): number {\n    return (\n      this._minimalFees +\n      this._minimalNanotezPerGasUnit * gas +\n      this._minimalNanotezPerByte * txSize +\n      storageDiff * this._costPerByte\n    );\n  }\n\n  async estimateInitiateFees(source: string): Promise<number> {\n    const dummyTx = {\n      receivingAddress: 'tz1Q2prWCrDGFDuGTe7axdt4z9e3QkCqdhmD',\n      secretHash:\n        '169cbd29345af89a0983f28254e71bdd1367890b9876fc8a9ea117c32f6a521b',\n      refundTimestamp: 2147483647,\n      rewardForRedeem: new BigNumber(0),\n      netAmount: new BigNumber(100),\n    };\n\n    const tx = this.buildInitiateTransaction(dummyTx);\n\n    const header = await this._tezos.rpc.getBlockHeader();\n    const contract = await this._tezos.rpc.getContract(source);\n    const op = await this._tezos.rpc.runOperation({\n      chain_id: header.chain_id,\n      operation: {\n        branch: header.hash,\n        signature:\n          'sigUHx32f9wesZ1n2BWpixXz4AQaZggEtchaQNHYGRCoWNAXx45WGW2ua3apUUUAGMLPwAU41QoaFCzVSL61VaessLg4YbbP',\n        contents: [\n          {\n            amount: '0',\n            counter: (parseInt(contract.counter || '0') + 1).toString(),\n            destination: this._contractAddress,\n            fee: this.calcFees(1040000, 60000, this._initiateTxSize).toString(),\n            gas_limit: '1040000', // TODO: move to config\n            kind: OpKind.TRANSACTION,\n            source,\n            storage_limit: '60000', // TODO: move to config\n            parameters: tx.data,\n          },\n        ],\n      },\n    });\n\n    let paidStorageDiff = 0,\n      consumedGas = 0;\n    (op.contents as OperationContentsAndResultTransaction[]).forEach(tx => {\n      if (tx.metadata.operation_result.status !== 'applied') {\n        throw new Error('Some error was encountered while estimating fees');\n      }\n      consumedGas += parseInt(tx.metadata.operation_result.consumed_gas || '0');\n      paidStorageDiff += parseInt(\n        tx.metadata.operation_result.paid_storage_size_diff || '0',\n      );\n    });\n\n    return this.calcFees(consumedGas, paidStorageDiff, this._initiateTxSize);\n  }\n\n  async estimateRedeemFees(recipient: string): Promise<RedeemFees> {\n    let fees = this.calcFees(this._gasLimit, 0, this._redeemTxSize);\n    const revealedKey = await this._tezos.rpc.getManagerKey(recipient);\n    if (revealedKey === null) {\n      fees += 257 * this._costPerByte;\n    }\n    return {\n      totalCost: fees,\n      rewardForRedeem: 2 * fees,\n    };\n  }\n\n  isValidAddress(address: string): boolean {\n    return validateAddress(address) == ValidationResult.VALID;\n  }\n\n  private getBlock(blockId: string | number) {\n    return this._tezos.rpc.getBlock({ block: blockId.toString() });\n  }\n}\n", "import type { OperationContentsAndResultTransaction } from '@taquito/rpc';\nimport { TezosToolkit } from '@taquito/taquito';\nimport BigNumber from 'bignumber.js';\n\nimport type { Atomex } from '../atomex';\nimport config from './config';\nimport { dt2ts } from './helpers';\nimport { TezosHelpers } from './tezos';\nimport type { InitiateParameters, Network, TezosBasedCurrency } from './types';\n\n\n/**\n * TZIP-7 Util class for Tezos FA1.2 tokens related Atomex helper functions\n */\nexport class FA12Helpers extends TezosHelpers {\n\n  /**\n   * Connects to the supported tezos chain\n   *\n   * @param newAtomex instance of new Atomex class\n   * @param network networks supported by atomex, can be either mainnet or testnet\n   * @param currency FA1.2 token symbol\n   * @param rpcUri optional rpc endpoint to create tezos chain client\n   * @returns chain id of the connected chain\n   */\n  static async create(\n    newAtomex: Atomex,\n    network: Network,\n    currency: TezosBasedCurrency,\n    rpcUri?: string,\n  ): Promise<TezosHelpers> {\n    const networkSettings = config.blockchains.tezos.rpc[network];\n    if (rpcUri !== undefined) {\n      networkSettings.rpc = rpcUri;\n    }\n\n    const tezos = new TezosToolkit(networkSettings.rpc);\n    const chainID = await tezos.rpc.getChainId();\n    if (networkSettings.chainID !== chainID.toString()) {\n      throw new Error(\n        `Wrong chain ID: expected ${networkSettings.chainID}, actual ${chainID}`,\n      );\n    }\n\n    return new FA12Helpers(\n      newAtomex,\n      tezos,\n      config.currencies[currency].contracts.entrypoints,\n      config.currencies[currency].contracts[network].address,\n      config.blockchains.tezos.rpc[network].blockTime,\n      config.currencies[currency].contracts[network].gasLimit,\n      config.blockchains.tezos.rpc[network].minimalFees,\n      config.blockchains.tezos.rpc[network].minimalNanotezPerGasUnit,\n      config.blockchains.tezos.rpc[network].minimalNanotezPerByte,\n      config.blockchains.tezos.rpc[network].costPerByte,\n      config.currencies[currency].contracts[network].redeemTxSize,\n      config.currencies[currency].contracts[network].initiateTxSize,\n    );\n  }\n\n  parseInitiateParameters(\n    content: OperationContentsAndResultTransaction,\n  ): InitiateParameters {\n    if (content.parameters === undefined) {\n      throw new Error('Parameters are undefined');\n    }\n\n    const params = this._entrypoints\n      .get(content.parameters.entrypoint)\n      ?.Execute(content.parameters.value);\n    if (params === undefined) {\n      throw new Error(\n        `Unexpected entrypoint: ${content.parameters.entrypoint}`,\n      );\n    }\n\n    const initiateParams = (() => {\n      switch (content.parameters.entrypoint) {\n        case 'initiate':\n          return params;\n        case 'default':\n          return params['initiate'];\n        default:\n          throw new Error(\n            `Unexpected entrypoint: ${content.parameters.entrypoint}`,\n          );\n      }\n    })();\n\n    return {\n      secretHash: initiateParams['hashedSecret'],\n      receivingAddress: initiateParams['participant'],\n      refundTimestamp: dt2ts(initiateParams['refundTime']),\n      netAmount: new BigNumber(initiateParams['totalAmount']).minus(initiateParams['payoffAmount']),\n      rewardForRedeem: new BigNumber(initiateParams['payoffAmount']),\n    };\n  }\n}\n", "import type { OperationContentsAndResultTransaction } from '@taquito/rpc';\nimport { TezosToolkit } from '@taquito/taquito';\nimport BigNumber from 'bignumber.js';\n\nimport type { Atomex } from '../atomex';\nimport config from './config';\nimport { dt2ts } from './helpers';\nimport { TezosHelpers } from './tezos';\nimport type { InitiateParameters, Network, TezosBasedCurrency } from './types';\n\n\nexport class FA2Helpers extends TezosHelpers {\n\n  /**\n   * Connects to the supported tezos chain\n   *\n   * @param newAtomex instance of new Atomex class\n   * @param network networks supported by atomex, can be either mainnet or testnet\n   * @param currency FA2 token symbol\n   * @param rpcUri optional rpc endpoint to create tezos chain client\n   * @returns chain id of the connected chain\n   */\n  static async create(\n    newAtomex: Atomex,\n    network: Network,\n    currency: TezosBasedCurrency,\n    rpcUri?: string,\n  ): Promise<TezosHelpers> {\n    const networkSettings = config.blockchains.tezos.rpc[network];\n    if (rpcUri !== undefined) {\n      networkSettings.rpc = rpcUri;\n    }\n\n    const tezos = new TezosToolkit(networkSettings.rpc);\n    const chainID = await tezos.rpc.getChainId();\n    if (networkSettings.chainID !== chainID.toString()) {\n      throw new Error(\n        `Wrong chain ID: expected ${networkSettings.chainID}, actual ${chainID}`,\n      );\n    }\n\n    return new FA2Helpers(\n      newAtomex,\n      tezos,\n      config.currencies[currency].contracts.entrypoints,\n      config.currencies[currency].contracts[network].address,\n      config.blockchains.tezos.rpc[network].blockTime,\n      config.currencies[currency].contracts[network].gasLimit,\n      config.blockchains.tezos.rpc[network].minimalFees,\n      config.blockchains.tezos.rpc[network].minimalNanotezPerGasUnit,\n      config.blockchains.tezos.rpc[network].minimalNanotezPerByte,\n      config.blockchains.tezos.rpc[network].costPerByte,\n      config.currencies[currency].contracts[network].redeemTxSize,\n      config.currencies[currency].contracts[network].initiateTxSize,\n    );\n  }\n\n  parseInitiateParameters(content: OperationContentsAndResultTransaction): InitiateParameters {\n    if (!content.parameters) {\n      throw new Error('Parameters are undefined');\n    }\n\n    const params = this._entrypoints.get(content.parameters.entrypoint)?.Execute(content.parameters.value);\n    if (!params) {\n      throw new Error(`Unexpected entrypoint: ${content.parameters.entrypoint}`);\n    }\n\n    const initiateParams = this.getInitiateParams(content.parameters.entrypoint, params);\n\n    return {\n      // TODO: return tokenAddress and tokenId\n      secretHash: initiateParams['hashedSecret'],\n      receivingAddress: initiateParams['participant'],\n      refundTimestamp: dt2ts(initiateParams['refundTime']),\n      netAmount: new BigNumber(initiateParams['totalAmount']).minus(initiateParams['payoffAmount']),\n      rewardForRedeem: new BigNumber(initiateParams['payoffAmount']),\n    };\n  }\n\n  private getInitiateParams(entrypoint: string, params: any) {\n    switch (entrypoint) {\n      case 'initiate':\n        return params;\n      case 'default':\n        return params['initiate'];\n      default:\n        throw new Error(\n          `Unexpected entrypoint: ${entrypoint}`,\n        );\n    }\n  }\n}\n"],
  "mappings": "ijBAWO,GAAM,GAAN,KAAsC,CAU3C,YAAqB,EAAwB,CAAxB,eATrB,OAAS,iBACT,OAAS,mBACT,OAAS,eACT,OAAS,WAET,OAAmB,iBAEnB,OAAQ,aAAa,IASnB,GANA,KAAK,cAAgB,EAAQ,cAC7B,KAAK,QAAU,EAAQ,SAAS,eAChC,KAAK,cAAgB,EAAQ,SAAS,qBACtC,KAAK,gBAAkB,EAAQ,SAAS,gBACxC,KAAK,YAAc,EAAQ,SAAS,YAEhC,EAAQ,YACV,OAAW,KAAkB,QAAO,KAAK,EAAQ,WAAW,EAE1D,KAAK,cAAc,GAAY,EAAQ,YAAa,EAAgB,CAC1E,CAEA,GAAI,gBAAgB,CAClB,MAAO,MAAK,cAAc,aAC5B,CAEA,GAAI,YAAY,CACd,MAAO,MAAK,UACd,CAEA,KAAM,QAAuB,CAC3B,AAAI,KAAK,WAGT,MAAM,MAAK,cAAc,MAAM,EAC/B,KAAM,MAAK,gBAAgB,MAAM,EACjC,KAAM,MAAK,YAAY,MAAM,EAE7B,KAAK,WAAa,GACpB,CAEA,MAAa,CACX,AAAI,CAAC,KAAK,WAGV,MAAK,cAAc,KAAK,EACxB,KAAK,gBAAgB,KAAK,EAC1B,KAAK,YAAY,KAAK,EAEtB,KAAK,WAAa,GACpB,CAEA,KAAM,WAAU,EAAgB,CAhElC,UAiEI,KAAM,MAAK,QAAQ,UAAU,CAAM,EAEnC,KAAM,eAAK,QAAQ,cAAb,cAA2B,EAAO,cAAlC,cAA+C,QAAQ,4BAAvD,cAAkF,UAAU,GACpG,CAEA,cAAc,EAAoE,CAChF,GAAM,GAAoB,EAAc,KAAK,aAAa,EACpD,EAAiB,KAAK,eAAiB,UAAY,EAAkB,QAAU,EAAkB,QAEvG,AAAI,GACF,KAAK,cAAc,UAAU,mBAAmB,cAAc,CAAc,CAChF,CAEA,YAAY,EAA4B,CACtC,MAAO,MAAK,cAAc,UAAU,mBAAmB,YAAY,CAAU,CAC/E,CAIA,KAAM,MAAK,EAAqD,EAAiB,GAAiE,CAChJ,GAAI,MAAO,IAA2B,SACpC,KAAM,IAAI,OAAM,sCAAsC,EAExD,GAAM,GAAU,KAAM,MAAK,gBAAgB,SAAS,EAAuB,eAAgB,CAAsB,EAC3G,EAAQ,KAAM,MAAK,gBAAgB,SAAS,EAAuB,eAAgB,CAAO,EAChG,GAAI,CAAC,EACH,KAAM,IAAI,OAAM,OAAO,mBAAyB,EAElD,GAAI,EAAM,SAAW,SACnB,KAAM,IAAI,OAAM,OAAO,uBAA6B,EAEtD,GAAM,GAAQ,KAAM,SAAQ,IAAI,EAAM,QAAQ,IAAI,GAAU,KAAK,YAAY,QAAQ,EAAQ,EAAuB,cAAc,CAAC,CAAC,EACpI,GAAI,CAAC,EAAM,OACT,KAAM,IAAI,OAAM,iBAAiB,EACnC,GAAI,EAAM,KAAK,GAAQ,CAAC,CAAI,EAC1B,KAAM,IAAI,OAAM,gBAAgB,EAGlC,MAAO,GAAM,SAAW,EAAI,EAAM,GAAO,CAC3C,CACF,ECnGO,GAAM,IAAN,KAAoB,CASzB,YAAqB,EAA8B,CAA9B,qBANrB,OAAS,MAET,OAAS,YACT,OAAS,YACT,OAAS,aAGP,KAAK,GAAK,GAAc,YAExB,KAAK,SAAW,GAAI,IAA6B,IAAI,EACrD,KAAK,SAAW,GAAI,IAA6B,IAAI,EACrD,KAAK,UAAY,GAAI,IAA8B,IAAI,CACzD,CACF,EAhBa,EAAN,GACL,EADW,EACI,YAAY,GAiB7B,GAAM,IAAN,KAAmC,CAMjC,YAAqB,EAAwB,CAAxB,eALrB,OAAQ,mBACR,OAAQ,yBACR,OAAQ,oBACR,OAAQ,eAGR,CAEA,GAAI,iBAAiC,CACnC,GAAI,CAAC,KAAK,gBACR,KAAM,IAAI,GAAgC,yBAAyB,EAErE,MAAO,MAAK,eACd,CAEA,GAAY,gBAAe,EAAgC,CACzD,KAAK,gBAAkB,CACzB,CAEA,GAAI,uBAA6C,CAC/C,GAAI,CAAC,KAAK,sBACR,KAAM,IAAI,GAAgC,+BAA+B,EAE3E,MAAO,MAAK,qBACd,CAEA,GAAY,sBAAqB,EAA4C,CAC3E,KAAK,sBAAwB,CAC/B,CAEA,GAAI,kBAAmC,CACrC,GAAI,CAAC,KAAK,iBACR,KAAM,IAAI,GAAgC,0BAA0B,EAEtE,MAAO,MAAK,gBACd,CAEA,GAAY,iBAAgB,EAAkC,CAC5D,KAAK,iBAAmB,CAC1B,CAEA,GAAI,cAA2B,CAC7B,GAAI,CAAC,KAAK,aACR,KAAM,IAAI,GAAgC,sBAAsB,EAElE,MAAO,MAAK,YACd,CAEA,GAAY,aAAY,EAA0B,CAChD,KAAK,aAAe,CACtB,CACF,EAEM,GAAN,KAAmC,CAIjC,YAAqB,EAAwB,CAAxB,eAHrB,OAAQ,oBACR,OAAQ,eAGR,CAEA,GAAI,kBAAmC,CACrC,GAAI,CAAC,KAAK,iBACR,KAAM,IAAI,GAAgC,0BAA0B,EAEtE,MAAO,MAAK,gBACd,CAEA,GAAY,iBAAgB,EAAkC,CAC5D,KAAK,iBAAmB,CAC1B,CAEA,GAAI,cAA2B,CAC7B,GAAI,CAAC,KAAK,aACR,KAAM,IAAI,GAAgC,sBAAsB,EAElE,MAAO,MAAK,YACd,CAEA,GAAY,aAAY,EAA0B,CAChD,KAAK,aAAe,CACtB,CACF,EAEM,GAAN,KAAoC,CAKlC,YAAqB,EAAwB,CAAxB,eAJrB,OAAQ,uBACR,OAAQ,uBACR,OAAQ,2BAGR,CAEA,GAAI,qBAA+C,CACjD,GAAI,CAAC,KAAK,oBACR,KAAM,IAAI,GAAgC,8BAA8B,EAE1E,MAAO,MAAK,mBACd,CAEA,GAAY,oBAAmB,EAA8C,CAC3E,KAAK,oBAAsB,CAC7B,CAEA,GAAI,qBAAyC,CAC3C,GAAI,CAAC,KAAK,oBACR,KAAM,IAAI,GAAgC,8BAA8B,EAE1E,MAAO,MAAK,mBACd,CAEA,GAAY,oBAAmB,EAAwC,CACrE,KAAK,oBAAsB,CAC7B,CAEA,GAAI,0BAA0D,CAC5D,GAAI,CAAC,KAAK,yBACR,KAAM,IAAI,GAAgC,mCAAmC,EAE/E,MAAO,MAAK,wBACd,CAEA,GAAY,yBAAwB,EAAyD,CAC3F,KAAK,yBAA2B,CAClC,CACF,EAEa,EAAN,aAA8C,MAAM,CAIzD,YAAY,EAAuB,CACjC,MAAM,EAAgC,WAAW,CAAa,CAAC,EAJjE,OAAS,QACT,OAAS,iBAKP,KAAK,cAAgB,EACrB,KAAK,KAAO,KAAK,YAAY,IAC/B,CAEA,MAAe,YAAW,EAAuB,CAC/C,MAAO,WAAW,mCACpB,CACF,ECpKA,wRCAA,gCDIO,GAAM,IAAwB,AAAC,GAA4B,CAJlE,MAKE,GAAM,GAAW,KAAI,MAAM,cAAc,IAAxB,cAA2B,IAAI,GAAO,SAAS,EAAK,EAAE,GAGvE,MAAO,IAAI,YAAW,CAAS,CACjC,EAEa,GAAwB,AAAC,GAA8B,EAAO,KAAK,CAAK,EAAE,SAAS,KAAK,EACxF,GAAoB,AAAC,GAA0B,EAAO,KAAK,EAAO,MAAM,EAAE,SAAS,KAAK,EACxF,GAAoB,AAAC,GAA0B,EAAO,KAAK,GAAsB,CAAK,CAAC,EAAE,SAAS,MAAM,EAExG,GAAoB,AAAC,GAA2C,GAAkB,KAAK,UAAU,CAAK,CAAC,EACvG,GAAoB,AAA8D,GAA4B,CACzH,GAAI,CACF,MAAO,MAAK,MAAM,GAAkB,CAAK,CAAC,CAC5C,OACM,EAAN,CACE,MAAO,KACT,CACF,EAEa,GAAoB,CAAC,EAAkC,IAC3D,GAAI,IAAU,CAAY,EAAE,aAAa,IAAM,CAAQ,EAAE,aAAa,EAGlE,GAAuB,CAAC,EAA2B,IACvD,GAAI,IAAU,CAAK,EAAE,aAAa,EAAE,IAAI,IAAM,CAAQ,EAGlD,GAAmB,CAC9B,EACA,EACA,IAEA,GAAQ,GAAU,YAAY,CAAK,EAAI,EAAQ,GAAI,IAAU,CAAK,EAE3D,GAAI,IAAW,EAAoB,QAAQ,EAAe,CAAY,CAAC,GExChF,gHAGO,GAAM,IAAU,AAAC,GACf,MAAM,QAAQ,CAAG,EAGb,GAAkB,AAAC,GACvB,MAAM,QAAQ,CAAG,EAGb,GAAgB,AAA8D,GAClF,GAA4B,CAAK,ECZ1C,6CAEO,GAAM,IAAwB,CACnC,EACA,IACG,CACH,GAAK,OAAO,IAAW,SAAW,EAAS,EAAO,iBAAoB,OAAO,IAAW,SAAW,EAAS,EAAO,eAGnH,KAAM,IAAI,OAAM,wBAAwB,CAC1C,ECVA,kEAAO,GAAM,IAAa,AAAC,GAAuB,CAAlD,MAAqD,UAAU,MAAM,KAAN,cAAU,qBAAsB,EAAM,MAAM,CAAC,GAEtG,GAAY,CAAC,EAAgB,EAAkB,EAAmB,EAAa,MAAQ,CAC3F,GAAI,OAAO,UAAU,WAAa,OAChC,MAAO,GAAO,SAAS,EAAW,CAAU,EAE9C,GAAM,GAAe,EAAO,OAE5B,GAAI,GAAa,GAAgB,GAAc,GAC7C,MAAO,GAET,GAAM,GAAa,EAAY,EAC3B,EAAS,EAAW,OAAO,KAAK,KAAK,EAAa,EAAW,MAAM,CAAC,EAExE,MAAI,GAAO,OAAS,GAClB,GAAS,EAAO,MAAM,EAAG,CAAU,GAE9B,EAAU,EAAS,EAAS,EAAS,CAC9C,EAEa,GAAW,CAAC,EAAgB,EAAmB,EAAa,MAAQ,OAAO,UAAU,WAAa,OAC3G,EAAO,SAAS,EAAW,CAAU,EACrC,GAAU,EAAQ,GAAM,EAAW,CAAU,EAEpC,GAAS,CAAC,EAAgB,EAAmB,EAAa,MAAQ,OAAO,UAAU,SAAW,OACvG,EAAO,OAAO,EAAW,CAAU,EACnC,GAAU,EAAQ,GAAO,EAAW,CAAU,ECrB3C,GAAM,IAAO,AAAC,GAAe,GAAI,SAAc,GAAW,WAAW,EAAS,CAAE,CAAC,EAE3E,GAAyB,AAAC,GAAuB,KAAK,IAAI,EAAY,UAAU,ECHtF,GAAM,GAAN,KAAqB,CAG1B,YAAqB,EAA8B,CAA9B,qBAFrB,OAAiB,WAAwB,GAAI,KAG7C,CAEA,GAAc,UAAuB,CACnC,MAAO,MAAK,QACd,CAEA,UAAU,EAAiC,CACzC,SAAY,sBAAsB,KAAM,CAAM,EAC9C,KAAK,SAAS,IAAI,CAAM,EAEjB,QAAQ,QAAQ,CAAM,CAC/B,CAIA,KAAM,cAAa,EAAkC,EAAuC,CAC1F,GAAM,GAAS,MAAO,IAAoB,SAErC,KAAM,MAAK,WAAW,EAAiB,CAAU,EAClD,EAEJ,MAAO,GAAS,KAAK,SAAS,OAAO,CAAM,EAAI,EACjD,CAEA,KAAM,YAAW,EAAiB,EAAkD,CAClF,GAAI,CAAC,KAAK,QAAQ,KAChB,OAEF,GAAM,GAA8E,CAAC,EACrF,OAAW,KAAU,MAAK,QAAS,CACjC,GAAI,GAAc,EAAO,aAAe,EACtC,SAEF,GAAM,GAAmB,EAAO,WAAW,EAC3C,GAAI,MAAO,IAAqB,SAAU,CACxC,GAAI,IAAqB,EACvB,MAAO,GAEP,QACJ,CAEA,EAAyB,KAAK,EAAiB,KAAK,GAAW,CAAC,EAAQ,CAAO,CAAC,CAAC,CACnF,CAEA,GAAM,GAA0B,KAAM,SAAQ,WAAW,CAAwB,EACjF,OAAW,KAA0B,GACnC,GAAI,EAAuB,SAAW,aAKlC,EAAuB,MAAM,KAAO,EACtC,MAAO,GAAuB,MAAM,EAI1C,CACF,EC5DO,GAAM,IAAN,KAA4E,CACjF,YACW,EACU,EACnB,CAFS,gBACU,+BACjB,CAEJ,WAAW,EAAqC,CAC9C,MAAO,MAAK,yBAAyB,CAAO,CAC9C,CACF,ECGO,GAAM,IAAN,KAA6D,CAA7D,cACL,OAAmB,kBAAqD,GAAI,MAE5E,cAAc,EAAgD,CApBhE,QAqBI,OAAW,KAAY,GAAe,WAAY,CAChD,GAAI,KAAK,gBAAgB,IAAI,EAAS,EAAE,EACtC,KAAM,IAAI,OAAM,mDAAmD,EAErE,GAAM,GAAkB,EAAe,gBAAgB,EAAS,IAC1D,EAAwB,CAC5B,WACA,eAAgB,iBAAiB,eACjC,0BAA2B,EAAe,0BAC1C,gBAAiB,oBAAiB,0BAAjB,OAA4C,KAAK,iCAAiC,EAAU,EAAe,gBAAgB,EAC5I,yBAA0B,oBAAiB,2BAAjB,OAA6C,EAAe,wBACxF,EACA,KAAK,gBAAgB,IAAI,EAAS,GAAI,CAAO,CAC/C,CACF,CAEA,YAAY,EAAkD,CArChE,MAsCI,MAAO,QAAK,gBAAgB,CAAU,IAA/B,cAAkC,QAC3C,CAEA,gBAAgB,EAAsD,CAGpE,MAFgB,MAAK,gBAAgB,IAAI,CAAU,CAGrD,CAEA,AAAU,iCAAiC,EAAoB,EAAwE,CACrI,MAAO,IAAI,IACT,EACA,AAAC,GAAoB,EAAiB,WAAW,EAAS,CAAQ,CACpE,CACF,CACF,ECrDA,+BAMA,GAAI,IAA4B,KAC1B,GAAoB,IACnB,KACH,IAAiB,GAAI,IAAG,WAAW,GAE9B,IAGH,GAAiB,AAAC,GAAyF,CAC/G,GAAM,GAAiB,EAAW,sBAAsB,CAAY,EAEpE,GAAI,EAAe,SAAW,IAAM,EAAe,SAAW,GAC5D,KAAM,IAAI,OAAM,sBAAsB,GAAc,EAGtD,GAAI,GAAI,EAAe,SAAW,GAAK,GAAM,GAAe,KAAQ,GAAK,EAAe,IACxF,MAAI,KAAM,GAAK,IAAM,IACnB,IAAK,IAEQ,CACb,EAAG,GAAsB,EAAe,MAAM,EAAG,EAAE,CAAC,EACpD,EAAG,GAAsB,EAAe,MAAM,GAAI,EAAE,CAAC,EACrD,IACA,kBAAmB,EAAK,EAAI,CAC9B,CAGF,EAEa,GAAmB,CAAC,EAAsB,IAA4B,CACjF,GAAM,GAAoB,GAAe,CAAY,EAE/C,EAAgB,EAAO,KAAK,EAAgB,WAAW,IAAI,EAAI,EAAgB,UAAU,CAAC,EAAI,EAAiB,KAAK,EACpH,EAAc,GAAkB,EAAE,cACtC,EACA,CAAE,EAAG,EAAkB,EAAG,EAAG,EAAkB,CAAE,EACjD,EAAkB,iBACpB,EAEA,MAAO,KAAO,EAAY,OAAO,MAAO,EAAK,CAC/C,ECxCO,GAAM,IAAN,KAA2C,CAKhD,YACW,EACU,EACnB,CAFS,qBACU,YAJrB,OAAS,aAAa,WAMtB,CAEA,KAAM,aAA8B,CAElC,GAAM,GAAU,AADC,MAAM,MAAK,KAAK,IAAI,YAAY,GACxB,GACzB,GAAI,CAAC,EACH,KAAM,IAAI,OAAM,wBAAwB,EAE1C,MAAO,EACT,CAEA,cAAe,CAEf,CAEA,KAAM,MAAK,EAA2C,CACpD,GAAM,GAAU,KAAM,MAAK,WAAW,EAChC,EAAiB,KAAM,MAAK,aAAa,EAAS,CAAO,EACzD,EAAiB,GAAiB,EAAgB,KAAK,KAAK,IAAI,SAAS,YAAY,CAAO,CAAC,EAEnG,MAAO,CACL,UACA,eAAgB,EAAe,WAAW,IAAI,EAAI,EAAe,UAAU,CAAC,EAAI,EAChF,eAAgB,EAAe,UAAU,EAAe,WAAW,IAAI,EAAI,EAAI,EAAG,EAAe,OAAS,CAAC,EAC3G,UAAW,GAAmB,gBAChC,CACF,CAEA,AAAU,aAAa,EAAiB,EAAiB,CACvD,MAAO,IAAI,SAAgB,CAAC,EAAS,IAAW,KAAK,KAAK,IAAI,SAAS,KAAK,EAAS,EAAS,GAAI,CAAC,EAAO,IACjG,EAAY,EAAQ,CAAS,EAAI,EAAO,CAAK,CACrD,CAAC,CACJ,CACF,EA1Ca,EAAN,GACL,EADW,EACK,mBAAmB,+BCJrC,GAAM,IAA2C,CAC/C,GAAI,MACJ,KAAM,WACN,OAAQ,MACR,WAAY,WACZ,SAAU,GACV,KAAM,QACR,EAEa,GAA0E,CACrF,EACF,EAEa,GAA0E,CACrF,EACF,ECbO,GAAM,GAAN,KAA2D,CAChE,WAAW,EAAkB,EAAyC,CACpE,KAAM,IAAI,OAAM,yBAAyB,CAC3C,CACF,ECNO,GAAM,GAAN,KAA2E,CAA3E,cACL,OAAQ,aAAa,IAErB,GAAI,YAAY,CACd,MAAO,MAAK,UACd,CAEA,KAAM,QAAQ,CACZ,AAAI,KAAK,WAGT,MAAK,WAAa,GACpB,CAEA,MAAa,CACX,AAAI,CAAC,KAAK,WAGV,MAAK,WAAa,GACpB,CAEA,oBAAoB,EAA8C,CAChE,KAAM,IAAI,OAAM,yBAAyB,CAC3C,CACF,ECzBO,GAAM,GAAN,KAA6E,CAClF,mBAAmB,EAAqB,EAAsC,CAC5E,KAAM,IAAI,OAAM,yBAAyB,CAC3C,CACA,WAAW,EAAqB,EAAkB,EAAsC,CACtF,KAAM,IAAI,OAAM,yBAAyB,CAC3C,CACA,UAAU,EAAmC,CAC3C,KAAM,IAAI,OAAM,yBAAyB,CAC3C,CACA,aAAa,EAAmC,CAC9C,KAAM,IAAI,OAAM,yBAAyB,CAC3C,CACF,ECfA,sJAMO,GAAM,IAAiC,AAAC,GAA2E,CACxH,GAAM,CAAC,EAAgB,GAAI,EAAe,IAAM,EAAO,MAAM,GAAG,EAEhE,MAAO,CAAC,EAAe,CAAY,CACrC,EAEa,GAAsC,CACjD,EACA,EACA,EACA,EACA,EAAwB,KACgC,CACxD,GAAM,GAA6B,EAAW,iBAAiB,EAAoB,EAAO,SAAS,MAAO,EAAU,WAAW,EACzH,CAAC,EAAiB,GAAkB,GAA+B,EAAO,IAAI,EAEhF,EACA,EAEJ,AAAI,EACF,GAA8B,EAAW,iBAAiB,EAAgB,EAAO,SAAS,cAAe,EAAU,WAAW,EAC9H,EAA6B,EAAW,iBACtC,EAA2B,aAAa,CAA2B,EACnE,EAAO,SAAS,aAChB,EAAU,WACZ,GAGA,GAA6B,EAAW,iBAAiB,EAAgB,EAAO,SAAS,aAAc,EAAU,WAAW,EAC5H,EAA8B,EAAW,iBACvC,EAA2B,IAAI,CAA0B,EACzD,EAAO,SAAS,cAChB,EAAU,UACZ,GAGF,GAAM,GAA4B,EAAW,iBAC3C,GAAI,GAAU,CAAC,EAAE,IAAI,CAA0B,EAC/C,EAAO,SAAS,MAChB,EAAU,WACZ,EAEM,EAAgC,CACpC,WAAY,EACZ,OAAQ,EACR,MAAO,CACT,EAEM,EAA+B,CACnC,WAAY,EACZ,OAAQ,EACR,MAAO,CACT,EAEA,MAAO,KAAS,MACZ,CAAC,EAAc,CAAa,EAC5B,CAAC,EAAe,CAAY,CAClC,EAEa,GAAoB,CAC/B,EACA,EACA,IAC0C,CAC1C,GAAM,GAAqB,GAAG,KAAQ,IAChC,EAAoB,GAAG,KAAM,IAC/B,EACA,EAAa,OAEjB,GAAI,EAAO,gBAAgB,CAAO,EAChC,OAAW,KAAK,GAAS,CACvB,GAAI,EAAE,OAAS,EAAoB,CACjC,EAAS,EACT,KACF,CAEA,GAAI,EAAE,OAAS,EAAmB,CAChC,EAAS,EACT,EAAO,MACP,KACF,CACF,KAGA,GAAS,EAAQ,IAAI,CAAkB,EAClC,GACH,GAAO,MACP,EAAS,EAAQ,IAAI,CAAiB,GAI1C,GAAI,CAAC,EACH,KAAM,IAAI,OAAM,iBAAiB,KAAQ,GAAI,EAE/C,MAAO,CAAC,EAAO,KAAM,CAAI,CAC3B,ECpGA,iCCDO,GAAK,IAAL,CAAK,GACV,WAAQ,GAAR,QACA,WAAS,GAAT,SAEA,QAAM,GAAN,MAJU,YCAL,GAAK,IAAL,CAAK,GACV,WAAQ,GAAR,QACA,WAAS,GAAT,SACA,eAAa,GAAb,aAHU,YCML,GAAM,GAAN,KAAkF,CAAlF,cACH,OAAQ,YAAuC,GAAI,MAEnD,YAAY,EAAgC,CACxC,YAAK,UAAU,IAAI,CAAQ,EACpB,IACX,CAEA,eAAe,EAAgC,CAC3C,MAAI,MAAK,UAAU,IAAI,CAAQ,GAC3B,KAAK,UAAU,OAAO,CAAQ,EAC3B,IACX,CAEA,oBAAqB,CACjB,YAAK,UAAY,GAAI,KACd,IACX,CAEA,QAAQ,EAAS,CACb,AAAI,CAAC,KAAK,UAAU,MAGpB,CAAI,KAAK,UAAU,OAAS,EACxB,KAAK,UAAU,OAAO,EAAE,KAAK,EAAE,MAAM,GAAG,CAAI,EAG5C,CAAC,GAAG,KAAK,SAAS,EAAE,QAAQ,GAAY,EAAS,GAAG,CAAI,CAAC,EAEjE,CACJ,EHtBO,GAAM,GAAN,KAA+C,CAUpD,YACqB,EACA,EACnB,CAFmB,uBACA,uBAXrB,OAAS,SAAgC,CACvC,aAAc,GAAI,GAClB,iBAAkB,GAAI,GACtB,iBAAkB,GAAI,EACxB,GAEA,OAAQ,aAAa,IACrB,OAAQ,kBAAuD,GAAI,MA4KnE,OAAU,oCAAoC,AAAC,GAAwB,CACrE,AAAC,KAAK,OAAO,aAAiE,KAAK,CAAY,CACjG,GAEA,OAAU,wCAAwC,AAAC,GAAgC,CAEjF,KAAK,aAAa,EAAiB,MAAM,EACtC,KAAK,GAAoB,CACxB,AAAI,CAAC,GAGL,MAAK,gBAAgB,IAAI,EAAiB,OAAQ,CAAgB,EACjE,KAAK,OAAO,iBAAyE,KAAK,CAAgB,EAC7G,CAAC,EACA,MAAM,GAAS,QAAQ,MAAM,CAAK,CAAC,CACxC,GAEA,OAAU,wCAAwC,AAAC,GAAoC,CACrF,AAAC,KAAK,OAAO,iBAAyE,KAAK,CAAa,CAC1G,EAzLA,CAEA,GAAI,YAAY,CACd,MAAO,MAAK,UACd,CAEA,KAAM,QAAQ,CACZ,AAAI,KAAK,WAGT,MAAK,aAAa,EAClB,KAAM,MAAK,gBAAgB,MAAM,EACjC,KAAM,MAAK,WAAW,EAEtB,KAAK,WAAa,GACpB,CAEA,MAAO,CACL,AAAI,CAAC,KAAK,YAGV,MAAK,aAAa,EAClB,KAAK,gBAAgB,KAAK,EAE1B,KAAK,WAAa,GACpB,CAEA,SAAS,EAAwB,EAAiB,EAAQ,EAAmE,CAC3H,MAAO,MAAK,gBAAgB,SAAS,EAAgB,CAAO,CAC9D,CAEA,UAAU,EAAwB,EAAuC,EAAQ,EAAyD,CACxI,MAAO,MAAK,gBAAgB,UAAU,EAAgB,CAAQ,CAChE,CAEA,KAAM,WAAU,EAAc,EAAa,EAAqD,CAC9F,GAAK,GAAa,KAAsB,EAAkB,CACxD,GAAM,GAAS,KAAK,gBAAgB,UAAU,CAAI,EAClD,GAAI,EACF,MAAO,EACX,CAEA,GAAK,GAAa,KAAuB,EAAmB,CAC1D,GAAM,GAAU,KAAM,MAAK,gBAAgB,WAAW,EACtD,YAAK,gBAAgB,WAAW,CAAO,EAEhC,KAAK,gBAAgB,UAAU,CAAI,CAC5C,CAGF,CAEA,KAAM,YAAW,EAAa,EAAoD,CAChF,GAAK,GAAa,KAAsB,EAAkB,CACxD,GAAM,GAAU,KAAK,gBAAgB,WAAW,EAChD,GAAI,EAAQ,OAAS,EACnB,MAAO,EACX,CAEA,GAAK,GAAa,KAAuB,EAAmB,CAC1D,GAAM,GAAU,KAAM,MAAK,gBAAgB,WAAW,EACtD,YAAK,gBAAgB,WAAW,CAAO,EAEhC,CACT,CAEA,MAAO,CAAC,CACV,CAIA,aAAa,EAAwE,CACnF,MAAQ,MAAK,gBAAgB,aAA4F,CAAmB,CAC9I,CAIA,KAAM,cAAa,EAA+E,CAChG,GAAI,GAEJ,GAAI,MAAO,IAAsB,SAC/B,EAAS,MACN,CACH,GAAM,GAAkB,KAAK,gBAAgB,cAAc,EAC3D,CAAC,CAAM,EAAI,EAAc,kBAAkB,EAAiB,EAAkB,KAAM,EAAkB,EAAE,CAC1G,CAEA,GAAI,CAAC,EACH,KAAM,IAAI,OAAM,gBAAgB,EAElC,GAAM,GAAY,KAAM,MAAK,gBAAgB,aAAa,CAAM,EAChE,MAAI,IACF,KAAK,gBAAgB,IAAI,EAAQ,CAAS,EAErC,CACT,CAEA,SAAS,EAAwB,EAAmD,CAClF,GAAM,GAAgB,EAAgB,eAAiB,GAAO,EAAE,EAChE,MAAO,MAAK,gBAAgB,SAAS,EAAgB,OAAK,GAAL,CAAsB,eAAc,EAAC,CAC5F,CAEA,YAAY,EAAwB,EAA0D,CAC5F,MAAO,MAAK,gBAAgB,YAAY,EAAgB,CAAkB,CAC5E,CAEA,gBAAgB,EAAwB,EAAiE,CACvG,MAAO,MAAK,gBAAgB,gBAAgB,EAAgB,CAAsB,CACpF,CAEA,KAAM,iBAAgB,EAAmF,CACvG,GAAM,GAAgB,EAAuB,eAAiB,QAAa,EAAuB,eAAiB,KAC/G,GACA,EAAuB,aACrB,EAAS,EAAuB,OAEtC,GAAI,EAAuB,OAAS,kBAClC,KAAM,IAAI,OAAM,0EAA0E,EAE5F,GAAM,CAAC,EAAQ,GAAQ,KAAK,yCAAyC,CAAsB,EACrF,EAAwB,IAAS,OAAS,EAAe,CAAC,EAC1D,EAAiB,KAAK,gBAAgB,UAAU,CAAM,EAC5D,GAAI,CAAC,EACH,KAAM,QAER,GAAM,GAAiB,KAAM,MAAK,mBAAmB,EAAQ,EAAM,EAAuB,KAAM,EAAQ,CAAqB,EAC7H,GAAI,CAAC,EACH,OAEF,GAAM,CAAC,EAAM,GAAM,EAAc,oCAC/B,EACA,EACA,EACA,EAAe,MACf,CACF,EAEA,MAAO,CACL,KAAM,EAAuB,KAC7B,OACA,KACA,OACA,QACF,CACF,CAEA,oBAAoB,EAAmD,CACrE,KAAM,IAAI,OAAM,iBAAiB,CACnC,CAEA,mBAAmB,EAA8B,EAA+D,CAC9G,KAAM,IAAI,OAAM,iBAAiB,CACnC,CAEA,AAAU,cAAe,CACvB,KAAK,gBAAgB,OAAO,aAAa,YAAY,KAAK,iCAAiC,EAC3F,KAAK,gBAAgB,OAAO,iBAAiB,YAAY,KAAK,qCAAqC,EACnG,KAAK,gBAAgB,OAAO,iBAAiB,YAAY,KAAK,qCAAqC,CACrG,CAEA,AAAU,cAAe,CACvB,KAAK,gBAAgB,OAAO,aAAa,eAAe,KAAK,iCAAiC,EAC9F,KAAK,gBAAgB,OAAO,iBAAiB,eAAe,KAAK,qCAAqC,EACtG,KAAK,gBAAgB,OAAO,iBAAiB,eAAe,KAAK,qCAAqC,CACxG,CAuBA,AAAU,yCAAyC,EAAuF,CACxI,GAAI,EAAuB,QAAU,EAAuB,KAC1D,MAAO,CAAC,EAAuB,OAAQ,EAAuB,IAAI,EAEpE,GAAI,EAAuB,MAAQ,EAAuB,GAAI,CAC5D,GAAM,GAAkB,KAAK,gBAAgB,cAAc,EAE3D,MAAO,GAAc,kBAAkB,EAAiB,EAAuB,KAAM,EAAuB,EAAE,CAChH,CAEA,KAAM,IAAI,OAAM,gDAAgD,CAClE,CAEA,KAAgB,oBAAmB,EAAgB,EAAY,EAAsB,EAAmB,EAAgC,CACtI,GAAI,IAAc,kBAChB,OAEF,GAAM,GAAY,KAAM,MAAK,mBAAmB,CAAM,EACtD,GAAI,EAAC,GAGL,OAAW,KAAS,GAAU,QAC5B,GAAI,EAAM,OAAS,GAAS,GAAwB,EAAS,EAAO,IAAI,EAAM,KAAK,GAAG,oBAAoB,KAAK,IAAI,GAAG,EAAM,UAAU,CAAC,EACrI,MAAO,GAGb,CAEA,AAAU,mBAAmB,EAAgB,CAC3C,GAAM,GAAkB,KAAK,gBAAgB,IAAI,CAAM,EAEvD,MAAO,GAAkB,QAAQ,QAAQ,CAAe,EAAI,KAAK,aAAa,CAAM,CACtF,CACF,EIrPO,GAAM,IAAN,KAAgF,CAAhF,cACL,OAAQ,aAA0D,GAAI,MACtE,OAAQ,yBAAoD,CAAC,GAE7D,UAAU,EAA0C,CAClD,MAAO,MAAK,WAAW,IAAI,CAAI,CACjC,CAEA,YAAwC,CACtC,MAAO,MAAK,sBACd,CAEA,eAAqE,CACnE,MAAO,MAAK,UACd,CAEA,WAAW,EAAkD,CAC3D,KAAK,uBAAyB,EAC9B,KAAK,WAAa,KAAK,0BAA0B,CAAe,CAClE,CAEA,AAAU,0BAA0B,EAA2F,CAC7H,GAAM,GAA0D,GAAI,KAEpE,OAAW,KAAU,GACnB,EAAW,IAAI,EAAO,KAAM,CAAM,EAEpC,MAAO,EACT,CACF,EC1BO,GAAM,IAAN,KAA2C,CAOhD,YACqB,EACnB,CADmB,mBAPrB,OAAS,SAA4B,CACnC,YAAa,GAAI,EACnB,GAEA,OAAQ,aAAa,IAmDrB,OAAU,+BAA+B,AAAC,GAAsB,CAC9D,AAAC,KAAK,OAAO,YAA+D,KAAK,CAAW,CAC9F,EAhDA,CAEA,GAAI,YAAY,CACd,MAAO,MAAK,UACd,CAEA,KAAM,QAAuB,CAC3B,AAAI,KAAK,WAGT,MAAK,aAAa,EAClB,KAAM,MAAK,YAAY,MAAM,EAE7B,KAAK,WAAa,GACpB,CAEA,MAAa,CACX,AAAI,CAAC,KAAK,WAGV,MAAK,aAAa,EAClB,KAAK,YAAY,KAAK,EAEtB,KAAK,WAAa,GACpB,CAIA,QAAQ,EAAgB,EAAuC,EAAQ,EAAkE,CACvI,MAAQ,MAAK,YAAY,QAAqF,EAAQ,CAAkB,CAC1I,CAIA,SAAS,EAAuC,EAA0B,EAAQ,EAAwD,CACxI,MAAQ,MAAK,YAAY,SAAkG,EAAoB,CAAQ,CACzJ,CAEA,AAAU,cAAe,CACvB,KAAK,YAAY,OAAO,YAAY,YAAY,KAAK,4BAA4B,CACnF,CAEA,AAAU,cAAe,CACvB,KAAK,YAAY,OAAO,YAAY,eAAe,KAAK,4BAA4B,CACtF,CAKF,ECjEA,kDCAA,2FCAA,8OAMA,GAAM,IAAgC,+CAChC,GAA0B,CAAC,EAAiB,IAAyB,CACzE,GAAM,GAAe,EAAW,kBAAkB,CAAO,EACnD,EAAqB,EAAe,EAAc,EAAgB,EAClE,EAAgB,GAAU,SAAU,GAAmB,OAAS,GAAG,SAAS,EAAE,EAAG,EAAG,GAAG,EAE7F,MAAO,OAAS,EAAgB,CAClC,EAEa,GAAoB,AAAC,GAAoB,EAAW,kBAAkB,CAAO,EAC7E,GAA6B,AAAC,GAAoB,GAAwB,CAAO,EACjF,GAAgC,AAAC,GAAoB,GAAwB,EAAS,EAA6B,EAEnH,GAA2B,AAAC,GAA+B,CACtE,GAAM,GAAS,EAAmB,UAAU,EAAG,EAAmB,WAAW,IAAI,EAAI,EAAI,CAAC,EAE1F,OAAQ,OACD,IAAO,QACP,IAAO,KACV,MAAO,sBAEJ,IAAO,QACP,IAAO,KACV,MAAO,iCAEJ,IAAO,QACP,IAAO,KACV,MAAO,qCAGP,KAAM,IAAI,OAAM,yCAAyC,MAAW,IAAqB,EAE/F,EAEa,GAAkB,AAAC,GAAsB,CACpD,GAAM,GAAmB,EAAU,WAAW,KAAK,EAC/C,EAAU,UAAU,EAAG,CAAC,EACxB,EAAU,UAAU,EAAG,CAAC,EACtB,EAAkB,GAAW,EAAW,GAAO,EAAgB,EAErE,MAAO,QAAO,KAAK,CAAe,EAAE,SAAS,KAAK,CACpD,ED3CO,GAAM,IAAkB,AAAC,GAAsB,CACpD,GAAM,GAAY,GAA2B,CAAS,EAChD,EAAkB,GAAW,EAAW,GAAO,EAAU,EAE/D,MAAO,GAAO,KAAK,CAAe,EAAE,SAAS,KAAK,CACpD,EDAO,GAAM,IAAN,KAAgD,CAGrD,YACW,EACU,EACnB,CAFS,qBACU,oBAJrB,OAAS,aAAa,QAMtB,CAEA,YAA8B,CAC5B,MAAO,MAAK,aAAa,OAAO,CAClC,CAEA,KAAM,eAA4C,CAtBpD,MAuBI,MAAQ,QAAM,MAAK,aAAa,OAAO,iBAAiB,IAAhD,cAAoD,SAC9D,CAEA,KAAM,MAAK,EAA2C,CACpD,GAAM,CAAC,EAAS,EAAW,GAAa,KAAM,SAAQ,IAAI,CACxD,KAAK,WAAW,EAChB,KAAK,aAAa,EAClB,KAAK,aAAa,OAAO,mBAAmB,CAC1C,QAAS,EAAa,8BAA8B,CAAO,EAC3D,YAAa,GAAY,SAC3B,CAAC,CACH,CAAC,EAED,GAAI,CAAC,EACH,KAAM,IAAI,OAAM,yCAAyC,EAE3D,GAAM,GAAY,EAAa,yBAAyB,CAAS,EAC3D,EAAiB,GAAgB,CAAS,EAC1C,EAAiB,GAAgB,EAAU,SAAS,EAE1D,MAAO,CACL,UACA,YACA,iBACA,iBACA,gBAAiB,wBACnB,CACF,CACF,EG3CO,GAAM,IAAN,KAAgD,CAGrD,YACW,EACU,EACnB,CAFS,qBACU,oBAJrB,OAAS,aAAa,QAMtB,CAEA,YAA8B,CAC5B,MAAO,MAAK,aAAa,OAAO,CAClC,CAEA,cAAmC,CArBrC,MAsBI,MAAO,QAAK,aAAa,aAAlB,cAA8B,SACvC,CAEA,KAAM,MAAK,EAA2C,CACpD,GAAM,CAAC,EAAS,EAAW,GAAa,KAAM,SAAQ,IAAI,CACxD,KAAK,WAAW,EAChB,KAAK,aAAa,EAClB,KAAK,aAAa,KAAK,EAAa,8BAA8B,CAAO,CAAC,CAC5E,CAAC,EAED,GAAI,CAAC,EACH,KAAM,IAAI,OAAM,yCAAyC,EAE3D,GAAM,GAAY,EAAa,yBAAyB,CAAS,EAC3D,EAAiB,GAAgB,CAAS,EAC1C,EAAiB,GAAgB,CAAS,EAEhD,MAAO,CACL,UACA,YACA,iBACA,iBACA,gBAAiB,wBACnB,CACF,CACF,ECvCO,GAAM,IAAN,KAA0C,CAK/C,YACW,EACU,EACnB,CAFS,qBACU,cANrB,OAAS,aAAa,SAEtB,OAAmB,kBAMjB,KAAK,eAAiB,KAAK,qBAAqB,CAClD,CAEA,YAAuC,CACrC,MAAO,MAAK,eAAe,WAAW,CACxC,CAEA,cAAiE,CAC/D,MAAO,MAAK,eAAe,aAAa,CAC1C,CAEA,KAAK,EAA2C,CAC9C,MAAO,MAAK,eAAe,KAAK,CAAO,CACzC,CAEA,AAAU,sBAAuB,CAhCnC,MAiCI,GAAK,SAAK,OAAwB,SAA7B,cAAqC,QAAS,OACjD,MAAO,IAAI,IAAwB,KAAK,cAAgB,KAAK,MAAuB,EACjF,GAAK,KAAK,OAAwB,aAAe,QAAc,KAAK,OAAwB,YAAc,OAC7G,MAAO,IAAI,IAAwB,KAAK,cAAgB,KAAK,MAAuB,EAEpF,KAAM,IAAI,OAAM,sBAAsB,CAC1C,CACF,ECxCA,kDAMO,GAAM,IAAN,KAA4C,CAKjD,YAAqB,EAA8B,EAAmB,CAAjD,qBAJrB,OAAS,aAAa,SAEtB,OAAmB,0BAGjB,KAAK,uBAAyB,GAAI,IAAe,CAAS,CAC5D,CAEA,YAA8B,CAC5B,MAAO,MAAK,uBAAuB,cAAc,CACnD,CAEA,cAAgC,CAC9B,MAAO,MAAK,uBAAuB,UAAU,CAC/C,CAEA,KAAM,MAAK,EAA2C,CACpD,GAAM,GAAe,EAAa,kBAAkB,CAAO,EAErD,CAAC,EAAS,EAAW,GAAgB,KAAM,SAAQ,IAAI,CAC3D,KAAK,WAAW,EAChB,KAAK,aAAa,EAClB,KAAK,uBAAuB,KAAK,CAAY,CAC/C,CAAC,EAEK,EAAiB,GAAgB,CAAS,EAC1C,EAAiB,EAAa,OAAO,UAAU,EAAa,MAAM,MAAM,EACxE,EAAY,EAAa,yBAAyB,CAAS,EAEjE,MAAO,CACL,UACA,YACA,iBACA,gBACF,CACF,CACF,ECxCA,GAAM,IAAqC,CACzC,GAAI,MACJ,KAAM,QACN,OAAQ,MACR,WAAY,QACZ,SAAU,EACV,KAAM,QACR,EAEM,GAAmC,CACvC,GAAI,QACJ,KAAM,QACN,OAAQ,QACR,WAAY,QACZ,KAAM,QACN,gBAAiB,uCACjB,SAAU,CACZ,EAEM,GAAiC,CACrC,GAAI,WACJ,KAAM,aACN,OAAQ,OACR,WAAY,QACZ,KAAM,MACN,QAAS,EACT,gBAAiB,uCACjB,SAAU,CACZ,EAEa,GAAuE,CAClF,GACA,GACA,EACF,EAEa,GAAuE,CAClF,GACC,OAAK,IAAL,CAAoB,gBAAiB,sCAAuC,GAC5E,OAAK,IAAL,CAAmB,gBAAiB,sCAAuC,EAC9E,ECtCO,GAAM,IAAN,KAAwD,CAC7D,WAAW,EAAkB,EAAyC,CACpE,KAAM,IAAI,OAAM,yBAAyB,CAC3C,CACF,ECNO,GAAM,IAAN,KAAwE,CAAxE,cACL,OAAQ,aAAa,IAErB,GAAI,YAAY,CACd,MAAO,MAAK,UACd,CAEA,KAAM,QAAQ,CACZ,AAAI,KAAK,WAGT,MAAK,WAAa,GACpB,CAEA,MAAa,CACX,AAAI,CAAC,KAAK,WAGV,MAAK,WAAa,GACpB,CAEA,oBAAoB,EAA8C,CAChE,KAAM,IAAI,OAAM,yBAAyB,CAC3C,CACF,ECzBO,GAAM,IAAN,KAA0E,CAC/E,mBAAmB,EAAqB,EAAsC,CAC5E,KAAM,IAAI,OAAM,yBAAyB,CAC3C,CACA,WAAW,EAAqB,EAAkB,EAAsC,CACtF,KAAM,IAAI,OAAM,yBAAyB,CAC3C,CACA,UAAU,EAAmC,CAC3C,KAAM,IAAI,OAAM,yBAAyB,CAC3C,CACA,aAAa,EAAmC,CAC9C,KAAM,IAAI,OAAM,yBAAyB,CAC3C,CACF,ECFO,GAAM,IAAN,KAAiB,CACtB,YACqB,EACnB,CADmB,cACjB,CAEJ,KAAM,SAAW,EAAiD,CAChE,GAAM,GAAM,GAAI,KAAI,EAAQ,QAAS,KAAK,OAAO,EAEjD,AAAI,EAAQ,QACV,KAAK,gBAAgB,EAAK,EAAQ,MAAM,EAE1C,GAAM,GAAW,KAAM,OAAM,EAAI,SAAS,EAAG,CAC3C,QAAS,KAAK,cAAc,CAAO,EACnC,OAAQ,EAAQ,QAAU,MAC1B,KAAM,EAAQ,QAAU,KAAK,UAAU,EAAQ,OAAO,EAAI,MAC5D,CAAC,EAED,GAAI,EAAS,SAAW,IAGxB,IAAI,CAAC,EAAS,GAAI,CAChB,GAAM,GAAY,KAAM,GAAS,KAAK,EACtC,KAAM,OAAM,CAAS,CACvB,CAEA,MAAO,MAAM,GAAS,KAAK,EAC7B,CAEA,AAAQ,gBAAgB,EAAU,EAAgD,CAChF,OAAW,KAAO,GAAQ,CACxB,GAAM,GAAQ,EAAO,GACrB,AAAI,GAAU,MACZ,EAAI,aAAa,IAAI,EAAK,OAAO,CAAK,CAAC,CAC3C,CACF,CAEA,AAAQ,cAAc,EAAoD,CACxE,GAAM,GAAqC,CAAC,EAC5C,MAAI,GAAQ,WACV,GAAQ,cAAmB,UAAU,EAAQ,aAE3C,EAAQ,SAAW,QAAU,EAAQ,SACvC,GAAQ,gBAAkB,oBAErB,CACT,CACF,EC3DA,4BAWO,GAAM,IAAiB,AAAC,GACtB,MAAO,GAAU,QAAW,UAAY,MAAO,GAAU,MAAS,UACpE,EAAU,OAAS,QAAa,MAAO,GAAU,MAAS,UAC1D,EAAU,KAAO,QAAa,MAAO,GAAU,IAAO,SAGhD,GAAuB,AAAC,GACX,EAAU,IAAI,GAAY,GAAmB,CAAQ,CAAC,EAKnE,GAAqB,AAAC,GAA8B,CAC/D,GAAM,CAAC,EAAe,GAAgB,EAAc,+BAA+B,EAAS,MAAM,EAWlG,MATqB,CACnB,IAAK,GAAI,GAAU,EAAS,GAAG,EAC/B,IAAK,GAAI,GAAU,EAAS,GAAG,EAC/B,OAAQ,EAAS,OACjB,UAAW,GAAI,MAAK,EAAS,SAAS,EACtC,gBACA,cACF,CAGF,EAEa,GAAuB,CAAC,EAAsB,EAAwC,EAAkB,IAAsB,CAtC3I,QAuCE,GAAM,CAAC,EAAe,GAAgB,EAAc,+BAA+B,EAAU,IAAI,EAC3F,EAAuB,KAAmB,YAAY,CAAY,IAA3C,cAA8C,SACrE,EAAwB,KAAmB,YAAY,CAAa,IAA5C,cAA+C,SAEvE,EAA+B,EAAuB,KAAK,IAAI,EAAsB,CAAe,EAAI,EACxG,EAAgC,EAAwB,KAAK,IAAI,EAAuB,CAAe,EAAI,EAEjH,MAAO,CACL,KAAM,EAAU,KAChB,eACA,gBACA,WAAY,GAAI,GAAU,EAAU,UAAU,EAC9C,SAAU,CACR,aAAc,EACd,cAAe,EACf,MAAO,CACT,CACF,CACF,EAEa,GAAyB,CACpC,EACA,EACA,IAEO,EAAW,IAAI,GAAa,GAAqB,EAAW,EAAoB,CAAe,CAAC,EAG5F,GAA6B,AAAC,GAA0C,CACnF,GAAM,CAAC,EAAe,GAAgB,EAAc,+BAA+B,EAAa,MAAM,EActG,MAZ6B,CAC3B,SAAU,EAAa,SACvB,OAAQ,EAAa,OACrB,gBACA,eACA,QAAS,EAAa,QAAQ,IAAI,GAAsB,EACtD,KAAM,EAAkB,KACxB,MAAO,GAAI,GAAU,EAAkB,KAAK,EAC5C,WAAY,EAAkB,UAChC,EAAE,CACJ,CAGF,EAEa,GAA2C,AAAC,GAAgE,CACvH,GAAM,GAAsB,EAAmB,GAC/C,GAAI,CAAC,EACH,KAAM,IAAI,OAAM,gBAAgB,EAElC,GAAM,CAAC,EAAe,GAAgB,EAAc,+BAA+B,EAAoB,MAAM,EAc7G,MAZ6B,CAC3B,SAAU,EAAoB,SAC9B,OAAQ,EAAoB,OAC5B,gBACA,eACA,QAAS,EAAmB,IAAI,GAAsB,EACpD,KAAM,EAAkB,KACxB,MAAO,GAAI,GAAU,EAAkB,KAAK,EAC5C,WAAY,EAAkB,UAChC,EAAE,CACJ,CAGF,EAEa,GAAqB,CAAC,EAAoB,IAA4D,CA3GnH,MA4GE,GAAM,GAAiB,EAAwB,UAAU,EAAS,MAAM,EACxE,GAAI,CAAC,EACH,KAAM,IAAI,OAAM,IAAI,EAAS,0BAA0B,EAEzD,GAAM,CAAC,EAAM,GAAM,EAAc,oCAAoC,EAAgB,EAAS,KAAM,EAAS,IAAK,EAAS,KAAK,EAEhI,MAAO,CACL,GAAI,EAAS,GACb,OACA,KACA,cAAe,EAAS,cACxB,KAAM,EAAS,KACf,OAAQ,EAAS,OACjB,SAAU,GAAI,GAAU,EAAS,QAAQ,EACzC,UAAW,GAAI,MAAK,EAAS,SAAS,EACtC,KAAM,EAAS,KACf,OAAQ,EAAS,OACjB,QAAS,MAAS,QAAT,cAAgB,IAAI,GAAQ,EAAK,MAAO,CAAC,CACpD,CACF,EAEa,GAAuB,CAAC,EAAuB,IACnD,EAAU,IAAI,GAAY,GAAmB,EAAU,CAAuB,CAAC,EAG3E,GAAmC,AAAC,GAC1B,EAAgB,IAAI,GAAmB,EAC1D,GAAI,EAAe,KACnB,QAAS,EAAe,YACxB,cAAe,EAAe,cAC9B,WAAY,EAAe,SAC3B,OAAQ,EAAe,OACvB,KAAM,EAAe,IACvB,EAAE,EAKS,GAAmB,CAAC,EAAkB,IAA2D,CAC5G,GAAM,GAAiB,EAAwB,UAAU,EAAQ,MAAM,EACvE,GAAI,CAAC,EACH,KAAM,IAAI,OAAM,IAAI,EAAQ,0BAA0B,EAExD,GAAM,CAAC,EAAM,GAAM,EAAc,oCAAoC,EAAgB,EAAQ,KAAM,EAAQ,IAAK,EAAQ,KAAK,EAoC7H,MAlCmB,CACjB,YAAa,EAAQ,YACrB,OAAQ,EAAQ,OAChB,WAAY,EAAQ,WACpB,GAAI,OAAO,EAAQ,EAAE,EACrB,OACA,KACA,MAAO,CACL,IAAK,GAAI,GAAU,EAAQ,GAAG,EAC9B,MAAO,GAAI,GAAU,EAAQ,KAAK,EAClC,KAAM,EAAQ,KACd,OAAQ,EAAQ,MAClB,EACA,UAAW,GAAI,MAAK,EAAQ,SAAS,EACrC,aAAc,CACZ,OAAQ,EAAQ,aAAa,OAC7B,aAAc,GAAiC,EAAQ,aAAa,YAAY,EAChF,WAAY,OACP,EAAQ,aAAa,YADd,CAEV,gBAAiB,GAAI,GAAU,EAAQ,aAAa,WAAW,eAAe,CAChF,GACA,OAAQ,GAAqB,EAAQ,aAAa,MAAM,CAC1D,EACA,KAAM,CACJ,OAAQ,EAAQ,KAAK,OACrB,aAAc,GAAiC,EAAQ,KAAK,YAAY,EACxE,WAAY,OACP,EAAQ,KAAK,YADN,CAEV,gBAAiB,GAAI,GAAU,EAAQ,KAAK,WAAW,eAAe,CACxE,GACA,OAAQ,GAAqB,EAAQ,KAAK,MAAM,CAClD,CACF,CAGF,EAEa,GAAuB,AAAC,GACpB,EAAU,IAAI,GAAa,EACxC,QAAS,EAAS,QAClB,MAAO,GAAI,GAAU,EAAS,KAAK,EACnC,IAAK,GAAI,GAAU,EAAS,GAAG,CACjC,EAAE,EAKS,GAAqB,CAAC,EAAqB,IAC/C,EAAS,IAAI,GAAW,GAAiB,EAAS,CAAuB,CAAC,EAGtE,GAA8B,CAAC,EAAiC,IAA4D,CACvI,GAAM,GAAiB,EAAwB,UAAU,EAAS,MAAM,EACxE,GAAI,CAAC,EACH,KAAM,IAAI,OAAM,IAAI,EAAS,0BAA0B,EAEzD,GAAM,CAAC,EAAM,GAAM,EAAc,oCAAoC,EAAgB,EAAS,KAAM,EAAS,IAAK,EAAS,KAAK,EAgBhI,MAdqB,CACnB,GAAI,EAAS,GACb,cAAe,EAAS,cACxB,KAAM,EAAS,KACf,OAAQ,EAAS,OACjB,SAAU,GAAI,GAAU,EAAS,QAAQ,EACzC,QAAS,EAAS,MAClB,OAAQ,EAAS,OACjB,KAAM,EAAS,KACf,UAAW,GAAI,MAAK,EAAS,SAAS,EACtC,OACA,IACF,CAGF,ECrMO,GAAM,GAAN,KAA+C,CAkBpD,YAAY,EAAkC,CAjB9C,OAAS,iBAET,OAAS,SAAiC,CACxC,YAAa,GAAI,GACjB,aAAc,GAAI,GAClB,iBAAkB,GAAI,GACtB,iBAAkB,GAAI,EACxB,GAEA,OAAmB,wBACnB,OAAmB,sBACnB,OAAmB,2BACnB,OAAmB,cACnB,OAAmB,cAEnB,OAAQ,aAAa,IAGnB,KAAK,cAAgB,EAAQ,cAC7B,KAAK,qBAAuB,EAAQ,qBACpC,KAAK,mBAAqB,EAAQ,mBAClC,KAAK,wBAA0B,EAAQ,wBACvC,KAAK,WAAa,EAAQ,WAC1B,KAAK,WAAa,GAAI,IAAW,KAAK,UAAU,CAClD,CAEA,GAAI,YAAY,CACd,MAAO,MAAK,UACd,CAEA,KAAM,QAAQ,CACZ,AAAI,KAAK,WAGT,MAAK,WAAa,GACpB,CAEA,MAAa,CACX,AAAI,CAAC,KAAK,WAGV,MAAK,WAAa,GACpB,CAEA,KAAM,UAAS,EAAwB,EAA6C,CAClF,GAAM,GAAU,cAAc,IACxB,EAAY,KAAK,qBAAqB,CAAc,EACpD,EAAW,KAAM,MAAK,WAAW,QAAkB,CAAE,UAAS,WAAU,CAAC,EAE/E,MAAO,GAAW,GAAmB,EAAU,KAAK,uBAAuB,EAAI,MACjF,CAEA,KAAM,WAAU,EAAwB,EAAyD,CAC/F,GAAM,GAAU,aACV,EAAY,KAAK,qBAAqB,CAAc,EACpD,EAAS,OACV,GADU,CAEb,QAAS,OACT,KAAM,kBAAU,WAAY,OACxB,EAAS,QAAU,MAAQ,OAC3B,MACN,GAEM,EAAY,KAAM,MAAK,WAAW,QAAoB,CAAE,UAAS,YAAW,QAAO,CAAC,EAE1F,MAAO,GAAY,GAAqB,EAAW,KAAK,uBAAuB,EAAI,CAAC,CACtF,CAEA,KAAM,aAAwC,CAC5C,GAAM,GAAU,cACV,EAAa,KAAM,MAAK,WAAW,QAAqB,CAAE,SAAQ,CAAC,EAEzE,MAAO,GAAa,GAAuB,EAAY,KAAK,kBAAkB,EAAI,CAAC,CACrF,CAIA,KAAM,cAAa,EAAwE,CACzF,GAAM,GAAU,wBACZ,EAEJ,GAAI,WAAqB,OACvB,GAAI,MAAO,GAAoB,IAAO,SACpC,EAAU,MACP,CACH,GAAM,GAAkB,KAAK,wBAAwB,cAAc,EACnE,EAAW,EAA4C,IAAI,GAAK,EAAc,kBAAkB,EAAiB,EAAE,KAAM,EAAE,EAAE,EAAE,EAAE,CACnI,CAGF,GAAM,GAAS,CAAE,QAAS,iBAAS,KAAK,IAAK,EAEvC,EAAY,KAAM,MAAK,WAAW,QAAoB,CAAE,UAAS,QAAO,CAAC,EAE/E,MAAO,GAAY,GAAqB,CAAS,EAAI,CAAC,CACxD,CAIA,KAAM,cAAa,EAA+E,CAChG,GAAM,GAAU,sBACZ,EAEJ,GAAI,MAAO,IAAsB,SAC/B,EAAS,MACN,CACH,GAAM,GAAkB,KAAK,wBAAwB,cAAc,EACnE,CAAC,CAAM,EAAI,EAAc,kBAAkB,EAAiB,EAAkB,KAAM,EAAkB,EAAE,CAC1G,CAEA,GAAM,GAAS,CAAE,QAAO,EAClB,EAAe,KAAM,MAAK,WAAW,QAAsB,CAAE,UAAS,QAAO,CAAC,EAEpF,MAAO,GAAe,GAA2B,CAAY,EAAI,MACnE,CAEA,KAAM,UAAS,EAAwB,EAAmD,CACxF,GAAM,GAAU,aACV,EAAY,KAAK,qBAAqB,CAAc,EACtD,EACA,EAEJ,GAAI,EAAgB,UAAU,QAAU,EAAgB,UAAU,KAChE,CAAC,EAAQ,CAAI,EAAI,CAAC,EAAgB,UAAU,OAAQ,EAAgB,UAAU,IAAI,UAC3E,MAAO,GAAgB,UAAU,MAAS,UAAY,MAAO,GAAgB,UAAU,IAAO,SAAU,CAC/G,GAAM,GAAkB,KAAK,wBAAwB,cAAc,EACnE,CAAC,EAAQ,CAAI,EAAI,EAAc,kBAAkB,EAAiB,EAAgB,UAAU,KAAM,EAAgB,UAAU,EAAE,CAChI,KAEE,MAAM,IAAI,OAAM,yCAAyC,EAE3D,GAAI,GACA,EACJ,AAAI,GAAe,EAAgB,SAAS,EAC1C,GAAkB,EAAgB,UAAU,KAAK,OACjD,EAAiB,EAAgB,UAAU,KAAK,OAGhD,GAAkB,EAAgB,UAAU,WAC5C,EAAiB,EAAgB,UAAU,OAI7C,GAAM,GAAU,CACd,cAAe,EAAgB,cAC/B,SACA,OACA,KAAM,EAAgB,UAAU,KAChC,WAAY,EAAgB,WAAa,CACvC,WAAY,EAAgB,WAAW,WACvC,iBAAkB,EAAgB,WAAW,iBAC7C,cAAe,EAAgB,WAAW,cAC1C,gBAAiB,EAAgB,WAAW,gBAAgB,SAAS,EACrE,SAAU,EAAgB,WAAW,SACrC,qBAAsB,EAAgB,WAAW,qBACjD,sBAAuB,EAAgB,WAAW,qBACpD,EAAI,OACJ,cAAe,EAAgB,cAC/B,IAAK,EAAgB,SAAS,EAC9B,MAAO,EAAe,SAAS,CACjC,EAEM,EAAc,KAAM,MAAK,WAAW,QAAyB,CACjE,UACA,YACA,OAAQ,OACR,SACF,CAAC,EAED,GAAI,IAAgB,OAClB,KAAM,IAAI,OAAM,yBAAyB,EAE3C,MAAO,GAAY,OACrB,CAEA,KAAM,aAAY,EAAwB,EAA0D,CAClG,GAAM,GAAU,cAAc,EAAmB,UAC3C,EAAY,KAAK,qBAAqB,CAAc,EACtD,EACA,EAEJ,GAAI,EAAmB,QAAU,EAAmB,KAClD,CAAC,EAAQ,CAAI,EAAI,CAAC,EAAmB,OAAQ,EAAmB,IAAI,UAC7D,EAAmB,MAAQ,EAAmB,GAAI,CACzD,GAAM,GAAkB,KAAK,wBAAwB,cAAc,EACnE,CAAC,EAAQ,CAAI,EAAI,EAAc,kBAAkB,EAAiB,EAAmB,KAAM,EAAmB,EAAE,CAClH,KAEE,MAAM,IAAI,OAAM,4CAA4C,EAE9D,GAAM,GAAS,CAAE,SAAQ,MAAK,EAExB,EAAY,KAAM,MAAK,WAAW,QAAiB,CACvD,UACA,YACA,SACA,OAAQ,QACV,CAAC,EAED,GAAI,IAAc,OAChB,KAAM,IAAI,OAAM,yBAAyB,EAE3C,MAAO,EACT,CAEA,KAAM,iBAAgB,EAAwB,EAAiE,CAC7G,GAAM,GAAU,aACV,EAAY,KAAK,qBAAqB,CAAc,EAEtD,EACA,EAEJ,GAAI,EAAuB,QAAU,EAAuB,KAC1D,CAAC,EAAQ,CAAI,EAAI,CAAC,EAAuB,OAAQ,EAAuB,IAAI,UACrE,EAAuB,MAAQ,EAAuB,GAAI,CACjE,GAAM,GAAkB,KAAK,wBAAwB,cAAc,EACnE,CAAC,EAAQ,CAAI,EAAI,EAAc,kBAAkB,EAAiB,EAAuB,KAAM,EAAuB,EAAE,EAEpH,EAAuB,qBACzB,GAAO,MACX,KAEE,MAAM,IAAI,OAAM,gDAAgD,EAElE,GAAM,GAAsB,KAAM,MAAK,WAAW,QAAgB,CAChE,UACA,YACA,OAAQ,CACN,SACA,OACA,kBAAmB,EAAuB,iBAC5C,EACA,OAAQ,QACV,CAAC,EAED,GAAI,IAAwB,OAC1B,KAAM,IAAI,OAAM,yBAAyB,EAE3C,MAAO,EACT,CAEA,oBAAoB,EAA8C,CAChE,KAAM,IAAI,OAAM,yBAAyB,CAC3C,CAIA,KAAM,SAAQ,EAAgB,EAAkE,CAC9F,GAAM,GAAU,aAAa,IAGvB,EAAS,CACb,QAAS,AAFK,KAAK,WAAW,CAAkB,EAE/B,KAAK,GAAG,CAC3B,EAEM,EAAU,KAAM,MAAK,WAAW,QAAiB,CACrD,UACA,QACF,CAAC,EAED,MAAO,GAAU,GAAiB,EAAS,KAAK,uBAAuB,EAAI,MAC7E,CAIA,KAAM,UAAS,EAAuC,EAA2C,CAC/F,GAAM,GAAU,YAEV,EAAU,KAAK,WAAW,CAAkB,EAC5C,EAAS,OACV,GADU,CAEb,QAAS,OACT,KAAM,kBAAU,WAAY,OACxB,EAAS,QAAU,MAAQ,OAC3B,OACJ,QAAS,EAAQ,KAAK,GAAG,CAC3B,GAEM,EAAW,KAAM,MAAK,WAAW,QAAmB,CACxD,UACA,QACF,CAAC,EAED,MAAO,GAAW,GAAmB,EAAU,KAAK,uBAAuB,EAAI,CAAC,CAClF,CAEA,AAAQ,WAAW,EAAuC,CAGxD,GAAM,GAAU,AAFS,OAAM,QAAQ,CAAkB,EAAI,EAAqB,CAAC,CAAkB,GAGlG,IAAI,GAAQ,CAhUnB,MAgUsB,cAAK,qBAAqB,aAAa,CAAO,IAA9C,cAAiD,OAAM,EACtE,OAAO,GAAU,CAAM,EAE1B,GAAI,CAAC,EAAQ,OACX,KAAM,IAAI,OAAM,4BAA4B,EAE9C,MAAO,EACT,CAEA,AAAQ,qBAAqB,EAAgC,CAzU/D,MA0UI,GAAM,GAAY,QAAK,qBAAqB,aAAa,CAAc,IAArD,cAAwD,MAE1E,GAAI,CAAC,EACH,KAAM,IAAI,OAAM,uCAAuC,GAAgB,EAEzE,MAAO,EACT,CACF,ECzUO,GAAM,GAAN,KAAsB,CAe3B,YACqB,EACA,EACnB,CAFmB,WACA,iBAhBrB,OAAS,SAAgC,CACvC,gBAAiB,GAAI,GACrB,OAAQ,GAAI,EACd,GAEA,OAAU,WAyDV,OAAU,oBAAoB,AAAC,GAAgC,CAC7D,KAAK,OAAO,gBAAgB,KAAK,KAAK,MAAM,EAAM,IAAI,CAAC,CACzD,GAMA,OAAU,WAAW,AAAC,GAAsB,CAC1C,KAAK,OAAO,OAAO,KAAK,KAAM,CAAK,CACrC,EAtDA,CAXA,GAAc,SAAoB,CAChC,GAAI,CAAC,KAAK,QACR,KAAM,IAAI,OAAM,iEAAiE,EAEnF,MAAO,MAAK,OACd,CAQA,KAAM,UAAyB,CAC7B,YAAK,WAAW,EACT,GAAI,SAAQ,GAAW,CAC5B,GAAM,GAAY,KAAK,UAAY,CAAC,eAAgB,KAAK,SAAS,EAAI,OACtE,KAAK,QAAU,GAAI,WAAU,KAAK,IAAK,CAAS,EAChD,KAAK,OAAO,iBAAiB,UAAW,KAAK,iBAAiB,EAC9D,KAAK,OAAO,iBAAiB,QAAS,KAAK,OAAO,EAClD,KAAK,OAAO,iBAAiB,QAAS,KAAK,QAAQ,EAEnD,KAAK,OAAO,iBAAiB,OAAQ,IAAM,EAAQ,CAAC,CACtD,CAAC,CACH,CAEA,YAAa,CACX,AAAI,KAAK,SACP,MAAK,OAAO,oBAAoB,UAAW,KAAK,iBAAiB,EACjE,KAAK,OAAO,oBAAoB,QAAS,KAAK,OAAO,EACrD,KAAK,OAAO,oBAAoB,QAAS,KAAK,QAAQ,EACtD,KAAK,OAAO,MAAM,EAEtB,CAEA,UAAU,EAAgB,CACxB,GAAM,GAA+B,CACnC,OAAQ,YACR,KAAM,EACN,UAAW,KAAK,IAAI,CACtB,EAEA,KAAK,OAAO,KAAK,KAAK,UAAU,CAAO,CAAC,CAC1C,CAEA,YAAY,EAAgB,CAC1B,GAAM,GAA+B,CACnC,OAAQ,cACR,KAAM,EACN,UAAW,KAAK,IAAI,CACtB,EAEA,KAAK,OAAO,KAAK,KAAK,UAAU,CAAO,CAAC,CAC1C,CAMA,AAAU,QAAQ,EAAc,CAC9B,KAAM,IAAI,OAAM,6BAA6B,KAAK,UAAU,CAAK,GAAG,CACtE,CAKF,ECzEO,GAAM,IAAN,KAA8B,CAWnC,YACqB,EACA,EACnB,CAFmB,2BACA,4BAVrB,OAAS,SAAwC,CAC/C,gBAAiB,GAAI,EACvB,GAEA,OAAmB,UAAwC,GAAI,MAE/D,OAAQ,aAAa,IAqCrB,OAAU,eAAe,KAAO,IAAyB,CACvD,KAAK,aAAa,EAAU,MAAM,EAElC,GAAM,GAAS,GAAI,GAAgB,GAAI,KAAI,GAAwB,kBAAmB,KAAK,mBAAmB,EAAG,EAAU,KAAK,EAChI,EAAO,OAAO,gBAAgB,YAAY,KAAK,uBAAuB,EACtE,EAAO,OAAO,OAAO,YAAY,KAAK,QAAQ,EAE9C,KAAK,QAAQ,IAAI,EAAU,OAAQ,CAAM,EACzC,KAAM,GAAO,QAAQ,CACvB,GAEA,OAAU,iBAAiB,AAAC,GAAyB,CACnD,KAAK,aAAa,EAAU,MAAM,CACpC,GAaA,OAAU,0BAA0B,AAAC,GAAkC,CACrE,KAAK,OAAO,gBAAgB,KAAK,CAAO,CAC1C,GAEA,OAAU,WAAW,CAAC,EAAyB,IAAuB,CACpE,WAAW,IAAM,CACf,EAAO,QAAQ,CACjB,EAAG,GAAI,CACT,EAjEA,CAEA,GAAI,YAAY,CACd,MAAO,MAAK,UACd,CAEA,KAAM,QAAQ,CACZ,AAAI,KAAK,WAGT,MAAK,sBAAsB,EAE3B,KAAK,WAAa,GACpB,CAEA,MAAO,CACL,AAAI,CAAC,KAAK,WAGV,MAAK,QAAQ,QAAQ,CAAC,EAAG,IAAW,CAClC,KAAK,aAAa,CAAM,CAC1B,CAAC,EAED,KAAK,WAAa,GACpB,CAEA,AAAU,uBAAwB,CAChC,KAAK,qBAAqB,OAAO,WAAW,YAAY,KAAK,YAAY,EACzE,KAAK,qBAAqB,OAAO,aAAa,YAAY,KAAK,cAAc,CAC/E,CAiBA,AAAU,aAAa,EAAgB,CACrC,GAAM,GAAS,KAAK,QAAQ,IAAI,CAAM,EAEtC,AAAI,GACF,GAAO,OAAO,gBAAgB,eAAe,KAAK,uBAAuB,EACzE,EAAO,OAAO,OAAO,eAAe,KAAK,QAAQ,EACjD,KAAK,QAAQ,OAAO,CAAM,EAC1B,EAAO,WAAW,EAEtB,CAWF,EAjFa,GAAN,GACL,EADW,GACe,oBAAoB,gBCFzC,GAAM,IAAN,KAAgC,CAarC,YACqB,EACnB,CADmB,2BATrB,OAAS,SAA0C,CACjD,gBAAiB,GAAI,EACvB,GAEA,OAAU,UAEV,OAAQ,aAAa,IAyCrB,OAAU,iBAAiB,CAAC,EAAyB,IAAuB,CAC1E,WAAW,SAAY,CACrB,KAAM,GAAO,QAAQ,EACrB,KAAK,mBAAmB,CAAM,CAChC,EAAG,GAAI,CACT,GAEA,OAAU,0BAA0B,AAAC,GAAkC,CACrE,KAAK,OAAO,gBAAgB,KAAK,CAAO,CAC1C,GA7CE,KAAK,OAAS,GAAI,GAAgB,GAAI,KAAI,GAA0B,qBAAsB,KAAK,mBAAmB,CAAC,CACrH,CAEA,GAAI,YAAY,CACd,MAAO,MAAK,UACd,CAEA,KAAM,QAAuB,CAC3B,AAAI,KAAK,WAGT,MAAK,OAAO,OAAO,gBAAgB,YAAY,KAAK,uBAAuB,EAC3E,KAAK,OAAO,OAAO,OAAO,YAAY,KAAK,cAAc,EACzD,KAAM,MAAK,OAAO,QAAQ,EAE1B,KAAK,mBAAmB,KAAK,MAAM,EAEnC,KAAK,WAAa,GACpB,CAEA,MAAO,CACL,AAAI,CAAC,KAAK,WAGV,MAAK,OAAO,OAAO,gBAAgB,eAAe,KAAK,uBAAuB,EAC9E,KAAK,OAAO,OAAO,OAAO,eAAe,KAAK,cAAc,EAC5D,KAAK,OAAO,WAAW,EAEvB,KAAK,WAAa,GACpB,CAEA,AAAU,mBAAmB,EAAyB,CACpD,EAAO,UAAU,GAA0B,kBAAkB,EAC7D,EAAO,UAAU,GAA0B,iBAAiB,CAC9D,CAYF,EA9Da,EAAN,GACL,EADW,EACe,uBAAuB,kBACjD,EAFW,EAEe,qBAAqB,aAC/C,EAHW,EAGe,oBAAoB,aCazC,GAAM,GAAN,KAAoD,CAkBzD,YAAY,EAAuC,CAjBnD,OAAS,iBACT,OAAS,SAAiC,CACxC,YAAa,GAAI,GACjB,aAAc,GAAI,GAClB,iBAAkB,GAAI,GACtB,iBAAkB,GAAI,EACxB,GAEA,OAAmB,wBACnB,OAAmB,2BACnB,OAAmB,sBACnB,OAAmB,uBACnB,OAAmB,6BACnB,OAAmB,2BAEnB,OAAQ,aAAa,IAiGrB,OAAmB,0BAA0B,AAAC,GAAkC,CAC9E,OAAQ,EAAQ,WACT,QACH,AAAC,KAAK,OAAO,aAAiE,KAAK,GAA4B,EAAQ,KAAM,KAAK,uBAAuB,CAAC,EAC1J,UAEG,OACH,AAAC,KAAK,OAAO,YAA+D,KAAK,GAAiB,EAAQ,KAAM,KAAK,uBAAuB,CAAC,EAC7I,UAEG,YACH,AAAC,KAAK,OAAO,iBAAyE,KAAK,GAAqB,EAAQ,IAAI,CAAC,EAC7H,UAEG,UACH,AAAC,KAAK,OAAO,iBAAyE,KAAK,GAAyC,EAAQ,IAAI,CAAC,EACjJ,MAEN,GAhHE,KAAK,cAAgB,EAAQ,cAC7B,KAAK,qBAAuB,EAAQ,qBACpC,KAAK,mBAAqB,EAAQ,mBAClC,KAAK,wBAA0B,EAAQ,wBACvC,KAAK,oBAAsB,EAAQ,oBAEnC,KAAK,wBAA0B,GAAI,IAAwB,KAAK,oBAAqB,KAAK,oBAAoB,EAC9G,KAAK,0BAA4B,GAAI,GAA0B,KAAK,mBAAmB,CACzF,CAEA,GAAI,YAAY,CACd,MAAO,MAAK,UACd,CAEA,KAAM,QAAQ,CACZ,AAAI,KAAK,WAGT,MAAK,wBAAwB,OAAO,gBAAgB,YAAY,KAAK,uBAAuB,EAC5F,KAAK,0BAA0B,OAAO,gBAAgB,YAAY,KAAK,uBAAuB,EAE9F,KAAM,SAAQ,IAAI,CAChB,KAAK,wBAAwB,MAAM,EACnC,KAAK,0BAA0B,MAAM,CACvC,CAAC,EAED,KAAK,WAAa,GACpB,CAEA,MAAa,CACX,AAAI,CAAC,KAAK,WAGV,MAAK,wBAAwB,OAAO,gBAAgB,eAAe,KAAK,uBAAuB,EAC/F,KAAK,0BAA0B,OAAO,gBAAgB,eAAe,KAAK,uBAAuB,EAEjG,KAAK,wBAAwB,KAAK,EAClC,KAAK,0BAA0B,KAAK,EAEpC,KAAK,WAAa,GACpB,CAEA,SAAS,EAAyB,EAA8C,CAC9E,KAAM,IAAI,OAAM,yBAAyB,CAC3C,CAEA,UAAU,EAAyB,EAA0D,CAC3F,KAAM,IAAI,OAAM,yBAAyB,CAC3C,CAEA,YAAwC,CACtC,KAAM,IAAI,OAAM,yBAAyB,CAC3C,CAIA,aAAa,EAAyE,CACpF,KAAM,IAAI,OAAM,yBAAyB,CAC3C,CAIA,KAAM,cAAa,EAAgF,CACjG,KAAM,IAAI,OAAM,yBAAyB,CAC3C,CAEA,SAAS,EAAyB,EAAoD,CACpF,KAAM,IAAI,OAAM,yBAAyB,CAC3C,CAEA,YAAY,EAAyB,EAA2D,CAC9F,KAAM,IAAI,OAAM,yBAAyB,CAC3C,CAEA,gBAAgB,EAAyB,EAAkE,CACzG,KAAM,IAAI,OAAM,yBAAyB,CAC3C,CAEA,oBAAoB,EAA8C,CAChE,KAAM,IAAI,OAAM,yBAAyB,CAC3C,CAIA,QAAQ,EAAiB,EAAmE,CAC1F,KAAM,IAAI,OAAM,yBAAyB,CAC3C,CAIA,SAAS,EAAwC,EAA4C,CAC3F,KAAM,IAAI,OAAM,yBAAyB,CAC3C,CAqBF,ECjJO,GAAM,IAAN,KAAmD,CAKxD,YACW,EACU,EACA,EACnB,CAHS,qBACU,wBACA,6BAPrB,OAAS,UAET,OAAQ,aAAa,IAOnB,EAAY,sBAAsB,KAAM,CAAgB,EACxD,EAAY,sBAAsB,KAAM,CAAqB,EAE7D,KAAK,OAAS,CACZ,YAAa,KAAK,sBAAsB,OAAO,YAC/C,iBAAkB,KAAK,sBAAsB,OAAO,iBACpD,aAAc,KAAK,sBAAsB,OAAO,aAChD,iBAAkB,KAAK,sBAAsB,OAAO,gBACtD,CACF,CAEA,GAAI,YAAY,CACd,MAAO,MAAK,UACd,CAEA,KAAM,QAAQ,CACZ,AAAI,KAAK,WAGT,MAAM,SAAQ,IAAI,CAChB,KAAK,sBAAsB,MAAM,EACjC,KAAK,iBAAiB,MAAM,CAC9B,CAAC,EAED,KAAK,WAAa,GACpB,CAEA,MAAa,CACX,AAAI,CAAC,KAAK,WAGV,MAAK,sBAAsB,KAAK,EAChC,KAAK,iBAAiB,KAAK,EAE3B,KAAK,WAAa,GACpB,CAEA,SAAS,EAAwB,EAA6C,CAC5E,MAAO,MAAK,iBAAiB,SAAS,EAAgB,CAAO,CAC/D,CAEA,UAAU,EAAwB,EAAyD,CACzF,MAAO,MAAK,iBAAiB,UAAU,EAAgB,CAAQ,CACjE,CAEA,YAAwC,CACtC,MAAO,MAAK,iBAAiB,WAAW,CAC1C,CAIA,aAAa,EAAwE,CACnF,MAAQ,MAAK,iBAAiB,aAA4F,CAAmB,CAC/I,CAIA,KAAM,cAAa,EAA+E,CAChG,MAAQ,MAAK,iBAAiB,aAAmG,CAAiB,CACpJ,CAEA,SAAS,EAAwB,EAAmD,CAClF,MAAO,MAAK,iBAAiB,SAAS,EAAgB,CAAe,CACvE,CAEA,YAAY,EAAwB,EAA0D,CAC5F,MAAO,MAAK,iBAAiB,YAAY,EAAgB,CAAkB,CAC7E,CAEA,gBAAgB,EAAwB,EAAiE,CACvG,MAAO,MAAK,iBAAiB,gBAAgB,EAAgB,CAAsB,CACrF,CAEA,oBAAoB,EAA6C,CAC/D,MAAO,MAAK,iBAAiB,oBAAoB,CAAI,CACvD,CAIA,QAAQ,EAAgB,EAAkE,CACxF,MAAQ,MAAK,iBAAiB,QAAiG,EAAQ,CAAkB,CAC3J,CAIA,SAAS,EAAuC,EAA2C,CACzF,MAAQ,MAAK,iBAAiB,SAAkG,EAAoB,CAAQ,CAC9J,CACF,ECpGO,GAAM,IAA+B,CAC1C,EACA,IAEO,GAAI,IACT,EAAc,cACd,GAAI,GAAiB,CACnB,cAAe,EAAc,cAC7B,qBAAsB,EAAc,SAAS,qBAC7C,mBAAoB,EAAc,UAAU,mBAC5C,wBAAyB,EAAc,UAAU,wBACjD,WAAY,EAAQ,UACtB,CAAC,EACD,GAAI,GAAsB,CACxB,cAAe,EAAc,cAC7B,qBAAsB,EAAc,SAAS,qBAC7C,mBAAoB,EAAc,UAAU,mBAC5C,wBAAyB,EAAc,UAAU,wBACjD,oBAAqB,EAAQ,mBAC/B,CAAC,CACH,EC7BK,GAAK,IAAL,CAAK,GACV,WAAQ,GAAR,QACA,WAAS,GAAT,SAEA,QAAM,GAAN,MAJU,YCiBL,GAAM,IAAN,KAAoD,CAuBzD,YAAY,EAAsC,CAtBlD,OAAS,SAAqC,CAC5C,WAAY,GAAI,GAChB,aAAc,GAAI,GAClB,kBAAmB,GAAI,GACvB,iBAAkB,GAAI,EACxB,GAMA,OAAS,iBAET,OAAmB,kBACnB,OAAmB,SACnB,OAAmB,oBACnB,OAAmB,qCAEnB,OAAiB,iBAA6C,GAAI,MAElE,OAAQ,aAAa,IA+KrB,OAAU,mCAAmC,AAAC,GAAyB,CACrE,GAAM,GAAgB,KAAK,eAAe,IAAI,EAAU,OAAO,EAC/D,GAAI,CAAC,EACH,OAEF,aAAa,EAAc,SAAS,EACpC,GAAM,GAAW,EAAU,QAAQ,QAAQ,EAAI,KAAK,IAAI,EAClD,EAAe,WAAW,KAAK,gCAAiC,GAAuB,CAAQ,EAAG,CAAS,EAEjH,KAAK,eAAe,IAAI,EAAU,QAAS,OACtC,GADsC,CAEzC,UAAW,CACb,EAAC,EACA,KAAK,OAA2C,kBAAkB,KAAK,CAAS,CACnF,GAEA,OAAU,kCAAkC,AAAC,GAAyB,CACpE,KAAK,oBAAoB,CAAS,EACjC,KAAK,OAA2C,iBAAiB,KAAK,CAAS,CAClF,GA/LE,KAAK,cAAgB,EAAQ,cAC7B,KAAK,MAAQ,EAAQ,MACrB,KAAK,eAAiB,EAAQ,eAE9B,EAAY,sBAAsB,KAAM,KAAK,cAAc,EAE3D,KAAK,iBAAmB,GAAI,KAAI,GAAqB,2BAA4B,EAAQ,oBAAoB,EAC7G,KAAK,kCAAoC,EAAQ,mCAAqC,GAAqB,6CAC7G,CAEA,GAAI,YAAY,CACd,MAAO,MAAK,UACd,CAEA,KAAM,QAAuB,CAC3B,AAAI,KAAK,WAGT,MAAK,WAAa,GACpB,CAEA,MAAa,CACX,GAAI,EAAC,KAAK,UAGV,QAAW,KAAsB,MAAK,cACpC,KAAK,iBAAiB,EAAmB,GAAG,SAAS,EAEvD,KAAK,WAAa,GACpB,CAEA,GAAc,gBAAoD,CAChE,MAAO,MAAK,cACd,CAEA,aAAa,EAAwC,CA5EvD,MA6EI,MAAO,QAAK,cAAc,IAAI,CAAO,IAA9B,cAAiC,SAC1C,CAEA,KAAM,WAAU,CACd,UACA,kBAAkB,EAClB,aACA,cAAc,GAAqB,sBACuB,CAC1D,GAAK,GAAkB,KAA2B,EAAuB,CACvE,GAAM,GAAY,KAAK,aAAa,CAAO,GAAM,KAAM,MAAK,uBAAuB,CAAO,EAE1F,GAAI,GAAa,CAAC,KAAK,gBAAgB,CAAS,EAC9C,MAAO,EACX,CAEA,GAAK,GAAkB,KAA4B,EACjD,OAEF,GAAM,GAAS,KAAM,MAAK,eAAe,WAAW,EAAS,CAAU,EACvE,GAAI,CAAC,EACH,KAAM,IAAI,OAAM,8CAA8C,WAAiB,EAEjF,GAAM,GAAY,KAAK,0BAA0B,CAAW,EACtD,EAAkB,KAAM,GAAO,KAAK,EAAc,CAAS,EAEjE,GAAI,EAAgB,UAAY,EAC9B,KAAM,IAAI,OAAM,oCAAoC,EAEtD,GAAM,GAA6B,KAAM,MAAK,iBAAiB,CAC7D,QAAS,EACT,UAAW,EAAgB,eAC3B,UAAW,EAAgB,UAC3B,gBAAiB,EAAgB,gBACjC,UAAW,EAAgB,eAC3B,WACF,CAAC,EAEK,EAAuB,CAC3B,MAAO,EAA2B,MAClC,OAAQ,EAA2B,GACnC,UACA,QAAS,GAAI,MAAK,EAA2B,OAAO,CACtD,EAEA,YAAM,MAAK,kBAAkB,EAAW,EAAI,EAErC,CACT,CAEA,KAAM,aAAY,EAAmC,CACnD,GAAM,GAAY,KAAK,aAAa,CAAO,EAE3C,MAAO,GAAY,KAAK,oBAAoB,CAAS,EAAI,EAC3D,CAEA,KAAgB,wBAAuB,EAAiD,CACtF,GAAM,GAAY,KAAM,MAAK,MAAM,aAAa,CAAO,EAEvD,GAAI,EAAC,EAGL,MAAO,MAAM,MAAK,kBAAkB,EAAW,EAAK,CACtD,CAEA,KAAgB,mBAAkB,EAAsB,EAAqD,CAC3G,GAAM,GAAY,KAAK,eAAe,CAAS,EAC/C,GAAI,CAAC,EACH,OAEF,GAAM,GAAgB,CACpB,YACA,WACF,EACA,YAAK,eAAe,IAAI,EAAU,QAAS,CAAa,EAEpD,GACF,GAAY,KAAM,MAAK,MAAM,gBAAgB,EAAU,QAAS,CAAS,GAE1E,KAAK,OAA2C,WAAW,KAAK,CAAS,EACnE,CACT,CAEA,KAAgB,qBAAoB,EAAwC,CAC1E,GAAM,GAAgB,KAAK,eAAe,IAAI,EAAU,OAAO,EAC/D,GAAI,CAAC,EACH,MAAO,GAET,KAAK,iBAAiB,EAAc,SAAS,EAC7C,GAAM,GAAU,KAAM,MAAK,MAAM,gBAAgB,CAAS,GAAK,KAAK,eAAe,OAAO,EAAU,OAAO,EAE3G,MAAI,IACD,KAAK,OAA2C,aAAa,KAAK,CAAS,EAEvE,CACT,CAEA,AAAU,eAAe,EAAkD,CACzE,GAAM,GAAgB,EAAU,QAAQ,QAAQ,EAAI,KAAK,IAAI,EAC7D,GAAI,GAAiB,EAAG,CACtB,KAAK,MAAM,gBAAgB,CAAS,EACnC,KAAK,OAA2C,iBAAiB,KAAK,CAAS,EAEhF,MACF,CAEA,GAAM,GAAwB,EAAiB,KAAK,kCAAoC,IAGxF,MAFkB,YAAW,KAAK,iCAAkC,GAAuB,CAAqB,EAAG,CAAS,CAG9H,CAEA,AAAU,iBAAiB,EAAgD,CACzE,aAAa,CAAkB,CACjC,CAEA,AAAU,0BAA0B,EAA8B,CAChE,MAAO,MAAK,IAAI,CAClB,CAEA,KAAgB,kBAAiB,EAA6E,CAC5G,GAAM,GAAW,KAAM,OAAM,KAAK,iBAAiB,KAAM,CACvD,OAAQ,OACR,QAAS,CACP,OAAU,mBACV,eAAgB,kBAClB,EACA,KAAM,KAAK,UAAU,CAAW,CAClC,CAAC,EAED,GAAI,CAAC,EAAS,GACZ,KAAM,IAAI,OAAM,KAAM,GAAS,KAAK,CAAC,EAEvC,MAAO,GAAS,KAAK,CACvB,CAuBA,AAAU,gBAAgB,EAAsB,CAC9C,MAAQ,GAAU,QAAQ,QAAQ,EAAI,KAAK,IAAI,GAAO,KAAK,kCAAoC,GACjG,CACF,EA5Na,EAAN,GAQL,EARW,EAQe,uBAAuB,eACjD,EATW,EASe,6BAA6B,aACvD,EAVW,EAUe,gDAAgD,ICvBrE,GAAM,GAAN,KAA4E,CACjF,kCAAkC,EAAkD,CAClF,MAAO,CACL,EAAG,EAAU,QACb,EAAG,EAAU,OACb,EAAG,EAAU,QAAQ,QAAQ,EAC7B,EAAG,EAAU,KACf,CACF,CAEA,kCAAkC,EAA4D,CAC5F,MAAO,CACL,QAAS,EAAoB,EAC7B,OAAQ,EAAoB,EAC5B,QAAS,GAAI,MAAK,EAAoB,CAAC,EACvC,MAAO,EAAoB,CAC7B,CACF,CACF,EClBO,GAAM,IAAN,KAAyD,CAG9D,YACqB,EACA,EACV,EAAoB,GAA0B,iBACvD,CAHmB,oBACA,iCACV,gBAEX,CAEA,aAAa,EAAwC,CACnD,GAAM,GAAe,aAAa,QAAQ,KAAK,OAAO,CAAO,CAAC,EAE9D,MAAQ,IAAgB,KAAK,0BAA0B,kCAAkC,KAAK,MAAM,CAAY,CAAC,GAC5G,MACP,CAEA,cAAc,EAAkC,CAC9C,MAAO,GAAU,IAAI,GAAW,KAAK,aAAa,CAAO,CAAC,EACvD,OAAO,OAAO,CACnB,CAEA,gBAAgB,EAAiB,EAAiC,CAChE,GAAM,GAAsB,KAAK,0BAA0B,kCAAkC,CAAS,EACtG,GAAI,CAAC,EACH,KAAM,IAAI,OAAM,wBAAwB,oDAA0D,EAEpG,oBAAa,QAAQ,KAAK,OAAO,CAAO,EAAG,KAAK,UAAU,CAAmB,CAAC,EAEvE,CACT,CAEA,gBAAgB,EAA0B,CACxC,oBAAa,WAAW,KAAK,OAAO,CAAO,CAAC,EAErC,EACT,CAEA,AAAU,OAAO,EAAiB,CAChC,MAAO,MAAK,UAAY,CAC1B,CACF,EAzCa,GAAN,GACL,EADW,GACe,mBAAmB,cCIxC,GAAM,IAAN,KAAsD,CAG3D,YACqB,EACA,EACV,EAAoB,GAAuB,iBACpD,CAHmB,oBACA,iCACV,gBAEX,CAEA,GAAc,MAAM,CAClB,MAAO,MAAK,SACd,CAEA,aAAa,EAAwC,CACnD,GAAM,GAAkC,KAAK,mCAAmC,EAGhF,MAAO,GAAgC,IAAa,MAAK,0BAA0B,kCAAkC,EAAgC,EAAS,GACzJ,OACP,CAEA,cAAc,EAAkC,CAC9C,GAAM,GAAkC,KAAK,mCAAmC,EAEhF,MAAO,QAAO,OAAO,CAA+B,EACjD,IAAI,GAAuB,KAAK,0BAA0B,kCAAkC,CAAmB,CAAC,EAChH,OAAO,AAAC,GAAsC,CAAC,CAAC,GAAa,EAAU,QAAQ,EAAU,OAAO,EAAI,EAAE,CAC3G,CAEA,gBAAgB,EAAiB,EAAiC,CAChE,GAAM,GAAkC,KAAK,mCAAmC,EAC1E,EAAsB,KAAK,0BAA0B,kCAAkC,CAAS,EACtG,GAAI,CAAC,EACH,KAAM,IAAI,OAAM,wBAAwB,oDAA0D,EAEpG,SAAgC,GAAW,EAC3C,KAAK,aAAa,QAAQ,KAAK,IAAK,KAAK,UAAU,CAA+B,CAAC,EAE5E,CACT,CAEA,gBAAgB,EAA0B,CACxC,GAAM,GAAkC,KAAK,mCAAmC,EAEhF,MAAK,GAAgC,GAGrC,OAAO,GAAgC,GAEvC,AAAI,OAAO,KAAK,CAA+B,EAAE,OAC/C,KAAK,aAAa,QAAQ,KAAK,IAAK,KAAK,UAAU,CAA+B,CAAC,EAEnF,KAAK,aAAa,WAAW,KAAK,GAAG,EAEhC,IATE,EAUX,CAEA,AAAU,oCAA4D,CACpE,GAAM,GAAgB,KAAK,aAAa,QAAQ,KAAK,GAAG,EACxD,MAAK,GAGE,KAAK,MAAM,CAAa,EAFtB,CAAC,CAGZ,CACF,EAjEa,GAAN,GACL,EADW,GACe,mBAAmB,cCAxC,GAAM,GAAN,KAAiF,CAGtF,YACE,EAA6D,aAC7D,EAAuD,GAAI,GAC3D,CALF,OAAmB,iBAMjB,KAAK,cAAgB,MAAO,IAAkB,SAC1C,KAAK,8BAA8B,EAAe,CAAyB,EAC3E,CACN,CAEA,aAAa,EAAiD,CAC5D,MAAO,SAAQ,QAAQ,KAAK,cAAc,aAAa,CAAO,CAAC,CACjE,CAEA,iBAAiB,EAA2C,CAC1D,MAAO,SAAQ,QAAQ,KAAK,cAAc,cAAc,CAAS,CAAC,CACpE,CAEA,gBAAgB,EAAiB,EAA0C,CACzE,MAAO,SAAQ,QAAQ,KAAK,cAAc,gBAAgB,EAAS,CAAS,CAAC,CAC/E,CAIA,gBAAgB,EAA0D,CACxE,GAAM,GAAU,MAAO,IAAuB,SAC1C,EACA,EAAmB,QAEvB,MAAO,SAAQ,QAAQ,KAAK,cAAc,gBAAgB,CAAO,CAAC,CACpE,CAEA,AAAQ,8BAA8B,EAA2C,EAAsD,CACrI,OAAQ,OACD,aACH,MAAO,IAAI,IAAuB,WAAW,aAAc,CAAyB,MACjF,gBACH,MAAO,IAAI,IAA0B,WAAW,aAAc,CAAyB,UAEvF,KAAM,IAAI,OAAM,oCAAoC,GAAc,EAExE,CACF,ECnDO,GAAM,IAAN,KAA6E,CAA7E,cACL,OAAmB,gBAAwC,GAAI,MAE/D,aAAa,EAAiD,CAC5D,MAAO,SAAQ,QAAQ,KAAK,cAAc,IAAI,CAAO,CAAC,CACxD,CAEA,iBAAiB,EAA2C,CAC1D,MAAO,SAAQ,QACb,EAAU,OACR,CAAC,EAAQ,IAAY,CACnB,GAAM,GAAY,KAAK,cAAc,IAAI,CAAO,EAChD,MAAI,IACF,EAAO,KAAK,CAAS,EAEhB,CACT,EACA,CAAC,CACH,CACF,CACF,CAEA,gBAAgB,EAAiB,EAA0C,CACzE,YAAK,cAAc,IAAI,EAAS,CAAS,EAElC,QAAQ,QAAQ,CAAS,CAClC,CAIA,gBAAgB,EAA0D,CACxE,GAAM,GAAU,MAAO,IAAuB,SAC1C,EACA,EAAmB,QAEvB,MAAO,SAAQ,QAAQ,KAAK,cAAc,OAAO,CAAO,CAAC,CAC3D,CACF,ECnBO,GAAM,IAAoC,CAC/C,EACA,EACA,IACG,CACH,GAAM,GAAc,WAAW,OAAS,UAAY,OAEpD,MAAO,IAAI,GAAqB,CAC9B,cAAe,EAAc,cAC7B,eAAgB,EAAc,SAAS,eACvC,qBAAsB,EAAQ,qBAC9B,MAAO,IAAgB,UACnB,GAAI,GAAsC,EAAQ,MAAM,QAAQ,aAAa,EAC7E,GAAI,GACV,CAAC,CACH,ECtBA,GAAM,IAAmB,wBACnB,GAAkD,CACtD,cAAe,CACb,qBAAsB,GACtB,MAAO,CACL,KAAM,CAAC,EACP,QAAS,CACP,cAAe,YACjB,CACF,CACF,EACA,SAAU,CACR,WAAY,GACZ,oBAAqB,wBACvB,CACF,EAEM,GAAuB,6BACvB,GAAkD,CACtD,cAAe,CACb,qBAAsB,GACtB,MAAO,CACL,KAAM,CAAC,EACP,QAAS,CACP,cAAe,YACjB,CACF,CACF,EACA,SAAU,CACR,WAAY,GACZ,oBAAqB,6BACvB,CACF,EAEa,GAAuB,CAClC,QAAS,GACT,QAAS,EACX,ECnCO,GAAM,GAAN,KAAoB,CASzB,YACqB,EACA,EAA+B,GAAI,GAAc,EAAQ,aAAa,EACzF,CAFmB,eACA,qBAVrB,OAAU,qCACV,OAAU,+BACV,OAAU,+BAUV,CARA,GAAY,0BAAmD,CAC7D,MAAO,MAAK,aACd,CAQA,wBAAwB,EAAmH,CACzI,YAAK,kCAAoC,EAClC,IACT,CAEA,kBAAkB,EAAuG,CACvH,YAAK,4BAA8B,EAC5B,IACT,CAEA,mBAAmB,EAAyG,CAC1H,YAAK,6BAA+B,EAC7B,IACT,CAEA,OAAgB,CACd,GAAM,GAAqB,GAAI,IAC/B,KAAK,wBAAwB,UAAU,mBAAqB,EAC5D,KAAK,wBAAwB,UAAU,mBAAqB,EAC5D,KAAK,wBAAwB,UAAU,wBAA0B,KAAK,8BAA8B,EACpG,KAAK,wBAAwB,SAAS,eAAiB,KAAK,qBAAqB,EACjF,KAAK,wBAAwB,SAAS,qBAAuB,KAAK,2BAA2B,EAC7F,GAAM,GAAe,KAAK,6BAA6B,EACvD,KAAK,wBAAwB,SAAS,gBAAkB,EACxD,KAAK,wBAAwB,SAAS,YAAc,EACpD,KAAK,wBAAwB,SAAS,gBAAkB,KAAK,sBAAsB,EACnF,KAAK,wBAAwB,SAAS,YAAc,KAAK,kBAAkB,EAC3E,GAAM,GAAc,KAAK,+BAA+B,EAExD,MAAO,IAAI,GAAO,CAChB,cAAe,KAAK,cACpB,SAAU,CACR,eAAgB,KAAK,cAAc,SAAS,eAC5C,qBAAsB,KAAK,cAAc,SAAS,qBAClD,gBAAiB,KAAK,cAAc,SAAS,gBAC7C,YAAa,KAAK,cAAc,SAAS,WAC3C,EACA,aACF,CAAC,CACH,CAEA,AAAU,+BAAgC,CACxC,MAAO,IAAI,GACb,CAEA,AAAU,4BAA6B,CACrC,GAAM,GAAqC,GAAO,KAAK,cAAc,eAAe,cAEpF,MAAO,MAAK,kCACR,KAAK,kCAAkC,KAAK,cAAe,EAAoC,KAAK,OAAO,EAC3G,GAAkC,KAAK,cAAe,EAAoC,KAAK,OAAO,CAC5G,CAEA,AAAU,sBAAuB,CAC/B,MAAO,MAAK,4BACR,KAAK,4BAA4B,KAAK,cAAe,KAAK,OAAO,EACjE,GAAI,GAAe,KAAK,cAAc,aAAa,CACzD,CAEA,AAAU,8BAA+B,CACvC,GAAM,GAAgC,GAAO,KAAK,cAAc,eAAe,SAE/E,MAAO,IAA6B,KAAK,cAAe,CAA6B,CACvF,CAEA,AAAU,uBAAwB,CAChC,MAAO,MAAK,6BACR,KAAK,6BAA6B,KAAK,cAAe,KAAK,OAAO,EAClE,GAAI,GAAgB,KAAK,cAAc,SAAS,gBAAiB,KAAK,cAAc,UAAU,uBAAuB,CAC3H,CAEA,AAAU,mBAAoB,CAC5B,MAAO,IAAI,IAAY,KAAK,cAAc,SAAS,WAAW,CAChE,CAEA,AAAU,gCAA0E,CAClF,MAAO,CACL,MAAO,KAAK,oCAAoC,EAChD,SAAU,KAAK,uCAAuC,CACxD,CACF,CAEA,AAAU,qCAA+D,CACvE,GAAM,GAAmB,GAAI,IACvB,EAA2B,GAAI,IAC/B,EAA4B,GAAI,IAmBtC,MAjB8C,CAC5C,QAAS,CACP,WAAY,GACZ,mBACA,2BACA,4BACA,gBAAiB,CAAC,CACpB,EACA,QAAS,CACP,WAAY,GACZ,mBACA,2BACA,4BACA,gBAAiB,CAAC,CACpB,CACF,CAGF,CAEA,AAAU,wCAAkE,CAC1E,GAAM,GAAmB,GAAI,GACvB,EAA2B,GAAI,GAC/B,EAA4B,GAAI,GAmBtC,MAjBiD,CAC/C,QAAS,CACP,WAAY,GACZ,mBACA,2BACA,4BACA,gBAAiB,CAAC,CACpB,EACA,QAAS,CACP,WAAY,GACZ,mBACA,2BACA,4BACA,gBAAiB,CAAC,CACpB,CACF,CAGF,CACF,EC7JO,GAAM,IAA6B,AAAC,GAGlC,AAFS,GAAI,GAAc,OAAK,GAAL,CAAc,cAAe,SAAU,EAAC,EAE3D,MAAM,EAGV,GAA6B,AAAC,GAGlC,AAFS,GAAI,GAAc,OAAK,GAAL,CAAc,cAAe,SAAU,EAAC,EAE3D,MAAM,ECdvB,oJCAA,GAAO,GAAQ,CACb,IAAK,CACH,QAAS,CACP,QAAS,uBACX,EACA,QAAS,CACP,QAAS,4BACX,EACA,UAAW,CACT,QAAS,uBACX,CACF,EACA,YAAa,CACX,SAAU,CACR,IAAK,CACH,QAAS,CACP,QAAS,EACT,IAAK,gEACL,UAAW,EACb,EACA,QAAS,CACP,QAAS,EACT,IAAK,+DACL,UAAW,EACb,CACF,CACF,EACA,MAAO,CACL,IAAK,CACH,QAAS,CACP,QAAS,kBACT,IAAK,+BACL,UAAW,GACX,YAAa,IACb,yBAA0B,GAC1B,sBAAuB,EACvB,YAAa,GACf,EACA,QAAS,CACP,QAAS,kBACT,IAAK,iCACL,UAAW,GACX,YAAa,IACb,yBAA0B,GAC1B,sBAAuB,EACvB,YAAa,GACf,CACF,CACF,CACF,EACA,WAAY,CACV,IAAK,CACH,UAAW,CACT,QAAS,CACP,QAAS,6CACT,SAAU,GACZ,EACA,QAAS,CACP,QAAS,6CACT,SAAU,IACZ,EACA,IAAK,CACH,CACE,UAAW,GACX,OAAQ,CACN,CACE,QAAS,GACT,aAAc,UACd,KAAM,gBACN,KAAM,SACR,CACF,EACA,KAAM,YACN,KAAM,OACR,EACA,CACE,UAAW,GACX,OAAQ,CACN,CACE,QAAS,GACT,aAAc,UACd,KAAM,gBACN,KAAM,SACR,EACA,CACE,QAAS,GACT,aAAc,UACd,KAAM,UACN,KAAM,SACR,EACA,CACE,QAAS,GACT,aAAc,UACd,KAAM,SACN,KAAM,SACR,CACF,EACA,KAAM,QACN,KAAM,OACR,EACA,CACE,UAAW,GACX,OAAQ,CACN,CACE,QAAS,GACT,aAAc,UACd,KAAM,gBACN,KAAM,SACR,EACA,CACE,QAAS,GACT,aAAc,UACd,KAAM,eACN,KAAM,SACR,EACA,CACE,QAAS,GACT,aAAc,UACd,KAAM,aACN,KAAM,SACR,EACA,CACE,QAAS,GACT,aAAc,UACd,KAAM,mBACN,KAAM,SACR,EACA,CACE,QAAS,GACT,aAAc,UACd,KAAM,aACN,KAAM,SACR,EACA,CACE,QAAS,GACT,aAAc,UACd,KAAM,SACN,KAAM,SACR,EACA,CACE,QAAS,GACT,aAAc,UACd,KAAM,UACN,KAAM,SACR,EACA,CACE,QAAS,GACT,aAAc,OACd,KAAM,UACN,KAAM,MACR,CACF,EACA,KAAM,YACN,KAAM,OACR,EACA,CACE,UAAW,GACX,OAAQ,CACN,CACE,QAAS,GACT,aAAc,UACd,KAAM,gBACN,KAAM,SACR,EACA,CACE,QAAS,GACT,aAAc,UACd,KAAM,UACN,KAAM,SACR,CACF,EACA,KAAM,WACN,KAAM,OACR,EACA,CACE,UAAW,GACX,OAAQ,CACN,CACE,QAAS,GACT,aAAc,UACd,KAAM,gBACN,KAAM,SACR,CACF,EACA,KAAM,WACN,KAAM,OACR,EACA,CACE,SAAU,GACV,OAAQ,CACN,CACE,aAAc,UACd,KAAM,GACN,KAAM,SACR,CACF,EACA,KAAM,QACN,QAAS,CACP,CACE,aAAc,UACd,KAAM,eACN,KAAM,SACR,EACA,CACE,aAAc,kBACd,KAAM,YACN,KAAM,SACR,EACA,CACE,aAAc,kBACd,KAAM,cACN,KAAM,SACR,EACA,CACE,aAAc,UACd,KAAM,kBACN,KAAM,SACR,EACA,CACE,aAAc,UACd,KAAM,YACN,KAAM,SACR,EACA,CACE,aAAc,UACd,KAAM,QACN,KAAM,SACR,EACA,CACE,aAAc,UACd,KAAM,SACN,KAAM,SACR,EACA,CACE,aAAc,OACd,KAAM,SACN,KAAM,MACR,EACA,CACE,aAAc,oBACd,KAAM,QACN,KAAM,OACR,CACF,EACA,QAAS,GACT,gBAAiB,OACjB,KAAM,UACR,EACA,CACE,SAAU,GACV,OAAQ,CACN,CACE,aAAc,UACd,KAAM,gBACN,KAAM,SACR,EACA,CACE,aAAc,kBACd,KAAM,eACN,KAAM,SACR,EACA,CACE,aAAc,UACd,KAAM,mBACN,KAAM,SACR,EACA,CACE,aAAc,UACd,KAAM,UACN,KAAM,SACR,CACF,EACA,KAAM,WACN,QAAS,CAAC,EACV,QAAS,GACT,gBAAiB,UACjB,KAAM,UACR,EACA,CACE,SAAU,GACV,OAAQ,CACN,CACE,aAAc,UACd,KAAM,gBACN,KAAM,SACR,CACF,EACA,KAAM,MACN,QAAS,CAAC,EACV,QAAS,GACT,gBAAiB,UACjB,KAAM,UACR,EACA,CACE,SAAU,GACV,OAAQ,CACN,CACE,aAAc,UACd,KAAM,gBACN,KAAM,SACR,CACF,EACA,KAAM,WACN,QAAS,CAAC,EACV,QAAS,GACT,gBAAiB,aACjB,KAAM,UACR,EACA,CACE,SAAU,GACV,OAAQ,CACN,CACE,aAAc,UACd,KAAM,gBACN,KAAM,SACR,EACA,CACE,aAAc,UACd,KAAM,UACN,KAAM,SACR,CACF,EACA,KAAM,SACN,QAAS,CAAC,EACV,QAAS,GACT,gBAAiB,aACjB,KAAM,UACR,EACA,CACE,SAAU,GACV,OAAQ,CACN,CACE,aAAc,UACd,KAAM,gBACN,KAAM,SACR,CACF,EACA,KAAM,SACN,QAAS,CAAC,EACV,QAAS,GACT,gBAAiB,aACjB,KAAM,UACR,CACF,CACF,EACA,SAAU,CACR,SAAU,GACV,UAAW,CACb,EACA,WAAY,UACd,EACA,IAAK,CACH,UAAW,CACT,QAAS,CACP,QAAS,uCACT,aAAc,IACd,eAAgB,IAChB,SAAU,IACZ,EACA,QAAS,CACP,QAAS,uCACT,aAAc,IACd,eAAgB,IAChB,SAAU,IACZ,EACA,YAAa,CACX,QAAS,CACP,KAAM,KACN,KAAM,CACJ,CACE,KAAM,KACN,KAAM,CACJ,CACE,KAAM,OACN,KAAM,CACJ,CACE,KAAM,UACN,OAAQ,CACN,cACF,CACF,EACA,CACE,KAAM,OACN,KAAM,CACJ,CACE,KAAM,OACN,KAAM,CACJ,CACE,KAAM,QACN,OAAQ,CACN,gBACF,CACF,EACA,CACE,KAAM,YACN,OAAQ,CACN,cACF,CACF,CACF,CACF,EACA,CACE,KAAM,QACN,OAAQ,CACN,SACF,CACF,CACF,EACA,OAAQ,CACN,WACF,CACF,CACF,EACA,OAAQ,CACN,YACA,WACF,CACF,EACA,CACE,KAAM,QACN,OAAQ,CACN,iBACA,MACF,CACF,CACF,EACA,OAAQ,CACN,OACF,CACF,EACA,CACE,KAAM,KACN,KAAM,CACJ,CACE,KAAM,QACN,OAAQ,CACN,UACA,SACF,CACF,EACA,CACE,KAAM,QACN,OAAQ,CACN,iBACA,SACF,CACF,CACF,EACA,OAAQ,CACN,WACF,CACF,CACF,CACF,EACA,SAAU,CACR,KAAM,KACN,KAAM,CACJ,CACE,KAAM,QACN,OAAQ,CACN,UACA,SACF,CACF,EACA,CACE,KAAM,QACN,OAAQ,CACN,iBACA,SACF,CACF,CACF,CACF,EACA,OAAQ,CACN,KAAM,QACN,OAAQ,CACN,gBACF,CACF,EACA,OAAQ,CACN,KAAM,QACN,OAAQ,CACN,SACF,CACF,EACA,SAAU,CACR,KAAM,OACN,KAAM,CACJ,CACE,KAAM,UACN,OAAQ,CACN,cACF,CACF,EACA,CACE,KAAM,OACN,KAAM,CACJ,CACE,KAAM,OACN,KAAM,CACJ,CACE,KAAM,QACN,OAAQ,CACN,gBACF,CACF,EACA,CACE,KAAM,YACN,OAAQ,CACN,cACF,CACF,CACF,CACF,EACA,CACE,KAAM,QACN,OAAQ,CACN,SACF,CACF,CACF,EACA,OAAQ,CACN,WACF,CACF,CACF,EACA,OAAQ,CACN,WACF,CACF,EACA,KAAM,CACJ,KAAM,KACN,KAAM,CACJ,CACE,KAAM,OACN,KAAM,CACJ,CACE,KAAM,UACN,OAAQ,CACN,cACF,CACF,EACA,CACE,KAAM,OACN,KAAM,CACJ,CACE,KAAM,OACN,KAAM,CACJ,CACE,KAAM,QACN,OAAQ,CACN,gBACF,CACF,EACA,CACE,KAAM,YACN,OAAQ,CACN,cACF,CACF,CACF,CACF,EACA,CACE,KAAM,QACN,OAAQ,CACN,SACF,CACF,CACF,EACA,OAAQ,CACN,WACF,CACF,CACF,EACA,OAAQ,CACN,YACA,WACF,CACF,EACA,CACE,KAAM,QACN,OAAQ,CACN,iBACA,MACF,CACF,CACF,CACF,EACA,IAAK,CACH,KAAM,QACN,OAAQ,CACN,gBACF,CACF,CACF,CACF,EACA,SAAU,CACR,SAAU,EACV,UAAW,CACb,EACA,WAAY,OACd,EACA,MAAO,CACL,UAAW,CACT,QAAS,CACP,QAAS,uCACT,aAAc,uCACd,aAAc,IACd,eAAgB,IAChB,SAAU,GACZ,EACA,QAAS,CACP,QAAS,uCACT,aAAc,GACd,aAAc,IACd,eAAgB,IAChB,SAAU,GACZ,EACA,YAAa,CACX,QAAS,CACP,KAAM,KACN,KAAM,CACJ,CACE,KAAM,KACN,KAAM,CACJ,CACE,KAAM,OACN,KAAM,CACJ,CACE,KAAM,OACN,KAAM,CACJ,CACE,KAAM,OACN,KAAM,CACJ,CACE,KAAM,QACN,OAAQ,CACN,eACF,CACF,EACA,CACE,KAAM,UACN,OAAQ,CACN,cACF,CACF,CACF,CACF,EACA,CACE,KAAM,OACN,KAAM,CACJ,CACE,KAAM,MACN,OAAQ,CACN,eACF,CACF,EACA,CACE,KAAM,YACN,OAAQ,CACN,aACF,CACF,CACF,CACF,CACF,CACF,EACA,CACE,KAAM,OACN,KAAM,CACJ,CACE,KAAM,UACN,OAAQ,CACN,eACF,CACF,EACA,CACE,KAAM,MACN,OAAQ,CACN,cACF,CACF,CACF,CACF,CACF,EACA,OAAQ,CACN,WACF,CACF,EACA,CACE,KAAM,QACN,OAAQ,CACN,SACF,CACF,CACF,CACF,EACA,CACE,KAAM,QACN,OAAQ,CACN,SACF,CACF,CACF,CACF,EACA,OAAQ,CACN,KAAM,OACR,EACA,OAAQ,CACN,KAAM,OACR,EACA,SAAU,CACR,KAAM,OACN,KAAM,CACJ,CACE,KAAM,OACN,KAAM,CACJ,CACE,KAAM,OACN,KAAM,CACJ,CACE,KAAM,QACN,OAAQ,CACN,eACF,CACF,EACA,CACE,KAAM,UACN,OAAQ,CACN,cACF,CACF,CACF,CACF,EACA,CACE,KAAM,MACN,OAAQ,CACN,eACF,CACF,EACA,CACE,KAAM,YACN,OAAQ,CACN,aACF,CACF,CACF,CACF,EACA,CACE,KAAM,UACN,OAAQ,CACN,eACF,CACF,EACA,CACE,KAAM,MACN,OAAQ,CACN,cACF,CACF,CACF,CACF,CACF,CACF,EACA,SAAU,CACR,SAAU,EACV,UAAW,CACb,EACA,WAAY,OACd,EACA,SAAU,CACR,UAAW,CACT,QAAS,CACP,QAAS,uCACT,aAAc,uCACd,aAAc,IACd,eAAgB,IAChB,SAAU,GACZ,EACA,QAAS,CACP,QAAS,uCACT,aAAc,uCACd,aAAc,IACd,eAAgB,IAChB,SAAU,GACZ,EACA,YAAa,CACX,QAAS,CACP,KAAM,KACN,KAAM,CACJ,CACE,KAAM,KACN,KAAM,CACJ,CACE,KAAM,OACN,KAAM,CACJ,CACE,KAAM,OACN,KAAM,CACJ,CACE,KAAM,OACN,KAAM,CACJ,CACE,KAAM,QACN,OAAQ,CACN,eACF,CACF,EACA,CACE,KAAM,UACN,OAAQ,CACN,cACF,CACF,CACF,CACF,EACA,CACE,KAAM,OACN,KAAM,CACJ,CACE,KAAM,MACN,OAAQ,CACN,eACF,CACF,EACA,CACE,KAAM,YACN,OAAQ,CACN,aACF,CACF,CACF,CACF,CACF,CACF,EACA,CACE,KAAM,OACN,KAAM,CACJ,CACE,KAAM,OACN,KAAM,CACJ,CACE,KAAM,UACN,OAAQ,CACN,eACF,CACF,EACA,CACE,KAAM,MACN,OAAQ,CACN,UACF,CACF,CACF,CACF,EACA,CACE,KAAM,MACN,OAAQ,CACN,cACF,CACF,CACF,CACF,CACF,EACA,OAAQ,CACN,WACF,CACF,EACA,CACE,KAAM,QACN,OAAQ,CACN,SACF,CACF,CACF,CACF,EACA,CACE,KAAM,QACN,OAAQ,CACN,SACF,CACF,CACF,CACF,EACA,OAAQ,CACN,KAAM,OACR,EACA,OAAQ,CACN,KAAM,OACR,EACA,SAAU,CACR,KAAM,OACN,KAAM,CACJ,CACE,KAAM,OACN,KAAM,CACJ,CACE,KAAM,OACN,KAAM,CACJ,CACE,KAAM,QACN,OAAQ,CACN,eACF,CACF,EACA,CACE,KAAM,UACN,OAAQ,CACN,cACF,CACF,CACF,CACF,EACA,CACE,KAAM,MACN,OAAQ,CACN,eACF,CACF,EACA,CACE,KAAM,YACN,OAAQ,CACN,aACF,CACF,CACF,CACF,EACA,CACE,KAAM,OACN,KAAM,CACJ,CACE,KAAM,UACN,OAAQ,CACN,eACF,CACF,EACA,CACE,KAAM,MACN,OAAQ,CACN,UACF,CACF,CACF,CACF,EACA,CACE,KAAM,MACN,OAAQ,CACN,cACF,CACF,CACF,CACF,CACF,CACF,EACA,SAAU,CACR,SAAU,EACV,UAAW,CACb,EACA,WAAY,OACd,CACF,CACF,ECz6BO,GAAM,IAAN,KAAa,CAMlB,YACE,EACA,EACA,EACA,CATF,OAAQ,YACR,OAAQ,YACR,OAAQ,cACR,OAAQ,yBAON,KAAK,SAAW,EAChB,KAAK,SAAW,EAChB,KAAK,WAAa,CACpB,CAEA,MAAO,QAAO,EAAsD,CAClE,MAAO,IAAI,IACT,GAAW,UAAY,UAAY,UACnC,EA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",
  "names": []
}
