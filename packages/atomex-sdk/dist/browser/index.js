var ge=Object.defineProperty,ze=Object.defineProperties;var ve=Object.getOwnPropertyDescriptors;var he=Object.getOwnPropertySymbols;var Ee=Object.prototype.hasOwnProperty,_e=Object.prototype.propertyIsEnumerable;var se=(i,e,t)=>e in i?ge(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,_=(i,e)=>{for(var t in e||(e={}))Ee.call(e,t)&&se(i,t,e[t]);if(he)for(var t of he(e))_e.call(e,t)&&se(i,t,e[t]);return i},ye=(i,e)=>ze(i,ve(e));var N=(i,e)=>{for(var t in e)ge(i,t,{get:e[t],enumerable:!0})};var s=(i,e,t)=>(se(i,typeof e!="symbol"?e+"":e,t),t);var Q=class{constructor(e){s(this,"atomexNetwork");s(this,"authorization");s(this,"signers");s(this,"currenciesProvider");this.atomexNetwork=e.atomexNetwork,this.currenciesProvider=e.providers.currenciesProvider,this.signers=e.signersManager,this.authorization=e.authorizationManager}async swap(e,t){throw new Error("Not implemented")}};var l=class{constructor(){s(this,"listeners",new Set)}addListener(e){return this.listeners.add(e),this}removeListener(e){return this.listeners.has(e)&&this.listeners.delete(e),this}removeAllListeners(){return this.listeners=new Set,this}emit(...e){!this.listeners.size||(this.listeners.size===1?this.listeners.values().next().value(...e):[...this.listeners].forEach(t=>t(...e)))}};import{Buffer as S}from"buffer";var fe=fetch;var w={};N(w,{hexStringToObject:()=>Me,hexStringToString:()=>Se,hexStringToUint8Array:()=>xe,numberToTokensAmount:()=>Ie,objectToHexString:()=>Be,stringToHexString:()=>Ae,tokensAmountToNat:()=>Ce,uint8ArrayToHexString:()=>V});import Te from"bignumber.js";var xe=i=>{var t;let e=(t=i.match(/[\da-f]{2}/gi))==null?void 0:t.map(r=>parseInt(r,16));return new Uint8Array(e)},V=i=>S.from(i).toString("hex"),Ae=i=>S.from(i,"utf8").toString("hex"),Se=i=>S.from(xe(i)).toString("utf8"),Be=i=>Ae(JSON.stringify(i)),Me=i=>{try{return JSON.parse(Se(i))}catch(e){return null}},Ce=(i,e)=>new Te(i).multipliedBy(10**e).integerValue(),Ie=(i,e)=>new Te(i).integerValue().div(10**e);var f={};N(f,{ensureNetworksAreSame:()=>Ne});var Ne=(i,e)=>{if((typeof i=="string"?i:i.atomexNetwork)!==(typeof e=="string"?e:e.atomexNetwork))throw new Error("Networks are different")};var O={};N(O,{capitalize:()=>Oe,padEnd:()=>De,padStart:()=>Re});var Oe=i=>{var e;return i&&((e=i[0])==null?void 0:e.toLocaleUpperCase())+i.slice(1)},we=(i,e,t,r=" ")=>{if(String.prototype.padStart!==void 0)return i.padStart(t,r);let n=i.length;if(t<=n||r=="")return i;let o=t-n,a=r.repeat(Math.ceil(o/r.length));return a.length>o&&(a=a.slice(0,o)),e?a+i:i+a},Re=(i,e,t=" ")=>String.prototype.padStart!==void 0?i.padStart(e,t):we(i,!0,e,t),De=(i,e,t=" ")=>String.prototype.padEnd!==void 0?i.padEnd(e,t):we(i,!1,e,t);var bt=i=>new Promise(e=>setTimeout(e,i));var R=class{constructor(e){s(this,"events",{authorized:new l,unauthorized:new l,authTokenExpiring:new l,authTokenExpired:new l});s(this,"atomexNetwork");s(this,"signersManager");s(this,"store");s(this,"authorizationUrl");s(this,"expiringNotificationTimeInSeconds");s(this,"_authTokenData",new Map);s(this,"authTokenExpiringTimeoutCallback",e=>{let t=this._authTokenData.get(e.address);if(!t)return;clearTimeout(t.watcherId);let r=e.expired.getTime()-Date.now(),n=setTimeout(this.authTokenExpiredTimeoutCallback,r,e);this._authTokenData.set(e.address,ye(_({},t),{watcherId:n})),this.events.authTokenExpiring.emit(e)});s(this,"authTokenExpiredTimeoutCallback",e=>{this.unregisterAuthToken(e),this.events.authTokenExpired.emit(e)});this.atomexNetwork=e.atomexNetwork,this.store=e.store,this.signersManager=e.signersManager,f.ensureNetworksAreSame(this,this.signersManager),this.authorizationUrl=new URL(R.DEFAULT_GET_AUTH_TOKEN_URI,e.authorizationBaseUrl),this.expiringNotificationTimeInSeconds=e.expiringNotificationTimeInSeconds||R.DEFAULT_EXPIRING_NOTIFICATION_TIME_IN_SECONDS}get authTokenData(){return this._authTokenData}getAuthToken(e){var t;return(t=this.authTokenData.get(e))==null?void 0:t.authToken}async authorize(e,t=!1,r,n=R.DEFAULT_AUTH_MESSAGE){if(!t){let p=this.getAuthToken(e)||await this.loadAuthTokenFromStore(e);if(p&&!this.isTokenExpiring(p))return p}let o=await this.signersManager.findSigner(e,r);if(!o)throw new Error(`Not found: the corresponding signer by the ${e} address`);let a=this.getAuthorizationTimeStamp(n),m=await o.sign(n+a);if(m.address!==e)throw new Error("Invalid address in the signed data");let d=await this.requestAuthToken({message:n,publicKey:m.publicKeyBytes,algorithm:m.algorithm,signingDataType:m.signingDataType,signature:m.signatureBytes,timeStamp:a}),u={value:d.token,userId:d.id,address:e,expired:new Date(d.expires)};return await this.registerAuthToken(u,!0),u}async unauthorize(e){let t=this.getAuthToken(e);return t?this.unregisterAuthToken(t):!1}async loadAuthTokenFromStore(e){let t=await this.store.getAuthToken(e);if(!!t)return await this.registerAuthToken(t,!1)}async registerAuthToken(e,t){let r=this.trackAuthToken(e);if(!r)return;let n={authToken:e,watcherId:r};return this._authTokenData.set(e.address,n),t&&(e=await this.store.upsertAuthToken(e.address,e)),this.events.authorized.emit(e),e}async unregisterAuthToken(e){let t=this._authTokenData.get(e.address);if(!t)return!1;this.untrackAuthToken(t.watcherId);let r=await this.store.removeAuthToken(e)&&this._authTokenData.delete(e.address);return r&&this.events.unauthorized.emit(e),r}trackAuthToken(e){let t=e.expired.getTime()-Date.now();if(t<=0){this.store.removeAuthToken(e),this.events.authTokenExpired.emit(e);return}let r=t-this.expiringNotificationTimeInSeconds*1e3;return setTimeout(this.authTokenExpiringTimeoutCallback,r,e)}untrackAuthToken(e){clearTimeout(e)}getAuthorizationTimeStamp(e){return Date.now()}async requestAuthToken(e){let t=await fe(this.authorizationUrl.href,{method:"POST",headers:{Accept:"application/json","Content-Type":"application/json"},body:JSON.stringify(e)});if(!t.ok)throw new Error(await t.text());return t.json()}isTokenExpiring(e){return e.expired.getTime()-Date.now()<=this.expiringNotificationTimeInSeconds*1e3}},P=R;s(P,"DEFAULT_AUTH_MESSAGE","Signing in "),s(P,"DEFAULT_GET_AUTH_TOKEN_URI","/v1/token"),s(P,"DEFAULT_EXPIRING_NOTIFICATION_TIME_IN_SECONDS",60);var Z=class{constructor(e){this.atomexNetwork=e;s(this,"_signers",new Set)}get signers(){return this._signers}addSigner(e){return f.ensureNetworksAreSame(this,e),this._signers.add(e),Promise.resolve(e)}async removeSigner(e,t){let r=typeof e=="string"?await this.findSigner(e,t):e;return r?this._signers.delete(r):!1}async findSigner(e,t){if(!this.signers.size)return;let r=[];for(let o of this.signers){if(t&&o.blockchain!==t)continue;let a=o.getAddress();if(typeof a=="string"){if(a===e)return o;continue}r.push(a.then(m=>[o,m]))}let n=await Promise.allSettled(r);for(let o of n)if(o.status==="fulfilled"&&o.value[1]===e)return o.value[0]}};var z=class{mapAuthTokenToSerializedAuthToken(e){return{a:e.address,u:e.userId,e:e.expired.getTime(),v:e.value}}mapSerializedAuthTokenToAuthToken(e){return{address:e.a,userId:e.u,expired:new Date(e.e),value:e.v}}};var ae=class{constructor(e,t,r=ae.DefaultKeyPrefix){this.localStorage=e;this.serializedAuthTokenMapper=t;this.keyPrefix=r}getAuthToken(e){let t=localStorage.getItem(this.getKey(e));return t&&this.serializedAuthTokenMapper.mapSerializedAuthTokenToAuthToken(JSON.parse(t))||void 0}getAuthTokens(e){return e.map(t=>this.getAuthToken(t)).filter(Boolean)}upsertAuthToken(e,t){let r=this.serializedAuthTokenMapper.mapAuthTokenToSerializedAuthToken(t);if(!r)throw new Error(`The authToken of the ${e} address can't be stored: serialization is failed`);return localStorage.setItem(this.getKey(e),JSON.stringify(r)),t}removeAuthToken(e){return localStorage.removeItem(this.getKey(e)),!0}getKey(e){return this.keyPrefix+e}},D=ae;s(D,"DefaultKeyPrefix","authToken:");var me=class{constructor(e,t,r=me.DefaultKeyPrefix){this.localStorage=e;this.serializedAuthTokenMapper=t;this.keyPrefix=r}get key(){return this.keyPrefix}getAuthToken(e){let t=this.getSerializedAuthTokensStoreObject();return t[e]&&(this.serializedAuthTokenMapper.mapSerializedAuthTokenToAuthToken(t[e])||void 0)}getAuthTokens(e){let t=this.getSerializedAuthTokensStoreObject();return Object.values(t).map(r=>this.serializedAuthTokenMapper.mapSerializedAuthTokenToAuthToken(r)).filter(r=>!!r&&e.indexOf(r.address)>-1)}upsertAuthToken(e,t){let r=this.getSerializedAuthTokensStoreObject(),n=this.serializedAuthTokenMapper.mapAuthTokenToSerializedAuthToken(t);if(!n)throw new Error(`The authToken of the ${e} address can't be stored: serialization is failed`);return r[e]=n,this.localStorage.setItem(this.key,JSON.stringify(r)),t}removeAuthToken(e){let t=this.getSerializedAuthTokensStoreObject();return t[e]?(delete t[e],Object.keys(t).length?this.localStorage.setItem(this.key,JSON.stringify(t)):this.localStorage.removeItem(this.key),!0):!1}getSerializedAuthTokensStoreObject(){let e=this.localStorage.getItem(this.key);return e?JSON.parse(e):{}}},U=me;s(U,"DefaultKeyPrefix","authTokens");var W=class{constructor(e="single-key",t=new z){s(this,"storeStrategy");this.storeStrategy=typeof e=="string"?this.createPreDefinedStoreStrategy(e,t):e}getAuthToken(e){return Promise.resolve(this.storeStrategy.getAuthToken(e))}getAuthTokens(...e){return Promise.resolve(this.storeStrategy.getAuthTokens(e))}upsertAuthToken(e,t){return Promise.resolve(this.storeStrategy.upsertAuthToken(e,t))}removeAuthToken(e){let t=typeof e=="string"?e:e.address;return Promise.resolve(this.storeStrategy.removeAuthToken(t))}createPreDefinedStoreStrategy(e,t){switch(e){case"single-key":return new U(globalThis.localStorage,t);case"multiple-keys":return new D(globalThis.localStorage,t);default:throw new Error(`Unknown the store strategy name: ${e}`)}}};var J=class{constructor(e,t){this.atomexNetwork=e;this.authorizationManager=t;s(this,"orderUpdated",new l);s(this,"orderBookUpdated",new l);s(this,"topOfBookUpdated",new l)}getOrder(e){throw new Error("Method not implemented.")}getOrders(e){throw new Error("Method not implemented.")}getSymbols(){throw new Error("Method not implemented.")}getTopOfBook(){throw new Error("Method not implemented.")}getOrderBook(){throw new Error("Method not implemented.")}addOrder(e){throw new Error("Method not implemented.")}cancelOrder(e){throw new Error("Method not implemented.")}cancelAllOrders(){throw new Error("Method not implemented.")}getSwapTransactions(e){throw new Error("Method not implemented.")}getSwap(e){throw new Error("Not implemented")}};var X=class{constructor(e,t){this.atomexNetwork=e;this.authorizationManager=t;s(this,"orderUpdated",new l);s(this,"orderBookUpdated",new l);s(this,"topOfBookUpdated",new l)}getOrder(e){throw new Error("Method not implemented.")}getOrders(e){throw new Error("Method not implemented.")}getSymbols(){throw new Error("Method not implemented.")}getTopOfBook(){throw new Error("Method not implemented.")}getOrderBook(){throw new Error("Method not implemented.")}addOrder(e){throw new Error("Method not implemented.")}cancelOrder(e){throw new Error("Method not implemented.")}cancelAllOrders(){throw new Error("Method not implemented.")}getSwapTransactions(e){throw new Error("Method not implemented.")}getSwap(e){throw new Error("Not implemented")}};var Y=class{constructor(e,t,r){this.atomexNetwork=e;this.restAtomexClient=t;this.webSocketAtomexClient=r;f.ensureNetworksAreSame(this,t),f.ensureNetworksAreSame(this,r)}get orderUpdated(){return this.webSocketAtomexClient.orderUpdated}get orderBookUpdated(){return this.webSocketAtomexClient.orderBookUpdated}get topOfBookUpdated(){return this.webSocketAtomexClient.topOfBookUpdated}getOrder(e){return this.restAtomexClient.getOrder(e)}getOrders(e){return this.restAtomexClient.getOrders(e)}getSymbols(){return this.restAtomexClient.getSymbols()}getTopOfBook(){return this.restAtomexClient.getTopOfBook()}getOrderBook(){return this.restAtomexClient.getOrderBook()}addOrder(e){return this.restAtomexClient.addOrder(e)}cancelOrder(e){return this.restAtomexClient.cancelOrder(e)}cancelAllOrders(){return this.restAtomexClient.cancelAllOrders()}getSwapTransactions(e){return this.restAtomexClient.getSwapTransactions(e)}getSwap(e){return this.restAtomexClient.getSwap(e)}};var ce=(r=>(r[r.Local=0]="Local",r[r.Remote=1]="Remote",r[r.SafeMerged=2]="SafeMerged",r))(ce||{});var ee=class{constructor(e){s(this,"currencies");this.currencies=new Map(e instanceof Map?e:Object.entries(e))}getCurrency(e){return Promise.resolve(this.currencies.get(e))}addCurrency(e){this.currencies.set(e.id,e)}removeCurrency(e){return this.currencies.delete(e)}};import{ec as Ue}from"elliptic";var de=null,We=()=>(de||(de=new Ue("secp256k1")),de),Fe=i=>{let e=w.hexStringToUint8Array(i);if(e.length!==64&&e.length!==65)throw new Error(`Invalid signature: ${i}`);let t=e.length===64?27+(e[32]>>7):e[64];return(t===0||t===1)&&(t+=27),{r:V(e.slice(0,32)),s:V(e.slice(32,64)),v:t,recoveryParameter:1-t%2}},be=(i,e)=>{let t=Fe(i),r=S.from(e.startsWith("0x")?e.substring(2):e,"hex"),n=We().recoverPubKey(r,{r:t.r,s:t.s},t.recoveryParameter);return"0x"+n.encode("hex",!1)};var pe=class{constructor(e,t){this.atomexNetwork=e;this.web3=t;s(this,"blockchain","ethereum")}async getAddress(){let t=(await this.web3.eth.getAccounts())[0];if(!t)throw new Error("Address is unavailable");return t}getPublicKey(){}async sign(e){let t=await this.getAddress(),r=await this.signInternal(e,t),n=be(r,this.web3.eth.accounts.hashMessage(e));return{address:t,publicKeyBytes:n.startsWith("0x")?n.substring(2):n,signatureBytes:r.substring(r.startsWith("0x")?2:0,r.length-2),algorithm:pe.signingAlgorithm}}signInternal(e,t){return new Promise((r,n)=>this.web3.eth.personal.sign(e,t,"",(o,a)=>a?r(a):n(o)))}},B=pe;s(B,"signingAlgorithm","Keccak256WithEcdsa:Geth2940");var te=class{constructor(){s(this,"authTokensMap",new Map)}getAuthToken(e){return Promise.resolve(this.authTokensMap.get(e))}getAuthTokens(...e){return Promise.resolve(e.reduce((t,r)=>{let n=this.authTokensMap.get(r);return n&&t.push(n),t},[]))}upsertAuthToken(e,t){return this.authTokensMap.set(e,t),Promise.resolve(t)}removeAuthToken(e){let t=typeof e=="string"?e:e.address;return Promise.resolve(this.authTokensMap.delete(t))}};import{SigningType as Je}from"@airgap/beacon-sdk";import{b58cdecode as Qe,prefix as Ve,validatePkAndExtractPrefix as Ze}from"@taquito/utils";var g={};N(g,{decodeSignature:()=>F,getRawMichelineSigningData:()=>He,getRawSigningData:()=>Le,getTezosSigningAlgorithm:()=>Ge,getWalletMichelineSigningData:()=>je});import{b58cdecode as Ke,prefix as $e,Prefix as M}from"@taquito/utils";var qe="54657a6f73205369676e6564204d6573736167653a20",Pe=(i,e)=>{let t=w.stringToHexString(i),r=e?e+t:t,n=O.padStart((r.length/2).toString(16),8,"0");return"0501"+n+r},Le=i=>w.stringToHexString(i),He=i=>Pe(i),je=i=>Pe(i,qe),Ge=i=>{let e=i.substring(0,i.startsWith("tz")?3:4);switch(e){case M.TZ1:case M.EDPK:return"Ed25519:Blake2b";case M.TZ2:case M.SPPK:return"Blake2bWithEcdsa:Secp256k1";case M.TZ3:case M.P2PK:return"Blake2bWithEcdsa:Secp256r1";default:throw new Error(`Unexpected address/public key prefix: ${e} (${i})`)}},F=i=>{let e=i.startsWith("sig")?i.substring(0,3):i.substring(0,5),t=Ke(i,$e[e]);return Buffer.from(t).toString("hex")};var C=i=>{let e=Ze(i),t=Qe(i,Ve[e]);return S.from(t).toString("hex")};var re=class{constructor(e,t){this.atomexNetwork=e;this.beaconWallet=t;s(this,"blockchain","tezos")}getAddress(){return this.beaconWallet.getPKH()}async getPublicKey(){var e;return(e=await this.beaconWallet.client.getActiveAccount())==null?void 0:e.publicKey}async sign(e){let[t,r,n]=await Promise.all([this.getAddress(),this.getPublicKey(),this.beaconWallet.client.requestSignPayload({payload:g.getWalletMichelineSigningData(e),signingType:Je.MICHELINE})]);if(!r)throw new Error("BeaconWallet: public key is unavailable");let o=g.getTezosSigningAlgorithm(r),a=C(r),m=F(n.signature);return{address:t,algorithm:o,publicKeyBytes:a,signatureBytes:m,signingDataType:"tezos/wallet-micheline"}}};var ne=class{constructor(e,t){this.atomexNetwork=e;this.templeWallet=t;s(this,"blockchain","tezos")}getAddress(){return this.templeWallet.getPKH()}getPublicKey(){var e;return(e=this.templeWallet.permission)==null?void 0:e.publicKey}async sign(e){let[t,r,n]=await Promise.all([this.getAddress(),this.getPublicKey(),this.templeWallet.sign(g.getWalletMichelineSigningData(e))]);if(!r)throw new Error("TempleWallet: public key is unavailable");let o=g.getTezosSigningAlgorithm(r),a=C(r),m=F(n);return{address:t,algorithm:o,publicKeyBytes:a,signatureBytes:m,signingDataType:"tezos/wallet-micheline"}}};var K=class{constructor(e,t){this.atomexNetwork=e;this.wallet=t;s(this,"blockchain","tezos");s(this,"internalSigner");this.internalSigner=this.createInternalSigner()}getAddress(){return this.internalSigner.getAddress()}getPublicKey(){return this.internalSigner.getPublicKey()}sign(e){return this.internalSigner.sign(e)}createInternalSigner(){var e;if(((e=this.wallet.client)==null?void 0:e.name)!==void 0)return new re(this.atomexNetwork,this.wallet);if(this.wallet.permission!==void 0&&this.wallet.connected!==void 0)return new ne(this.atomexNetwork,this.wallet);throw new Error("Unknown Tezos wallet")}};import{InMemorySigner as Xe}from"@taquito/signer";var ie=class{constructor(e,t){this.atomexNetwork=e;s(this,"blockchain","tezos");s(this,"internalInMemorySigner");this.internalInMemorySigner=new Xe(t)}getAddress(){return this.internalInMemorySigner.publicKeyHash()}getPublicKey(){return this.internalInMemorySigner.publicKey()}async sign(e){let t=g.getRawSigningData(e),[r,n,o]=await Promise.all([this.getAddress(),this.getPublicKey(),this.internalInMemorySigner.sign(t)]),a=C(n),m=o.sbytes.substring(o.bytes.length),d=g.getTezosSigningAlgorithm(n);return{address:r,algorithm:d,publicKeyBytes:a,signatureBytes:m}}};var ue={};N(ue,{Atomex:()=>$,EthereumHelpers:()=>L,FA12Helpers:()=>j,FA2Helpers:()=>G,Helpers:()=>v,TezosHelpers:()=>T,dt2ts:()=>b,now:()=>q});var c={api:{mainnet:{baseUrl:"https://api.atomex.me"},testnet:{baseUrl:"https://api.test.atomex.me"},localhost:{baseUrl:"http://127.0.0.1:5000"}},blockchains:{ethereum:{rpc:{mainnet:{chainID:1,rpc:"https://mainnet.infura.io/v3/7cd728d2d3384719a630d836f1693c5c",blockTime:10},testnet:{chainID:5,rpc:"https://goerli.infura.io/v3/7cd728d2d3384719a630d836f1693c5c",blockTime:10}}},tezos:{rpc:{mainnet:{chainID:"NetXdQprcVkpaWU",rpc:"https://rpc.tzkt.io/mainnet/",blockTime:30,minimalFees:100,minimalNanotezPerGasUnit:.1,minimalNanotezPerByte:1,costPerByte:250},testnet:{chainID:"NetXnHfVqm9iesp",rpc:"https://rpc.tzkt.io/ithacanet/",blockTime:15,minimalFees:100,minimalNanotezPerGasUnit:.1,minimalNanotezPerByte:1,costPerByte:250}}}},currencies:{ETH:{contracts:{mainnet:{address:"0xe9c251cbb4881f9e056e40135e7d3ea9a7d037df",gasLimit:2e5},testnet:{address:"0x512fe6B803bA327DCeFBF2Cec7De333f761B0f2b",gasLimit:17e4},abi:[{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"_hashedSecret",type:"bytes32"}],name:"Activated",type:"event"},{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"_hashedSecret",type:"bytes32"},{indexed:!1,internalType:"address",name:"_sender",type:"address"},{indexed:!1,internalType:"uint256",name:"_value",type:"uint256"}],name:"Added",type:"event"},{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"_hashedSecret",type:"bytes32"},{indexed:!0,internalType:"address",name:"_participant",type:"address"},{indexed:!1,internalType:"address",name:"_initiator",type:"address"},{indexed:!1,internalType:"uint256",name:"_refundTimestamp",type:"uint256"},{indexed:!1,internalType:"uint256",name:"_countdown",type:"uint256"},{indexed:!1,internalType:"uint256",name:"_value",type:"uint256"},{indexed:!1,internalType:"uint256",name:"_payoff",type:"uint256"},{indexed:!1,internalType:"bool",name:"_active",type:"bool"}],name:"Initiated",type:"event"},{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"_hashedSecret",type:"bytes32"},{indexed:!1,internalType:"bytes32",name:"_secret",type:"bytes32"}],name:"Redeemed",type:"event"},{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"_hashedSecret",type:"bytes32"}],name:"Refunded",type:"event"},{constant:!0,inputs:[{internalType:"bytes32",name:"",type:"bytes32"}],name:"swaps",outputs:[{internalType:"bytes32",name:"hashedSecret",type:"bytes32"},{internalType:"address payable",name:"initiator",type:"address"},{internalType:"address payable",name:"participant",type:"address"},{internalType:"uint256",name:"refundTimestamp",type:"uint256"},{internalType:"uint256",name:"countdown",type:"uint256"},{internalType:"uint256",name:"value",type:"uint256"},{internalType:"uint256",name:"payoff",type:"uint256"},{internalType:"bool",name:"active",type:"bool"},{internalType:"enum Atomex.State",name:"state",type:"uint8"}],payable:!1,stateMutability:"view",type:"function"},{constant:!1,inputs:[{internalType:"bytes32",name:"_hashedSecret",type:"bytes32"},{internalType:"address payable",name:"_participant",type:"address"},{internalType:"uint256",name:"_refundTimestamp",type:"uint256"},{internalType:"uint256",name:"_payoff",type:"uint256"}],name:"initiate",outputs:[],payable:!0,stateMutability:"payable",type:"function"},{constant:!1,inputs:[{internalType:"bytes32",name:"_hashedSecret",type:"bytes32"}],name:"add",outputs:[],payable:!0,stateMutability:"payable",type:"function"},{constant:!1,inputs:[{internalType:"bytes32",name:"_hashedSecret",type:"bytes32"}],name:"activate",outputs:[],payable:!1,stateMutability:"nonpayable",type:"function"},{constant:!1,inputs:[{internalType:"bytes32",name:"_hashedSecret",type:"bytes32"},{internalType:"bytes32",name:"_secret",type:"bytes32"}],name:"redeem",outputs:[],payable:!1,stateMutability:"nonpayable",type:"function"},{constant:!1,inputs:[{internalType:"bytes32",name:"_hashedSecret",type:"bytes32"}],name:"refund",outputs:[],payable:!1,stateMutability:"nonpayable",type:"function"}]},decimals:{original:18,displayed:4},blockchain:"ethereum"},XTZ:{contracts:{mainnet:{address:"KT1VG2WtYdSWz5E7chTeAdDPZNy2MpP8pTfL",redeemTxSize:133,initiateTxSize:200,gasLimit:15e3},testnet:{address:"KT1SJMtHZFSPva5AzQEx5btBuQ8BjvXqort3",redeemTxSize:133,initiateTxSize:200,gasLimit:85e3},entrypoints:{default:{prim:"or",args:[{prim:"or",args:[{prim:"pair",args:[{prim:"address",annots:["%participant"]},{prim:"pair",args:[{prim:"pair",args:[{prim:"bytes",annots:["%hashed_secret"]},{prim:"timestamp",annots:["%refund_time"]}]},{prim:"mutez",annots:["%payoff"]}],annots:["%settings"]}],annots:[":initiate","%initiate"]},{prim:"bytes",annots:[":hashed_secret","%add"]}],annots:["%fund"]},{prim:"or",args:[{prim:"bytes",annots:[":secret","%redeem"]},{prim:"bytes",annots:[":hashed_secret","%refund"]}],annots:["%withdraw"]}]},withdraw:{prim:"or",args:[{prim:"bytes",annots:[":secret","%redeem"]},{prim:"bytes",annots:[":hashed_secret","%refund"]}]},refund:{prim:"bytes",annots:[":hashed_secret"]},redeem:{prim:"bytes",annots:[":secret"]},initiate:{prim:"pair",args:[{prim:"address",annots:["%participant"]},{prim:"pair",args:[{prim:"pair",args:[{prim:"bytes",annots:["%hashed_secret"]},{prim:"timestamp",annots:["%refund_time"]}]},{prim:"mutez",annots:["%payoff"]}],annots:["%settings"]}],annots:[":initiate"]},fund:{prim:"or",args:[{prim:"pair",args:[{prim:"address",annots:["%participant"]},{prim:"pair",args:[{prim:"pair",args:[{prim:"bytes",annots:["%hashed_secret"]},{prim:"timestamp",annots:["%refund_time"]}]},{prim:"mutez",annots:["%payoff"]}],annots:["%settings"]}],annots:[":initiate","%initiate"]},{prim:"bytes",annots:[":hashed_secret","%add"]}]},add:{prim:"bytes",annots:[":hashed_secret"]}}},decimals:{original:6,displayed:3},blockchain:"tezos"},TZBTC:{contracts:{mainnet:{address:"KT1Ap287P1NzsnToSJdA4aqSNjPomRaHBZSr",tokenAddress:"KT1PWx2mnDueood7fEmfbBDKx1D9BAnnXitn",redeemTxSize:133,initiateTxSize:250,gasLimit:1e5},testnet:{address:"KT1Jj1jzDQbDRHt4u7M73DUrBDV1napRbNFr",tokenAddress:"",redeemTxSize:133,initiateTxSize:250,gasLimit:1e5},entrypoints:{default:{prim:"or",args:[{prim:"or",args:[{prim:"pair",args:[{prim:"pair",args:[{prim:"pair",args:[{prim:"bytes",annots:["%hashedSecret"]},{prim:"address",annots:["%participant"]}]},{prim:"pair",args:[{prim:"nat",annots:["%payoffAmount"]},{prim:"timestamp",annots:["%refundTime"]}]}]},{prim:"pair",args:[{prim:"address",annots:["%tokenAddress"]},{prim:"nat",annots:["%totalAmount"]}]}],annots:["%initiate"]},{prim:"bytes",annots:["%redeem"]}]},{prim:"bytes",annots:["%refund"]}]},refund:{prim:"bytes"},redeem:{prim:"bytes"},initiate:{prim:"pair",args:[{prim:"pair",args:[{prim:"pair",args:[{prim:"bytes",annots:["%hashedSecret"]},{prim:"address",annots:["%participant"]}]},{prim:"nat",annots:["%payoffAmount"]},{prim:"timestamp",annots:["%refundTime"]}]},{prim:"address",annots:["%tokenAddress"]},{prim:"nat",annots:["%totalAmount"]}]}}},decimals:{original:8,displayed:4},blockchain:"tezos"},USDT_XTZ:{contracts:{mainnet:{address:"<mainnet address>",tokenAddress:"",redeemTxSize:2e4,initiateTxSize:2e4,gasLimit:4e5},testnet:{address:"KT1HHjNxi3okxxGJT1SPPhpcs3gMQt8hqixY",tokenAddress:"KT1BWvRQnVVowZZLGkct9A7sdj5YEe8CdUhR",redeemTxSize:2e4,initiateTxSize:2e4,gasLimit:4e5},entrypoints:{default:{prim:"or",args:[{prim:"or",args:[{prim:"pair",args:[{prim:"pair",args:[{prim:"pair",args:[{prim:"bytes",annots:["%hashedSecret"]},{prim:"address",annots:["%participant"]}]},{prim:"pair",args:[{prim:"nat",annots:["%payoffAmount"]},{prim:"timestamp",annots:["%refundTime"]}]}]},{prim:"pair",args:[{prim:"pair",args:[{prim:"address",annots:["%tokenAddress"]},{prim:"nat",annots:["%tokenId"]}]},{prim:"nat",annots:["%totalAmount"]}]}],annots:["%initiate"]},{prim:"bytes",annots:["%redeem"]}]},{prim:"bytes",annots:["%refund"]}]},refund:{prim:"bytes"},redeem:{prim:"bytes"},initiate:{prim:"pair",args:[{prim:"pair",args:[{prim:"pair",args:[{prim:"bytes",annots:["%hashedSecret"]},{prim:"address",annots:["%participant"]}]},{prim:"nat",annots:["%payoffAmount"]},{prim:"timestamp",annots:["%refundTime"]}]},{prim:"pair",args:[{prim:"address",annots:["%tokenAddress"]},{prim:"nat",annots:["%tokenId"]}]},{prim:"nat",annots:["%totalAmount"]}]}}},decimals:{original:6,displayed:4},blockchain:"tezos"}}};var $=class{constructor(e,t,r){s(this,"_network");s(this,"_baseUrl");s(this,"_authToken");s(this,"_authorizationManager");this._network=e,this._baseUrl=t,this._authToken=r}static create(e){return new $(e=="mainnet"?"mainnet":"testnet",c.api[e].baseUrl)}setAuthorizationManager(e){this._authorizationManager=e}getLocalAuthToken(e){var r;let t=(r=this._authorizationManager)==null?void 0:r.getAuthToken(e);return t==null?void 0:t.value}setAuthToken(e){this._authToken=e}async makeRequest(e,t,r=!1,n,o){let a=new URL(t,this._baseUrl);n!==void 0&&Object.keys(n).forEach(p=>a.searchParams.append(p,n[p]));let m={};if(r){let p=typeof r=="string"?this.getLocalAuthToken(r):this._authToken;if(!p)throw new Error("Auth token is undefined");m.Authorization=`Bearer ${p}`}let d;e==="post"&&o!==void 0&&(d=JSON.stringify(o),m["Content-Type"]="application/json");let u=await fetch(a.toString(),{method:e,headers:m,body:d});if(u.ok)return u.json();{let p=await u.text();throw Error(p)}}async getAuthToken(e){return this.makeRequest("post","/v1/Token",!1,{},e)}async getSymbols(){return this.makeRequest("get","/v1/Symbols",!1)}async getQuotes(e){let t=e!==void 0&&e.length>0?e.join(","):"All";return this.makeRequest("get","/v1/MarketData/quotes",!1,{symbols:t})}async getOrderBook(e){return this.makeRequest("get","/v1/MarketData/book",!1,{symbol:e})}async addOrder(e){var o;let[t,r]=this.splitSymbol(e.symbol).map(a=>this.getCurrencyConfig(a)),n=e;return n.requisites=_({baseCurrencyContract:t.contractAddress,quoteCurrencyContract:r.contractAddress},n.requisites),this.makeRequest("post","/v1/Orders",((o=e.requisites)==null?void 0:o.receivingAddress)||!0,{},n).then(a=>a.orderId)}async getOrders(e,t){return this.makeRequest("get","/v1/Orders",e||!0,_({},t))}async getOrder(e,t){return this.makeRequest("get",`/v1/Orders/${e}`,t||!0)}async cancelOrder(e,t,r,n){return this.makeRequest("delete",`/v1/Orders/${e}`,n||!0,{symbol:t,side:r}).then(o=>o.result)}async addSwapRequisites(e,t){return this.makeRequest("post",`/v1/Swaps/${e}/requisites`,(t==null?void 0:t.receivingAddress)||!0,{},t).then(r=>r.result)}async getSwaps(e,t){return this.makeRequest("get","/v1/Swaps",e||!0,_({},t))}async getSwap(e,t){return this.makeRequest("get",`/v1/Swaps/${e}`,t||!0)}getOrderPreview(e,t,r,n){let o=e.entries.filter(d=>d.side==t?!1:(()=>{switch(t+n){case"BuySend":case"SellReceive":return r/d.price;default:return r}})()<=Math.max(...d.qtyProfile)).map(d=>d.price);if(o.length==0)throw new Error(`No matching order found (${n} ${r} / ${t})`);let a=t=="Buy"?Math.min(...o):Math.max(...o),m=()=>{switch(t+n){case"BuySend":case"SellReceive":return r/a;default:return r*a}};return{price:a,amountSent:n=="Send"?r:m(),amountReceived:n=="Receive"?r:m()}}splitSymbol(e){let[t,r]=e.split("/",2);if(!t||!r)throw new Error("Symbol is invalid");return[t,r]}getCurrencyConfig(e){let t=Object.entries(c.currencies).find(([r,n])=>r==e);if(t==null)throw new Error(`No matching config section for ${e}`);return{blockchain:t[1].blockchain,decimals:t[1].decimals.original,displayDecimals:t[1].decimals.displayed,contractAddress:t[1].contracts[this._network].address,tokenAddress:t[1].contracts[this._network].tokenAddress}}formatAmount(e,t){let r=this.getCurrencyConfig(t);return parseFloat(typeof e=="string"?parseFloat(e).toFixed(r.displayDecimals):e.toFixed(r.displayDecimals))}getOrderSide(e,t,r){let[n,o]=this.splitSymbol(e);if(n===t&&o===r)return"Sell";if(o===t&&n===r)return"Buy";throw new Error(`Mismatch ${t} => ${r} (${e})`)}getMaxOrderSize(e,t){return Math.max(...e.entries.filter(r=>r.side!=t).map(r=>Math.max(...r.qtyProfile)))}};import et from"elliptic";import tt from"web3";var v=class{},b=i=>Math.round(new Date(i).getTime()/1e3),q=()=>Math.round(Date.now()/1e3);var L=class extends v{constructor(t,r,n,o,a){super();s(this,"_web3");s(this,"_contract");s(this,"_timeBetweenBlocks");s(this,"_functions");s(this,"_gasLimit");this._web3=t,this._contract=new t.eth.Contract(r,n),this._timeBetweenBlocks=o,this._gasLimit=a,this._functions=new Map,r.forEach(m=>{m.type==="function"&&this._functions.set(m.name,{types:m.inputs,signature:t.eth.abi.encodeFunctionSignature(m)})})}static async create(t,r){let n=c.blockchains.ethereum.rpc[t];r!==void 0&&(n.rpc=r);let o=new tt(n.rpc),a=await o.eth.getChainId();if(n.chainID!==a)throw new Error(`Wrong chain ID: expected ${n.chainID}, actual ${a}`);return new L(o,c.currencies.ETH.contracts.abi,c.currencies.ETH.contracts[t].address,n.blockTime,c.currencies.ETH.contracts[t].gasLimit)}getAuthMessage(t,r){let n=Date.now();return{message:t,timestamp:n,msgToSign:t+n.toString(),algorithm:"Keccak256WithEcdsa:Geth2940"}}buildInitiateTransaction(t){if(t.refundTimestamp<q())throw new Error(`Swap timestamp is in the past: ${t.refundTimestamp}`);return{data:this._contract.methods.initiate("0x"+t.secretHash,t.receivingAddress,t.refundTimestamp,t.rewardForRedeem).encodeABI(),contractAddr:this._contract.options.address,amount:t.netAmount+t.rewardForRedeem}}buildRedeemTransaction(t,r){return{data:this._contract.methods.redeem(r,t).encodeABI(),contractAddr:this._contract.options.address}}buildRefundTransaction(t){return{data:this._contract.methods.refund(t).encodeABI(),contractAddr:this._contract.options.address}}buildAddTransaction(t,r){return{data:this._contract.methods.add(t).encodeABI(),contractAddr:this._contract.options.address,amount:r}}buildActivateTransaction(t){return{data:this._contract.methods.activate(t).encodeABI(),contractAddr:this._contract.options.address}}parseInitiateParameters(t){let r=this._functions.get("initiate");if(!t.input.startsWith(r.signature))throw new Error(`Unexpected method signature: ${t.input}`);let n=this._web3.eth.abi.decodeParameters(r.types,t.input.slice(r.signature.length));return{secretHash:n._hashedSecret.slice(2),receivingAddress:n._participant,refundTimestamp:parseInt(n._refundTimestamp),rewardForRedeem:parseInt(this._web3.utils.toBN(n._payoff).toString()),netAmount:parseInt(this._web3.utils.toBN(t.value).sub(this._web3.utils.toBN(n._payoff)).toString())}}async validateInitiateTransaction(t,r,n,o,a,m,d,u=2){let p=a-m,y=await this._web3.eth.getTransaction(r);try{if(y===void 0)throw new Error(`Failed to retrieve transaction: ${r}`);if(y.to!==this._contract.options.address)throw new Error(`Wrong contract address: ${y.to}`);let h=this.parseInitiateParameters(y);if(h.secretHash!==n)throw new Error(`Secret hash: expect ${n}, actual ${h.secretHash}`);if(h.receivingAddress.toLowerCase()!==o.toLowerCase())throw new Error(`Receiving address: expect ${o}, actual ${h.receivingAddress}`);if(h.netAmount!==p)throw new Error(`Net amount: expect ${p}, actual ${h.netAmount}`);if(h.refundTimestamp<d)throw new Error(`Refund timestamp: minimum ${d}, actual ${h.refundTimestamp}`)}catch(h){return{status:"Invalid",message:h.message,confirmations:0,nextBlockETA:0}}let x=await this._web3.eth.getBlock("latest"),E=x.number-(y.blockNumber||x.number),k={status:y.blockNumber!==void 0?"Included":"Pending",confirmations:E,nextBlockETA:parseInt(x.timestamp.toString())+this._timeBetweenBlocks};return E>=u&&(k.status="Confirmed"),k}hexSlice(t,r,n){return"0x"+n.slice(t*2+2,r*2+2)}getVRS(t){let r=[this.hexSlice(64,(t.length-2)/2,t),this.hexSlice(0,32,t),this.hexSlice(32,64,t)];return{v:parseInt(r[0].slice(2),16),r:r[1].slice(2),s:r[2].slice(2)}}recoverPublicKey(t,r){let n=this._web3.eth.accounts.hashMessage(t),o=this.getVRS(r),m=new et.ec("secp256k1").recoverPubKey(Buffer.from(n.slice(2),"hex"),o,o.v<2?o.v:1-o.v%2);return"0x"+m.encode("hex",!1)}encodePublicKey(t){return t.startsWith("0x")?t.slice(2):t}encodeSignature(t){let r=this.getVRS(t);return r.r.padStart(64,"0")+r.s.padStart(64,"0")}async estimateInitiateFees(t){let r={receivingAddress:"0x0000000000000000000000000000000000000000",secretHash:"0000000000000000000000000000000000000000000000000000000000000000",refundTimestamp:2147483647,rewardForRedeem:0,netAmount:0},n=this.buildInitiateTransaction(r),o=await this._web3.eth.getGasPrice(),a=await this._web3.eth.estimateGas({from:t,to:n.contractAddr,data:n.data,value:n.amount});return parseInt(o)*a}async estimateRedeemFees(t){let r=await this._web3.eth.getGasPrice(),n=parseInt(r)*this._gasLimit;return{totalCost:n,rewardForRedeem:2*n}}isValidAddress(t){return this._web3.utils.isAddress(t)}};import{ParameterSchema as rt}from"@taquito/michelson-encoder";import{OpKind as nt}from"@taquito/rpc";import{TezosToolkit as it}from"@taquito/taquito";import{b58cdecode as oe,prefix as H,validateAddress as ot,ValidationResult as st}from"@taquito/utils";var at=i=>new Date(i*1e3).toISOString().slice(0,-5)+"Z",T=class extends v{constructor(t,r,n,o,a,m,d,u,p,y,x){super();s(this,"_tezos");s(this,"_contractAddress");s(this,"_timeBetweenBlocks");s(this,"_entrypoints");s(this,"_gasLimit");s(this,"_minimalFees");s(this,"_minimalNanotezPerGasUnit");s(this,"_minimalNanotezPerByte");s(this,"_costPerByte");s(this,"_redeemTxSize");s(this,"_initiateTxSize");this._tezos=t,this._contractAddress=n,this._timeBetweenBlocks=o,this._gasLimit=a,this._minimalFees=m,this._minimalNanotezPerGasUnit=d,this._minimalNanotezPerByte=u,this._costPerByte=p,this._redeemTxSize=y,this._initiateTxSize=x,this._entrypoints=new Map(Object.entries(r).map(([E,k])=>[E,new rt(k)]))}static async create(t,r="XTZ",n){let o=c.blockchains.tezos.rpc[t];n!==void 0&&(o.rpc=n);let a=new it(o.rpc),m=await a.rpc.getChainId();if(o.chainID!==m.toString())throw new Error(`Wrong chain ID: expected ${o.chainID}, actual ${m}`);return new T(a,c.currencies[r].contracts.entrypoints,c.currencies[r].contracts[t].address,c.blockchains.tezos.rpc[t].blockTime,c.currencies[r].contracts[t].gasLimit,c.blockchains.tezos.rpc[t].minimalFees,c.blockchains.tezos.rpc[t].minimalNanotezPerGasUnit,c.blockchains.tezos.rpc[t].minimalNanotezPerByte,c.blockchains.tezos.rpc[t].costPerByte,c.currencies[r].contracts[t].redeemTxSize,c.currencies[r].contracts[t].initiateTxSize)}getTezosAlgorithm(t){switch(t){case"tz1":return"Ed25519:Blake2b";case"tz2":return"Blake2bWithEcdsa:Secp256k1";case"tz3":return"Blake2bWithEcdsa:Secp256r1";default:throw new Error(`Unexpected address prefix: ${t}`)}}getAuthMessage(t,r){let n=Date.now();return{message:t,timestamp:n,msgToSign:t+n.toString(),algorithm:this.getTezosAlgorithm(r.slice(0,3))}}buildInitiateTransaction(t){var n;if(t.refundTimestamp<q())throw new Error(`Swap timestamp is in the past: ${t.refundTimestamp}`);let r=(n=this._entrypoints.get("initiate"))==null?void 0:n.Encode(t.receivingAddress,t.secretHash,at(t.refundTimestamp),t.rewardForRedeem);return{data:{entrypoint:"initiate",value:r},contractAddr:this._contractAddress,amount:t.netAmount+t.rewardForRedeem}}buildRedeemTransaction(t,r=""){var n;return{data:{entrypoint:"redeem",value:(n=this._entrypoints.get("redeem"))==null?void 0:n.Encode(t)},contractAddr:this._contractAddress}}buildRefundTransaction(t){var r;return{data:{entrypoint:"refund",value:(r=this._entrypoints.get("refund"))==null?void 0:r.Encode(t)},contractAddr:this._contractAddress}}buildAddTransaction(t,r){var n;return{amount:r,data:{entrypoint:"add",value:(n=this._entrypoints.get("add"))==null?void 0:n.Encode(t)},contractAddr:this._contractAddress}}getBlockDetails(t){return{level:t.metadata.level_info.level,timestamp:b(t.header.timestamp)}}parseInitiateParameters(t){var o;if(t.parameters===void 0)throw new Error("Parameters are undefined");let r=(o=this._entrypoints.get(t.parameters.entrypoint))==null?void 0:o.Execute(t.parameters.value);if(r===void 0)throw new Error(`Unexpected entrypoint: ${t.parameters.entrypoint}`);let n=(()=>{switch(t.parameters.entrypoint){case"initiate":return r;case"fund":case"default":return r.initiate;default:throw new Error(`Unexpected entrypoint: ${t.parameters.entrypoint}`)}})();return{secretHash:n.settings.hashed_secret,receivingAddress:n.participant,refundTimestamp:b(n.settings.refund_time),netAmount:parseInt(t.amount)-parseInt(n.settings.payoff),rewardForRedeem:parseInt(n.settings.payoff)}}findContractCall(t,r){var a;let n=(a=t.operations[3])==null?void 0:a.find(m=>m.hash==r);if(n===void 0)throw new Error(`Operation not found: ${r} @ ${t.hash}`);let o=n.contents.filter(m=>m.kind=="transaction"&&m.destination==this._contractAddress);if(o.length===0)throw new Error("Unsupported contract version is used");return o}async validateInitiateTransaction(t,r,n,o,a,m,d,u=2){let p=a-m,y=await this._tezos.rpc.getBlock({block:t.toString()});try{if(this.findContractCall(y,r).find(I=>{let A=this.parseInitiateParameters(I);return A.secretHash!==n?(console.log(`[${I.counter}] Secret hash: expect ${n}, actual ${A.secretHash}`),!1):A.receivingAddress.toLowerCase()!==o.toLowerCase()?(console.log(`[${I.counter}] Receiving address: expect ${o}, actual ${A.receivingAddress}`),!1):A.netAmount!==p?(console.log(`[${I.counter}] Net amount: expect ${p}, actual ${A.netAmount}`),!1):A.refundTimestamp<d?(console.log(`[${I.counter}] Refund timestamp: minimum ${d}, actual ${A.refundTimestamp}`),!1):!0},this)===void 0)throw new Error(`Initiate transaction that satisfies the expected criteria is not found in ${r} contents`)}catch(le){return{status:"Invalid",message:le.message,confirmations:0,nextBlockETA:0}}let x=this.getBlockDetails(await this._tezos.rpc.getBlock({block:"head"})),E=this.getBlockDetails(y),k=x.level-E.level,h={status:"Included",confirmations:k,nextBlockETA:x.timestamp+this._timeBetweenBlocks};return k>=u&&(h.status="Confirmed"),h}encodePublicKey(t){switch(t.substring(0,2)){case"ed":return Buffer.from(oe(t,H.edpk)).toString("hex");case"p2":return Buffer.from(oe(t,H.p2pk)).toString("hex");case"sp":return Buffer.from(oe(t,H.sppk)).toString("hex");default:throw new Error("Unsupported Public Key Type")}}encodeSignature(t){var n;let r=t.startsWith("sig")?t.substring(0,3):t.substring(0,5);if(Object.prototype.hasOwnProperty.call(H,r))return Buffer.from(oe(t,(n=Object.getOwnPropertyDescriptor(H,r))==null?void 0:n.value)).toString("hex");throw new Error("Unsupported Signature Type")}calcFees(t=0,r=0,n=0){return this._minimalFees+this._minimalNanotezPerGasUnit*t+this._minimalNanotezPerByte*n+r*this._costPerByte}async estimateInitiateFees(t){let r={receivingAddress:"tz1Q2prWCrDGFDuGTe7axdt4z9e3QkCqdhmD",secretHash:"169cbd29345af89a0983f28254e71bdd1367890b9876fc8a9ea117c32f6a521b",refundTimestamp:2147483647,rewardForRedeem:0,netAmount:100},n=this.buildInitiateTransaction(r),o=await this._tezos.rpc.getBlockHeader(),a=await this._tezos.rpc.getContract(t),m=await this._tezos.rpc.runOperation({chain_id:o.chain_id,operation:{branch:o.hash,signature:"sigUHx32f9wesZ1n2BWpixXz4AQaZggEtchaQNHYGRCoWNAXx45WGW2ua3apUUUAGMLPwAU41QoaFCzVSL61VaessLg4YbbP",contents:[{amount:"0",counter:(parseInt(a.counter||"0")+1).toString(),destination:this._contractAddress,fee:this.calcFees(104e4,6e4,this._initiateTxSize).toString(),gas_limit:"1040000",kind:nt.TRANSACTION,source:t,storage_limit:"60000",parameters:n.data}]}}),d=0,u=0;return m.contents.forEach(p=>{if(p.metadata.operation_result.status!=="applied")throw new Error("Some error was encountered while estimating fees");u+=parseInt(p.metadata.operation_result.consumed_gas||"0"),d+=parseInt(p.metadata.operation_result.paid_storage_size_diff||"0")}),this.calcFees(u,d,this._initiateTxSize)}async estimateRedeemFees(t){let r=this.calcFees(this._gasLimit,0,this._redeemTxSize);return await this._tezos.rpc.getManagerKey(t)===null&&(r+=257*this._costPerByte),{totalCost:r,rewardForRedeem:2*r}}isValidAddress(t){return ot(t)==st.VALID}};import{TezosToolkit as mt}from"@taquito/taquito";var j=class extends T{static async create(e,t,r){let n=c.blockchains.tezos.rpc[e];r!==void 0&&(n.rpc=r);let o=new mt(n.rpc),a=await o.rpc.getChainId();if(n.chainID!==a.toString())throw new Error(`Wrong chain ID: expected ${n.chainID}, actual ${a}`);return new j(o,c.currencies[t].contracts.entrypoints,c.currencies[t].contracts[e].address,c.blockchains.tezos.rpc[e].blockTime,c.currencies[t].contracts[e].gasLimit,c.blockchains.tezos.rpc[e].minimalFees,c.blockchains.tezos.rpc[e].minimalNanotezPerGasUnit,c.blockchains.tezos.rpc[e].minimalNanotezPerByte,c.blockchains.tezos.rpc[e].costPerByte,c.currencies[t].contracts[e].redeemTxSize,c.currencies[t].contracts[e].initiateTxSize)}parseInitiateParameters(e){var n;if(e.parameters===void 0)throw new Error("Parameters are undefined");let t=(n=this._entrypoints.get(e.parameters.entrypoint))==null?void 0:n.Execute(e.parameters.value);if(t===void 0)throw new Error(`Unexpected entrypoint: ${e.parameters.entrypoint}`);let r=(()=>{switch(e.parameters.entrypoint){case"initiate":return t;case"default":return t.initiate;default:throw new Error(`Unexpected entrypoint: ${e.parameters.entrypoint}`)}})();return{secretHash:r.hashedSecret,receivingAddress:r.participant,refundTimestamp:b(r.refundTime),netAmount:parseInt(r.totalAmount)-parseInt(r.payoffAmount),rewardForRedeem:parseInt(r.payoffAmount)}}};import{TezosToolkit as ct}from"@taquito/taquito";var G=class extends T{static async create(e,t,r){let n=c.blockchains.tezos.rpc[e];r!==void 0&&(n.rpc=r);let o=new ct(n.rpc),a=await o.rpc.getChainId();if(n.chainID!==a.toString())throw new Error(`Wrong chain ID: expected ${n.chainID}, actual ${a}`);return new G(o,c.currencies[t].contracts.entrypoints,c.currencies[t].contracts[e].address,c.blockchains.tezos.rpc[e].blockTime,c.currencies[t].contracts[e].gasLimit,c.blockchains.tezos.rpc[e].minimalFees,c.blockchains.tezos.rpc[e].minimalNanotezPerGasUnit,c.blockchains.tezos.rpc[e].minimalNanotezPerByte,c.blockchains.tezos.rpc[e].costPerByte,c.currencies[t].contracts[e].redeemTxSize,c.currencies[t].contracts[e].initiateTxSize)}parseInitiateParameters(e){var n;if(!e.parameters)throw new Error("Parameters are undefined");let t=(n=this._entrypoints.get(e.parameters.entrypoint))==null?void 0:n.Execute(e.parameters.value);if(!t)throw new Error(`Unexpected entrypoint: ${e.parameters.entrypoint}`);let r=this.getInitiateParams(e.parameters.entrypoint,t);return{secretHash:r.hashedSecret,receivingAddress:r.participant,refundTimestamp:b(r.refundTime),netAmount:parseInt(r.totalAmount)-parseInt(r.payoffAmount),rewardForRedeem:parseInt(r.payoffAmount)}}getInitiateParams(e,t){switch(e){case"initiate":return t;case"default":return t.initiate;default:throw new Error(`Unexpected entrypoint: ${e}`)}}};export{Q as Atomex,P as AuthorizationManager,z as DefaultSerializedAuthTokenMapper,ce as ImportantDataReceivingMode,te as InMemoryAuthorizationManagerStore,ee as InMemoryCurrenciesProvider,ie as InMemoryTezosSigner,W as LocalStorageAuthorizationManagerStore,Y as MixedApiAtomexClient,J as RestAtomexClient,Z as SignersManager,K as WalletTezosSigner,B as Web3EthereumSigner,X as WebSocketAtomexClient,f as atomexUtils,w as converters,ue as legacy,O as textUtils,bt as wait};
//# sourceMappingURL=index.js.map
