{
  "version": 3,
  "sources": ["../../src/index.ts", "../../src/atomex/atomex.ts", "../../src/core/eventEmitter.ts", "../../src/native/index.node.ts", "../../src/utils/converters.ts", "../../src/utils/atomexUtils.ts", "../../src/utils/text.ts", "../../src/utils/index.ts", "../../src/authorization/authorizationManager.ts", "../../src/blockchain/signersManager.ts", "../../src/browser/localStorageAuthorizationManagerStore/defaultSerializedAuthTokenMapper.ts", "../../src/browser/localStorageAuthorizationManagerStore/multipleKeysStoreStrategy.ts", "../../src/browser/localStorageAuthorizationManagerStore/singleKeyStoreStrategy.ts", "../../src/browser/localStorageAuthorizationManagerStore/localStorageAuthorizationManagerStore.ts", "../../src/clients/restAtomexClient.ts", "../../src/clients/webSocketAtomexClient.ts", "../../src/clients/mixedAtomexClient.ts", "../../src/common/models/importantDataReceivingMode.ts", "../../src/common/inMemoryCurrenciesProvider.ts", "../../src/ethereum/utils/index.ts", "../../src/ethereum/signers/web3EthereumSigner.ts", "../../src/stores/inMemoryAuthorizationManagerStore.ts", "../../src/tezos/walletTezosSigner/beaconWalletTezosSigner.ts", "../../src/tezos/utils/index.ts", "../../src/tezos/utils/signing.ts", "../../src/tezos/walletTezosSigner/templeWalletTezosSigner.ts", "../../src/tezos/walletTezosSigner/walletTezosSigner.ts", "../../src/tezos/inMemoryTezosSigner.ts", "../../src/legacy/index.ts", "../../src/legacy/atomex.ts", "../../src/legacy/ethereum.ts", "../../src/legacy/helpers.ts", "../../src/legacy/tezos.ts", "../../src/legacy/fa12.ts", "../../src/legacy/fa2.ts"],
  "sourcesContent": ["export { Atomex } from './atomex';\nexport { AuthorizationManager } from './authorization/index';\nexport { SignersManager } from './blockchain/index';\nexport { LocalStorageAuthorizationManagerStore, DefaultSerializedAuthTokenMapper } from './browser/index';\nexport { RestAtomexClient, WebSocketAtomexClient, MixedApiAtomexClient } from './clients/index';\nexport { ImportantDataReceivingMode, InMemoryCurrenciesProvider } from './common/index';\nexport { Web3EthereumSigner } from './ethereum/index';\nexport { InMemoryAuthorizationManagerStore } from './stores/index';\nexport { InMemoryTezosSigner, WalletTezosSigner } from './tezos/index';\nexport * from './utils';\n\nexport type { AtomexOptions, NewSwapRequest } from './atomex/index';\nexport type { AuthToken, AuthorizationManagerOptions } from './authorization/index';\nexport type {\n  AtomexProtocol, Transaction,\n  AtomexProtocolV1, InitiateParametersAtomexProtocolV1, RedeemParametersAtomexProtocolV1, RefundParametersAtomexProtocolV1,\n  AtomexSignature, Signer,\n  BalancesProvider, SwapTransactionsProvider, TransactionsProvider\n} from './blockchain/index';\nexport type { SerializedAuthTokenMapper, SerializedAuthToken } from './browser/index';\nexport type { AtomexClient } from './clients/index';\nexport type { AtomexNetwork, Currency, Side, CurrenciesProvider, CollectionSelector } from './common/index';\nexport type { AtomexStore, AuthorizationManagerStore } from './stores/index';\nexport type { Swap, SwapParticipant, SwapParticipantRequisites, SwapParticipantStatus } from './swaps/index';\nexport type { TezosCurrency, TezosFA12Currency, TezosFA2Currency } from './tezos/index';\n\nexport * as legacy from './legacy/index';\n", "import type { SignersManager } from '../blockchain/index';\nimport type { AtomexNetwork, CurrenciesProvider } from '../common/index';\nimport type { Swap } from '../swaps/index';\nimport { SwapOperationCompleteStage, type AtomexOptions, type NewSwapRequest } from './models/index';\n\nexport class Atomex {\n  readonly atomexNetwork: AtomexNetwork;\n  readonly authorization;\n  readonly signers: SignersManager;\n\n  readonly currenciesProvider: CurrenciesProvider;\n\n  constructor(options: AtomexOptions) {\n    this.atomexNetwork = options.atomexNetwork;\n    this.currenciesProvider = options.providers.currenciesProvider;\n    this.signers = options.signersManager;\n    this.authorization = options.authorizationManager;\n  }\n\n  async swap(newSwapRequest: NewSwapRequest, completeStage: SwapOperationCompleteStage): Promise<Swap>;\n  async swap(swapId: Swap['id'], completeStage: SwapOperationCompleteStage): Promise<Swap>;\n  async swap(newSwapRequestOrSwapId: NewSwapRequest | Swap['id'], completeStage: SwapOperationCompleteStage): Promise<Swap> {\n    throw new Error('Not implemented');\n  }\n}\n", "export interface PublicEventEmitter<T extends readonly unknown[]> {\n    addListener(listener: (...args: T) => void): this;\n    removeListener(listener: (...args: T) => void): this;\n    removeAllListeners(): this;\n}\n\nexport class EventEmitter<T extends readonly unknown[]> implements PublicEventEmitter<T> {\n    private listeners: Set<(...args: T) => void> = new Set();\n\n    addListener(listener: (...args: T) => void) {\n        this.listeners.add(listener);\n        return this;\n    }\n\n    removeListener(listener: (...args: T) => void) {\n        if (this.listeners.has(listener))\n            this.listeners.delete(listener);\n        return this;\n    }\n\n    removeAllListeners() {\n        this.listeners = new Set();\n        return this;\n    }\n\n    emit(...args: T) {\n        if (!this.listeners.size)\n            return;\n\n        if (this.listeners.size === 1) {\n            this.listeners.values().next().value(...args);\n        } else {\n            // We copy listeners to prevent an unbounded loop if there is the adding of a new event handler inside the handler; \n            [...this.listeners].forEach(listener => listener(...args));\n        }\n    }\n}\n\nexport type ToEventEmitter<T> = T extends PublicEventEmitter<infer TArgs> ? EventEmitter<TArgs> : never;\nexport type ToEventEmitters<T> = T extends Record<infer K, PublicEventEmitter<infer TArgs>> ? Record<K, EventEmitter<TArgs>> : never;\n", "export { Buffer } from 'node:buffer';\n\nimport nodeFetch from 'node-fetch';\n\nconst fetchNative = (globalThis.fetch) || nodeFetch;\nexport {\n  fetchNative as fetch\n};\n", "import BigNumber from 'bignumber.js';\n\nimport { Buffer } from '../native';\n\nexport const hexStringToUint8Array = (hex: string): Uint8Array => {\n  const integers = hex.match(/[\\da-f]{2}/gi)?.map(val => parseInt(val, 16));\n\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n  return new Uint8Array(integers!);\n};\n\nexport const uint8ArrayToHexString = (value: Uint8Array): string => Buffer.from(value).toString('hex');\nexport const stringToHexString = (value: string): string => Buffer.from(value, 'utf8').toString('hex');\nexport const hexStringToString = (value: string): string => Buffer.from(hexStringToUint8Array(value)).toString('utf8');\n\nexport const objectToHexString = (value: Record<string, unknown>): string => stringToHexString(JSON.stringify(value));\nexport const hexStringToObject = <T extends Record<string, unknown> = Record<string, unknown>>(value: string): T | null => {\n  try {\n    return JSON.parse(hexStringToString(value));\n  }\n  catch {\n    return null;\n  }\n};\n\nexport const tokensAmountToNat = (tokensAmount: BigNumber | number, decimals: number): BigNumber => {\n  return new BigNumber(tokensAmount).multipliedBy(10 ** decimals).integerValue();\n};\n\nexport const numberToTokensAmount = (value: BigNumber | number, decimals: number): BigNumber => {\n  return new BigNumber(value).integerValue().div(10 ** decimals);\n};\n", "import type { AtomexNetwork } from '../common/index';\n\nexport const ensureNetworksAreSame = (\n  value1: { atomexNetwork: AtomexNetwork } | AtomexNetwork,\n  value2: { atomexNetwork: AtomexNetwork } | AtomexNetwork\n) => {\n  if ((typeof value1 === 'string' ? value1 : value1.atomexNetwork) === (typeof value2 === 'string' ? value2 : value2.atomexNetwork))\n    return;\n\n  throw new Error('Networks are different');\n};\n", "export const capitalize = (value: string): string => value && (value[0]?.toLocaleUpperCase() + value.slice(1));\n\nconst stringPad = (string: string, isStart: boolean, maxLength: number, fillString = ' ') => {\n  if (String.prototype.padStart !== undefined)\n    return string.padStart(maxLength, fillString);\n\n  const stringLength = string.length;\n  // eslint-disable-next-line eqeqeq\n  if (maxLength <= stringLength || fillString == '')\n    return string;\n\n  const fillLength = maxLength - stringLength;\n  let filler = fillString.repeat(Math.ceil(fillLength / fillString.length));\n\n  if (filler.length > fillLength)\n    filler = filler.slice(0, fillLength);\n\n  return isStart ? filler + string : string + filler;\n};\n\nexport const padStart = (string: string, maxLength: number, fillString = ' ') => String.prototype.padStart !== undefined\n  ? string.padStart(maxLength, fillString)\n  : stringPad(string, true, maxLength, fillString);\n\nexport const padEnd = (string: string, maxLength: number, fillString = ' ') => String.prototype.padEnd !== undefined\n  ? string.padEnd(maxLength, fillString)\n  : stringPad(string, false, maxLength, fillString);\n", "export * as converters from './converters';\nexport * as atomexUtils from './atomexUtils';\nexport * as textUtils from './text';\n\nexport const wait = (ms: number) => new Promise<void>(resolve => setTimeout(resolve, ms));\n\nexport const prepareTimeoutDuration = (durationMs: number) => Math.min(durationMs, 0x7FFFFFFF);\n", "import type { SignersManager } from '../blockchain/index';\nimport type { AtomexNetwork } from '../common/index';\nimport { EventEmitter, type ToEventEmitters, type PublicEventEmitter } from '../core/index';\nimport { fetch } from '../native/index';\nimport type { AuthorizationManagerStore } from '../stores/index';\nimport { atomexUtils, prepareTimeoutDuration } from '../utils/index';\nimport type {\n  AuthenticationRequestData, AuthenticationResponseData, AuthorizationManagerOptions,\n  AuthToken, AuthTokenData\n} from './models/index';\n\ninterface AuthorizationManagerEvents {\n  readonly authorized: PublicEventEmitter<readonly [authToken: AuthToken]>;\n  readonly unauthorized: PublicEventEmitter<readonly [authToken: AuthToken]>;\n  readonly authTokenExpiring: PublicEventEmitter<readonly [expiringAuthToken: AuthToken]>;\n  readonly authTokenExpired: PublicEventEmitter<readonly [expiredAuthToken: AuthToken]>;\n}\n\nexport class AuthorizationManager {\n  readonly events: AuthorizationManagerEvents = {\n    authorized: new EventEmitter(),\n    unauthorized: new EventEmitter(),\n    authTokenExpiring: new EventEmitter(),\n    authTokenExpired: new EventEmitter()\n  };\n  // readonly authorized: PublicEventEmitter<readonly [authToken: AuthToken]> = new EventEmitter();\n  // readonly unauthorized: PublicEventEmitter<readonly [authToken: AuthToken]> = new EventEmitter();\n  // readonly authTokenExpiring: PublicEventEmitter<readonly [expiringAuthToken: AuthToken]> = new EventEmitter();\n  // readonly authTokenExpired: PublicEventEmitter<readonly [expiredAuthToken: AuthToken]> = new EventEmitter();\n\n  protected static readonly DEFAULT_AUTH_MESSAGE = 'Signing in ';\n  protected static readonly DEFAULT_GET_AUTH_TOKEN_URI = '/v1/token';\n  protected static readonly DEFAULT_EXPIRING_NOTIFICATION_TIME_IN_SECONDS = 60;\n\n  readonly atomexNetwork: AtomexNetwork;\n\n  protected readonly signersManager: SignersManager;\n  protected readonly store: AuthorizationManagerStore;\n  protected readonly authorizationUrl: URL;\n  protected readonly expiringNotificationTimeInSeconds: number;\n\n  private readonly _authTokenData: Map<string, AuthTokenData> = new Map();\n\n  constructor(options: AuthorizationManagerOptions) {\n    this.atomexNetwork = options.atomexNetwork;\n    this.store = options.store;\n    this.signersManager = options.signersManager;\n\n    atomexUtils.ensureNetworksAreSame(this, this.signersManager);\n\n    this.authorizationUrl = new URL(AuthorizationManager.DEFAULT_GET_AUTH_TOKEN_URI, options.authorizationBaseUrl);\n    this.expiringNotificationTimeInSeconds = options.expiringNotificationTimeInSeconds || AuthorizationManager.DEFAULT_EXPIRING_NOTIFICATION_TIME_IN_SECONDS;\n  }\n\n  protected get authTokenData(): ReadonlyMap<string, AuthTokenData> {\n    return this._authTokenData;\n  }\n\n  getAuthToken(address: string): AuthToken | undefined {\n    return this.authTokenData.get(address)?.authToken;\n  }\n\n  async authorize(\n    address: string,\n    forceRequestNewToken = false,\n    blockchain?: string,\n    authMessage: string = AuthorizationManager.DEFAULT_AUTH_MESSAGE\n  ): Promise<AuthToken> {\n    if (!forceRequestNewToken) {\n      const authToken = this.getAuthToken(address) || (await this.loadAuthTokenFromStore(address));\n\n      if (authToken && !this.isTokenExpiring(authToken))\n        return authToken;\n    }\n\n    const signer = await this.signersManager.findSigner(address, blockchain);\n    if (!signer)\n      throw new Error(`Not found: the corresponding signer by the ${address} address`);\n\n    const timeStamp = this.getAuthorizationTimeStamp(authMessage);\n    const atomexSignature = await signer.sign(authMessage + timeStamp);\n\n    if (atomexSignature.address !== address)\n      throw new Error('Invalid address in the signed data');\n\n    const authenticationResponseData = await this.requestAuthToken({\n      message: authMessage,\n      publicKey: atomexSignature.publicKeyBytes,\n      algorithm: atomexSignature.algorithm,\n      signingDataType: atomexSignature.signingDataType,\n      signature: atomexSignature.signatureBytes,\n      timeStamp\n    });\n\n    const authToken: AuthToken = {\n      value: authenticationResponseData.token,\n      userId: authenticationResponseData.id,\n      address,\n      expired: new Date(authenticationResponseData.expires)\n    };\n\n    await this.registerAuthToken(authToken, true);\n\n    return authToken;\n  }\n\n  async unauthorize(address: string): Promise<boolean> {\n    const authToken = this.getAuthToken(address);\n\n    return authToken ? this.unregisterAuthToken(authToken) : false;\n  }\n\n  async loadAuthTokenFromStore(address: string): Promise<AuthToken | undefined> {\n    const authToken = await this.store.getAuthToken(address);\n\n    if (!authToken)\n      return undefined;\n\n    return await this.registerAuthToken(authToken, false);\n  }\n\n  protected async registerAuthToken(authToken: AuthToken, isNeedSave: boolean): Promise<AuthToken | undefined> {\n    const watcherId = this.trackAuthToken(authToken);\n    if (!watcherId)\n      return;\n\n    const authTokenData = {\n      authToken,\n      watcherId\n    };\n    this._authTokenData.set(authToken.address, authTokenData);\n\n    if (isNeedSave)\n      authToken = await this.store.upsertAuthToken(authToken.address, authToken);\n\n    (this.events as ToEventEmitters<this['events']>).authorized.emit(authToken);\n    return authToken;\n  }\n\n  protected async unregisterAuthToken(authToken: AuthToken): Promise<boolean> {\n    const authTokenData = this._authTokenData.get(authToken.address);\n    if (!authTokenData)\n      return false;\n\n    this.untrackAuthToken(authTokenData.watcherId);\n    const result = (await this.store.removeAuthToken(authToken) && this._authTokenData.delete(authToken.address));\n\n    if (result)\n      (this.events as ToEventEmitters<this['events']>).unauthorized.emit(authToken);\n\n    return result;\n  }\n\n  protected trackAuthToken(authToken: AuthToken): AuthTokenData['watcherId'] {\n    const tokenDuration = authToken.expired.getTime() - Date.now();\n    if (tokenDuration <= 0) {\n      this.store.removeAuthToken(authToken);\n      (this.events as ToEventEmitters<this['events']>).authTokenExpired.emit(authToken);\n\n      return;\n    }\n\n    const expiringTokenDuration = tokenDuration - (this.expiringNotificationTimeInSeconds * 1000);\n    const watcherId = setTimeout(this.authTokenExpiringTimeoutCallback, prepareTimeoutDuration(expiringTokenDuration), authToken);\n\n    return watcherId;\n  }\n\n  protected untrackAuthToken(authTokenWatcherId: AuthTokenData['watcherId']) {\n    clearTimeout(authTokenWatcherId);\n  }\n\n  protected getAuthorizationTimeStamp(_authMessage: string): number {\n    return Date.now();\n  }\n\n  protected async requestAuthToken(requestData: AuthenticationRequestData): Promise<AuthenticationResponseData> {\n    const response = await fetch(this.authorizationUrl.href, {\n      method: 'POST',\n      headers: {\n        'Accept': 'application/json',\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify(requestData)\n    });\n\n    if (!response.ok)\n      throw new Error(await response.text());\n\n    return response.json();\n  }\n\n  protected authTokenExpiringTimeoutCallback = (authToken: AuthToken) => {\n    const authTokenData = this._authTokenData.get(authToken.address);\n    if (!authTokenData)\n      return;\n\n    clearTimeout(authTokenData.watcherId);\n    const duration = authToken.expired.getTime() - Date.now();\n    const newWatcherId = setTimeout(this.authTokenExpiredTimeoutCallback, prepareTimeoutDuration(duration), authToken);\n\n    this._authTokenData.set(authToken.address, {\n      ...authTokenData,\n      watcherId: newWatcherId\n    });\n    (this.events as ToEventEmitters<this['events']>).authTokenExpiring.emit(authToken);\n  };\n\n  protected authTokenExpiredTimeoutCallback = (authToken: AuthToken) => {\n    this.unregisterAuthToken(authToken);\n    (this.events as ToEventEmitters<this['events']>).authTokenExpired.emit(authToken);\n  };\n\n  protected isTokenExpiring(authToken: AuthToken) {\n    return (authToken.expired.getTime() - Date.now()) <= (this.expiringNotificationTimeInSeconds * 1000);\n  }\n}\n", "import type { AtomexNetwork } from '../common/index';\nimport { atomexUtils } from '../utils/index';\nimport type { Signer } from './signer';\n\nexport class SignersManager {\n  private readonly _signers: Set<Signer> = new Set();\n\n  constructor(readonly atomexNetwork: AtomexNetwork) {\n  }\n\n  protected get signers(): Set<Signer> {\n    return this._signers;\n  }\n\n  addSigner(signer: Signer): Promise<Signer> {\n    atomexUtils.ensureNetworksAreSame(this, signer);\n    this._signers.add(signer);\n\n    return Promise.resolve(signer);\n  }\n\n  async removeSigner(signer: Signer): Promise<boolean>;\n  async removeSigner(address: string, blockchain?: string): Promise<boolean>;\n  async removeSigner(signerOrAddress: Signer | string, blockchain?: string): Promise<boolean> {\n    const signer = typeof signerOrAddress === 'string'\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      ? (await this.findSigner(signerOrAddress, blockchain))\n      : signerOrAddress;\n\n    return signer ? this._signers.delete(signer) : false;\n  }\n\n  async findSigner(address: string, blockchain?: string): Promise<Signer | undefined> {\n    if (!this.signers.size)\n      return undefined;\n\n    const signerAndAddressPromises: Array<Promise<[signer: Signer, address: string]>> = [];\n    for (const signer of this.signers) {\n      if (blockchain && signer.blockchain !== blockchain)\n        continue;\n\n      const addressOrPromise = signer.getAddress();\n      if (typeof addressOrPromise === 'string') {\n        if (addressOrPromise === address)\n          return signer;\n        else\n          continue;\n      }\n\n      signerAndAddressPromises.push(addressOrPromise.then(address => [signer, address]));\n    }\n\n    const signerAndAddressResults = await Promise.allSettled(signerAndAddressPromises);\n    for (const signerAndAddressResult of signerAndAddressResults) {\n      if (signerAndAddressResult.status !== 'fulfilled') {\n        // TODO: warning if status === 'rejected'\n        continue;\n      }\n\n      if (signerAndAddressResult.value[1] === address)\n        return signerAndAddressResult.value[0];\n    }\n\n    return undefined;\n  }\n}\n", "import type { AuthToken } from '../../authorization/index';\nimport type { SerializedAuthToken } from './serializedAuthToken';\nimport type { SerializedAuthTokenMapper } from './serializedAuthTokenMapper';\n\nexport class DefaultSerializedAuthTokenMapper implements SerializedAuthTokenMapper {\n  mapAuthTokenToSerializedAuthToken(authToken: AuthToken): SerializedAuthToken | null {\n    return {\n      a: authToken.address,\n      u: authToken.userId,\n      e: authToken.expired.getTime(),\n      v: authToken.value\n    };\n  }\n\n  mapSerializedAuthTokenToAuthToken(serializedAuthToken: SerializedAuthToken): AuthToken | null {\n    return {\n      address: serializedAuthToken.a,\n      userId: serializedAuthToken.u,\n      expired: new Date(serializedAuthToken.e),\n      value: serializedAuthToken.v\n    };\n  }\n}\n", "import type { AuthToken } from '../../index';\nimport type { SerializedAuthTokenMapper } from './serializedAuthTokenMapper';\nimport type { StoreStrategy } from './storeStrategy';\n\nexport class MultipleKeysStoreStrategy implements StoreStrategy {\n  protected static readonly DefaultKeyPrefix = 'authToken:';\n\n  constructor(\n    protected readonly localStorage: Storage,\n    protected readonly serializedAuthTokenMapper: SerializedAuthTokenMapper,\n    readonly keyPrefix: string = MultipleKeysStoreStrategy.DefaultKeyPrefix\n  ) {\n  }\n\n  getAuthToken(address: string): AuthToken | undefined {\n    const rawAuthToken = localStorage.getItem(this.getKey(address));\n\n    return (rawAuthToken && this.serializedAuthTokenMapper.mapSerializedAuthTokenToAuthToken(JSON.parse(rawAuthToken))\n      || undefined);\n  }\n\n  getAuthTokens(addresses: string[]): AuthToken[] {\n    return addresses.map(address => this.getAuthToken(address))\n      .filter(Boolean) as AuthToken[];\n  }\n\n  upsertAuthToken(address: string, authToken: AuthToken): AuthToken {\n    const serializedAuthToken = this.serializedAuthTokenMapper.mapAuthTokenToSerializedAuthToken(authToken);\n    if (!serializedAuthToken)\n      throw new Error(`The authToken of the ${address} address can't be stored: serialization is failed`);\n\n    localStorage.setItem(this.getKey(address), JSON.stringify(serializedAuthToken));\n\n    return authToken;\n  }\n\n  removeAuthToken(address: string): boolean {\n    localStorage.removeItem(this.getKey(address));\n\n    return true;\n  }\n\n  protected getKey(address: string) {\n    return this.keyPrefix + address;\n  }\n}\n", "import type { AuthToken } from '../../index';\nimport type { SerializedAuthToken } from './serializedAuthToken';\nimport type { SerializedAuthTokenMapper } from './serializedAuthTokenMapper';\nimport type { StoreStrategy } from './storeStrategy';\n\ninterface AuthTokensStoreObject {\n  [address: string]: SerializedAuthToken;\n}\n\nexport class SingleKeyStoreStrategy implements StoreStrategy {\n  protected static readonly DefaultKeyPrefix = 'authTokens';\n\n  constructor(\n    protected readonly localStorage: Storage,\n    protected readonly serializedAuthTokenMapper: SerializedAuthTokenMapper,\n    readonly keyPrefix: string = SingleKeyStoreStrategy.DefaultKeyPrefix\n  ) {\n  }\n\n  protected get key() {\n    return this.keyPrefix;\n  }\n\n  getAuthToken(address: string): AuthToken | undefined {\n    const serializedAuthTokensStoreObject = this.getSerializedAuthTokensStoreObject();\n\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return serializedAuthTokensStoreObject[address] && (this.serializedAuthTokenMapper.mapSerializedAuthTokenToAuthToken(serializedAuthTokensStoreObject[address]!)\n      || undefined);\n  }\n\n  getAuthTokens(addresses: string[]): AuthToken[] {\n    const serializedAuthTokensStoreObject = this.getSerializedAuthTokensStoreObject();\n\n    return Object.values(serializedAuthTokensStoreObject)\n      .map(serializedAuthToken => this.serializedAuthTokenMapper.mapSerializedAuthTokenToAuthToken(serializedAuthToken))\n      .filter((authToken): authToken is AuthToken => !!authToken && addresses.indexOf(authToken.address) > -1);\n  }\n\n  upsertAuthToken(address: string, authToken: AuthToken): AuthToken {\n    const serializedAuthTokensStoreObject = this.getSerializedAuthTokensStoreObject();\n    const serializedAuthToken = this.serializedAuthTokenMapper.mapAuthTokenToSerializedAuthToken(authToken);\n    if (!serializedAuthToken)\n      throw new Error(`The authToken of the ${address} address can't be stored: serialization is failed`);\n\n    serializedAuthTokensStoreObject[address] = serializedAuthToken;\n    this.localStorage.setItem(this.key, JSON.stringify(serializedAuthTokensStoreObject));\n\n    return authToken;\n  }\n\n  removeAuthToken(address: string): boolean {\n    const serializedAuthTokensStoreObject = this.getSerializedAuthTokensStoreObject();\n\n    if (!serializedAuthTokensStoreObject[address])\n      return false;\n\n    delete serializedAuthTokensStoreObject[address];\n\n    if (Object.keys(serializedAuthTokensStoreObject).length)\n      this.localStorage.setItem(this.key, JSON.stringify(serializedAuthTokensStoreObject));\n    else\n      this.localStorage.removeItem(this.key);\n\n    return true;\n  }\n\n  protected getSerializedAuthTokensStoreObject(): AuthTokensStoreObject {\n    const rawAuthTokens = this.localStorage.getItem(this.key);\n    if (!rawAuthTokens)\n      return {};\n\n    return JSON.parse(rawAuthTokens);\n  }\n}\n", "import type { AuthToken } from '../../authorization/index';\nimport type { AuthorizationManagerStore } from '../../stores/index';\nimport { DefaultSerializedAuthTokenMapper } from './defaultSerializedAuthTokenMapper';\nimport { MultipleKeysStoreStrategy } from './multipleKeysStoreStrategy';\nimport type { SerializedAuthTokenMapper } from './serializedAuthTokenMapper';\nimport { SingleKeyStoreStrategy } from './singleKeyStoreStrategy';\nimport type { StoreStrategy } from './storeStrategy';\n\ntype PreDefinedStoreStrategyName = 'single-key' | 'multiple-keys';\n\nexport class LocalStorageAuthorizationManagerStore implements AuthorizationManagerStore {\n  protected readonly storeStrategy: StoreStrategy;\n\n  constructor(\n    storeStrategy: PreDefinedStoreStrategyName | StoreStrategy = 'single-key',\n    serializedAuthTokenMapper: SerializedAuthTokenMapper = new DefaultSerializedAuthTokenMapper()\n  ) {\n    this.storeStrategy = typeof storeStrategy === 'string'\n      ? this.createPreDefinedStoreStrategy(storeStrategy, serializedAuthTokenMapper)\n      : storeStrategy;\n  }\n\n  getAuthToken(address: string): Promise<AuthToken | undefined> {\n    return Promise.resolve(this.storeStrategy.getAuthToken(address));\n  }\n\n  getAuthTokens(...addresses: string[]): Promise<AuthToken[]> {\n    return Promise.resolve(this.storeStrategy.getAuthTokens(addresses));\n  }\n\n  upsertAuthToken(address: string, authToken: AuthToken): Promise<AuthToken> {\n    return Promise.resolve(this.storeStrategy.upsertAuthToken(address, authToken));\n  }\n\n  removeAuthToken(authToken: AuthToken): Promise<boolean>;\n  removeAuthToken(address: string): Promise<boolean>;\n  removeAuthToken(addressOrAuthToken: AuthToken | string): Promise<boolean> {\n    const address = typeof addressOrAuthToken === 'string'\n      ? addressOrAuthToken\n      : addressOrAuthToken.address;\n\n    return Promise.resolve(this.storeStrategy.removeAuthToken(address));\n  }\n\n  private createPreDefinedStoreStrategy(strategyName: PreDefinedStoreStrategyName, serializedAuthTokenMapper: SerializedAuthTokenMapper) {\n    switch (strategyName) {\n      case 'single-key':\n        return new SingleKeyStoreStrategy(globalThis.localStorage, serializedAuthTokenMapper);\n      case 'multiple-keys':\n        return new MultipleKeysStoreStrategy(globalThis.localStorage, serializedAuthTokenMapper);\n      default:\n        throw new Error(`Unknown the store strategy name: ${strategyName}`);\n    }\n  }\n}\n", "import type { AuthorizationManager } from '../authorization/index';\nimport type { Transaction } from '../blockchain/index';\nimport type { AtomexNetwork, CollectionSelector } from '../common/index';\nimport { EventEmitter, type PublicEventEmitter, type ToEventEmitter } from '../core';\nimport type { Order, OrderBook, Quote, ExchangeSymbol, NewOrderRequest } from '../exchange/index';\nimport type { Swap } from '../swaps/index';\nimport type { AtomexClient } from './atomexClient';\n\nexport class RestAtomexClient implements AtomexClient {\n  readonly orderUpdated: PublicEventEmitter<readonly [updatedOrder: Order]> = new EventEmitter();\n  readonly orderBookUpdated: PublicEventEmitter<readonly [updatedOrderBook: OrderBook]> = new EventEmitter();\n  readonly topOfBookUpdated: PublicEventEmitter<readonly [updatedQuotes: readonly Quote[]]> = new EventEmitter();\n\n  constructor(\n    readonly atomexNetwork: AtomexNetwork,\n    protected readonly authorizationManager: AuthorizationManager\n  ) {\n  }\n\n  getOrder(orderId: string): Promise<Order | undefined> {\n    throw new Error('Method not implemented.');\n  }\n\n  getOrders(selector?: CollectionSelector | undefined): Promise<Order[]> {\n    throw new Error('Method not implemented.');\n  }\n\n  getSymbols(): Promise<ExchangeSymbol> {\n    throw new Error('Method not implemented.');\n  }\n\n  getTopOfBook(): Promise<Quote[]> {\n    throw new Error('Method not implemented.');\n  }\n\n  getOrderBook(): Promise<OrderBook> {\n    throw new Error('Method not implemented.');\n  }\n\n  addOrder(newOrderRequest: NewOrderRequest): Promise<number> {\n    throw new Error('Method not implemented.');\n  }\n\n  cancelOrder(orderId: number): Promise<boolean> {\n    throw new Error('Method not implemented.');\n  }\n\n  cancelAllOrders(): Promise<number> {\n    throw new Error('Method not implemented.');\n  }\n\n  getSwapTransactions(swap: Swap): Promise<readonly Transaction[]> {\n    throw new Error('Method not implemented.');\n  }\n\n  getSwap(swapId: string): Promise<Swap> {\n    throw new Error('Not implemented');\n  }\n}\n", "import type { AuthorizationManager } from '../authorization/index';\nimport type { Transaction } from '../blockchain/index';\nimport type { AtomexNetwork, CollectionSelector } from '../common/index';\nimport { EventEmitter, type PublicEventEmitter, type ToEventEmitter } from '../core';\nimport type { Order, OrderBook, Quote, ExchangeSymbol, NewOrderRequest } from '../exchange/index';\nimport type { Swap } from '../swaps/index';\nimport type { AtomexClient } from './atomexClient';\n\nexport class WebSocketAtomexClient implements AtomexClient {\n  readonly orderUpdated: PublicEventEmitter<readonly [updatedOrder: Order]> = new EventEmitter();\n  readonly orderBookUpdated: PublicEventEmitter<readonly [updatedOrderBook: OrderBook]> = new EventEmitter();\n  readonly topOfBookUpdated: PublicEventEmitter<readonly [updatedQuotes: readonly Quote[]]> = new EventEmitter();\n\n  constructor(\n    readonly atomexNetwork: AtomexNetwork,\n    protected readonly authorizationManager: AuthorizationManager\n  ) {\n  }\n\n  getOrder(orderId: string): Promise<Order | undefined> {\n    throw new Error('Method not implemented.');\n  }\n\n  getOrders(selector?: CollectionSelector | undefined): Promise<Order[]> {\n    throw new Error('Method not implemented.');\n  }\n\n  getSymbols(): Promise<ExchangeSymbol> {\n    throw new Error('Method not implemented.');\n  }\n\n  getTopOfBook(): Promise<Quote[]> {\n    throw new Error('Method not implemented.');\n  }\n\n  getOrderBook(): Promise<OrderBook> {\n    throw new Error('Method not implemented.');\n  }\n\n  addOrder(newOrderRequest: NewOrderRequest): Promise<number> {\n    throw new Error('Method not implemented.');\n  }\n\n  cancelOrder(orderId: number): Promise<boolean> {\n    throw new Error('Method not implemented.');\n  }\n\n  cancelAllOrders(): Promise<number> {\n    throw new Error('Method not implemented.');\n  }\n\n  getSwapTransactions(swap: Swap): Promise<readonly Transaction[]> {\n    throw new Error('Method not implemented.');\n  }\n\n  getSwap(swapId: string): Promise<Swap> {\n    throw new Error('Not implemented');\n  }\n}\n", "import type { Transaction } from '../blockchain/index';\nimport type { AtomexNetwork, CollectionSelector } from '../common/index';\nimport type { Order, OrderBook, Quote, ExchangeSymbol, NewOrderRequest } from '../exchange/index';\nimport type { Swap } from '../swaps/index';\nimport { atomexUtils } from '../utils';\nimport type { AtomexClient } from './atomexClient';\n\nexport class MixedApiAtomexClient implements AtomexClient {\n  constructor(\n    readonly atomexNetwork: AtomexNetwork,\n    readonly restAtomexClient: AtomexClient,\n    readonly webSocketAtomexClient: AtomexClient\n  ) {\n    atomexUtils.ensureNetworksAreSame(this, restAtomexClient);\n    atomexUtils.ensureNetworksAreSame(this, webSocketAtomexClient);\n  }\n\n  get orderUpdated() {\n    return this.webSocketAtomexClient.orderUpdated;\n  }\n\n  get orderBookUpdated() {\n    return this.webSocketAtomexClient.orderBookUpdated;\n  }\n\n  get topOfBookUpdated() {\n    return this.webSocketAtomexClient.topOfBookUpdated;\n  }\n\n  getOrder(orderId: string): Promise<Order | undefined> {\n    return this.restAtomexClient.getOrder(orderId);\n  }\n\n  getOrders(selector?: CollectionSelector | undefined): Promise<Order[]> {\n    return this.restAtomexClient.getOrders(selector);\n  }\n\n  getSymbols(): Promise<ExchangeSymbol> {\n    return this.restAtomexClient.getSymbols();\n  }\n\n  getTopOfBook(): Promise<Quote[]> {\n    return this.restAtomexClient.getTopOfBook();\n  }\n\n  getOrderBook(): Promise<OrderBook> {\n    return this.restAtomexClient.getOrderBook();\n  }\n\n  addOrder(newOrderRequest: NewOrderRequest): Promise<number> {\n    return this.restAtomexClient.addOrder(newOrderRequest);\n  }\n\n  cancelOrder(orderId: number): Promise<boolean> {\n    return this.restAtomexClient.cancelOrder(orderId);\n  }\n\n  cancelAllOrders(): Promise<number> {\n    return this.restAtomexClient.cancelAllOrders();\n  }\n\n  getSwapTransactions(swap: Swap): Promise<readonly Transaction[]> {\n    return this.restAtomexClient.getSwapTransactions(swap);\n  }\n\n  getSwap(swapId: string): Promise<Swap> {\n    return this.restAtomexClient.getSwap(swapId);\n  }\n}\n", "export enum ImportantDataReceivingMode {\n  Local = 0,\n  Remote = 1,\n  SafeMerged = 2\n}\n", "import type { CurrenciesProvider } from './currenciesProvider';\nimport type { Currency } from './models/index';\n\nexport class InMemoryCurrenciesProvider implements CurrenciesProvider {\n  protected readonly currencies: Map<Currency['id'], Currency>;\n\n  constructor(currencies: { readonly [currencyId: Currency['id']]: Currency });\n  constructor(currencies: ReadonlyMap<Currency['id'], Currency>);\n  constructor(currencies: { readonly [currencyId: Currency['id']]: Currency } | ReadonlyMap<Currency['id'], Currency>) {\n    this.currencies = new Map(currencies instanceof Map ? currencies : Object.entries(currencies));\n  }\n\n  getCurrency(currencyId: Currency['id']): Promise<Currency | undefined> {\n    return Promise.resolve(this.currencies.get(currencyId));\n  }\n\n  addCurrency(currency: Currency) {\n    this.currencies.set(currency.id, currency);\n  }\n\n  removeCurrency(currencyId: Currency['id']) {\n    return this.currencies.delete(currencyId);\n  }\n}\n", "import { ec as EC } from 'elliptic';\n\nimport { Buffer } from '../../native';\nimport { converters } from '../../utils';\nimport { uint8ArrayToHexString } from '../../utils/converters';\n\nlet secp256k1Curve: EC | null = null;\nconst getSecp256k1Curve = () => {\n  if (!secp256k1Curve)\n    secp256k1Curve = new EC('secp256k1');\n\n  return secp256k1Curve;\n};\n\nconst splitSignature = (hexSignature: string): { r: string, s: string, v: number, recoveryParameter: number } => {\n  const signatureBytes = converters.hexStringToUint8Array(hexSignature);\n\n  if (signatureBytes.length !== 64 && signatureBytes.length !== 65)\n    throw new Error(`Invalid signature: ${hexSignature}`);\n\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n  let v = signatureBytes.length === 64 ? 27 + (signatureBytes[32]! >> 7) : signatureBytes[64]!;\n  if (v === 0 || v === 1)\n    v += 27;\n\n  const result = {\n    r: uint8ArrayToHexString(signatureBytes.slice(0, 32)),\n    s: uint8ArrayToHexString(signatureBytes.slice(32, 64)),\n    v,\n    recoveryParameter: 1 - (v % 2)\n  };\n\n  return result;\n};\n\nexport const recoverPublicKey = (hexSignature: string, web3MessageHash: string) => {\n  const splittedSignature = splitSignature(hexSignature);\n\n  const messageBuffer = Buffer.from(web3MessageHash.startsWith('0x') ? web3MessageHash.substring(2) : web3MessageHash, 'hex');\n  const ecPublicKey = getSecp256k1Curve().recoverPubKey(\n    messageBuffer,\n    { r: splittedSignature.r, s: splittedSignature.s },\n    splittedSignature.recoveryParameter,\n  );\n\n  return '0x' + ecPublicKey.encode('hex', false);\n};\n", "import type Web3 from 'web3';\n\nimport type { AtomexSignature, Signer } from '../../blockchain/index';\nimport type { AtomexNetwork } from '../../common/index';\nimport { recoverPublicKey } from '../utils/index';\n\nexport class Web3EthereumSigner implements Signer {\n  static readonly signingAlgorithm = 'Keccak256WithEcdsa:Geth2940';\n\n  readonly blockchain = 'ethereum';\n\n  constructor(\n    readonly atomexNetwork: AtomexNetwork,\n    protected readonly web3: Web3\n  ) {\n  }\n\n  async getAddress(): Promise<string> {\n    const accounts = await this.web3.eth.getAccounts();\n    const address = accounts[0];\n    if (!address)\n      throw new Error('Address is unavailable');\n\n    return address;\n  }\n\n  getPublicKey() {\n    return undefined;\n  }\n\n  async sign(message: string): Promise<AtomexSignature> {\n    const address = await this.getAddress();\n    const signatureBytes = await this.signInternal(message, address);\n    const publicKeyBytes = recoverPublicKey(signatureBytes, this.web3.eth.accounts.hashMessage(message));\n\n    return {\n      address,\n      publicKeyBytes: publicKeyBytes.startsWith('0x') ? publicKeyBytes.substring(2) : publicKeyBytes,\n      signatureBytes: signatureBytes.substring(signatureBytes.startsWith('0x') ? 2 : 0, signatureBytes.length - 2),\n      algorithm: Web3EthereumSigner.signingAlgorithm\n    };\n  }\n\n  protected signInternal(message: string, address: string) {\n    return new Promise<string>((resolve, reject) => this.web3.eth.personal.sign(message, address, '', (error, signature) => {\n      return signature ? resolve(signature) : reject(error);\n    }));\n  }\n}\n", "import type { AuthToken } from '../authorization/index';\nimport type { AuthorizationManagerStore } from './authorizationManagerStore';\n\nexport class InMemoryAuthorizationManagerStore implements AuthorizationManagerStore {\n  protected readonly authTokensMap: Map<string, AuthToken> = new Map();\n\n  getAuthToken(address: string): Promise<AuthToken | undefined> {\n    return Promise.resolve(this.authTokensMap.get(address));\n  }\n\n  getAuthTokens(...addresses: string[]): Promise<AuthToken[]> {\n    return Promise.resolve(\n      addresses.reduce(\n        (result, address) => {\n          const authToken = this.authTokensMap.get(address);\n          if (authToken)\n            result.push(authToken);\n\n          return result;\n        },\n        [] as AuthToken[]\n      )\n    );\n  }\n\n  upsertAuthToken(address: string, authToken: AuthToken): Promise<AuthToken> {\n    this.authTokensMap.set(address, authToken);\n\n    return Promise.resolve(authToken);\n  }\n\n  removeAuthToken(authToken: AuthToken): Promise<boolean>;\n  removeAuthToken(address: string): Promise<boolean>;\n  removeAuthToken(addressOrAuthToken: AuthToken | string): Promise<boolean> {\n    const address = typeof addressOrAuthToken === 'string'\n      ? addressOrAuthToken\n      : addressOrAuthToken.address;\n\n    return Promise.resolve(this.authTokensMap.delete(address));\n  }\n}\n", "import { SigningType } from '@airgap/beacon-sdk';\nimport type { BeaconWallet } from '@taquito/beacon-wallet';\n\nimport type { AtomexSignature, Signer } from '../../blockchain/index';\nimport type { AtomexNetwork } from '../../common/index';\nimport { TezosAtomexSigningDataType } from '../models/index';\nimport { decodePublicKey, signingUtils } from '../utils/index';\nimport { decodeSignature } from '../utils/signing';\n\nexport class BeaconWalletTezosSigner implements Signer {\n  readonly blockchain = 'tezos';\n\n  constructor(\n    readonly atomexNetwork: AtomexNetwork,\n    protected readonly beaconWallet: BeaconWallet\n  ) {\n  }\n\n  getAddress(): Promise<string> {\n    return this.beaconWallet.getPKH();\n  }\n\n  async getPublicKey(): Promise<string | undefined> {\n    return (await this.beaconWallet.client.getActiveAccount())?.publicKey;\n  }\n\n  async sign(message: string): Promise<AtomexSignature> {\n    const [address, publicKey, signature] = await Promise.all([\n      this.getAddress(),\n      this.getPublicKey(),\n      this.beaconWallet.client.requestSignPayload({\n        payload: signingUtils.getWalletMichelineSigningData(message),\n        signingType: SigningType.MICHELINE,\n      })\n    ]);\n\n    if (!publicKey)\n      throw new Error('BeaconWallet: public key is unavailable');\n\n    const algorithm = signingUtils.getTezosSigningAlgorithm(publicKey);\n    const publicKeyBytes = decodePublicKey(publicKey);\n    const signatureBytes = decodeSignature(signature.signature);\n\n    return {\n      address,\n      algorithm,\n      publicKeyBytes,\n      signatureBytes,\n      signingDataType: TezosAtomexSigningDataType.WalletMicheline\n    };\n  }\n}\n", "import { b58cdecode, prefix, validatePkAndExtractPrefix } from '@taquito/utils';\n\nimport { Buffer } from '../../native';\n\nexport const decodePublicKey = (publicKey: string) => {\n  const keyPrefix = validatePkAndExtractPrefix(publicKey);\n  const decodedKeyBytes = b58cdecode(publicKey, prefix[keyPrefix]);\n\n  return Buffer.from(decodedKeyBytes).toString('hex');\n};\nexport * as signingUtils from './signing';\n", "import { b58cdecode, prefix, Prefix } from '@taquito/utils';\n\nimport { converters, textUtils } from '../../utils/index';\nimport { SigPrefix } from '../models/index';\n\n// 'Tezos Signed Message: '\nconst tezosSignedMessagePrefixBytes = '54657a6f73205369676e6564204d6573736167653a20';\nconst getMichelineSigningData = (message: string, prefixBytes?: string) => {\n  const messageBytes = converters.stringToHexString(message);\n  const signedMessageBytes = prefixBytes ? (prefixBytes + messageBytes) : messageBytes;\n  const messageLength = textUtils.padStart((signedMessageBytes.length / 2).toString(16), 8, '0');\n\n  return '0501' + messageLength + signedMessageBytes;\n};\n\nexport const getRawSigningData = (message: string) => converters.stringToHexString(message);\nexport const getRawMichelineSigningData = (message: string) => getMichelineSigningData(message);\nexport const getWalletMichelineSigningData = (message: string) => getMichelineSigningData(message, tezosSignedMessagePrefixBytes);\n\nexport const getTezosSigningAlgorithm = (addressOrPublicKey: string) => {\n  const prefix = addressOrPublicKey.substring(0, addressOrPublicKey.startsWith('tz') ? 3 : 4);\n\n  switch (prefix) {\n    case Prefix.TZ1:\n    case Prefix.EDPK:\n      return 'Ed25519:Blake2b';\n\n    case Prefix.TZ2:\n    case Prefix.SPPK:\n      return 'Blake2bWithEcdsa:Secp256k1';\n\n    case Prefix.TZ3:\n    case Prefix.P2PK:\n      return 'Blake2bWithEcdsa:Secp256r1';\n\n    default:\n      throw new Error(`Unexpected address/public key prefix: ${prefix} (${addressOrPublicKey})`);\n  }\n};\n\nexport const decodeSignature = (signature: string) => {\n  const signaturePrefix = (signature.startsWith('sig')\n    ? signature.substring(0, 3)\n    : signature.substring(0, 5)) as SigPrefix;\n  const decodedKeyBytes = b58cdecode(signature, prefix[signaturePrefix]);\n\n  return Buffer.from(decodedKeyBytes).toString('hex');\n};\n", "import type { TempleWallet } from '@temple-wallet/dapp';\n\nimport type { AtomexSignature, Signer } from '../../blockchain/index';\nimport type { AtomexNetwork } from '../../common/index';\nimport { TezosAtomexSigningDataType } from '../models/index';\nimport { decodePublicKey, signingUtils } from '../utils/index';\nimport { decodeSignature } from '../utils/signing';\n\nexport class TempleWalletTezosSigner implements Signer {\n  readonly blockchain = 'tezos';\n\n  constructor(\n    readonly atomexNetwork: AtomexNetwork,\n    protected readonly templeWallet: TempleWallet\n  ) {\n  }\n\n  getAddress(): Promise<string> {\n    return this.templeWallet.getPKH();\n  }\n\n  getPublicKey(): string | undefined {\n    return this.templeWallet.permission?.publicKey;\n  }\n\n  async sign(message: string): Promise<AtomexSignature> {\n    const [address, publicKey, signature] = await Promise.all([\n      this.getAddress(),\n      this.getPublicKey(),\n      this.templeWallet.sign(signingUtils.getWalletMichelineSigningData(message))\n    ]);\n\n    if (!publicKey)\n      throw new Error('TempleWallet: public key is unavailable');\n\n    const algorithm = signingUtils.getTezosSigningAlgorithm(publicKey);\n    const publicKeyBytes = decodePublicKey(publicKey);\n    const signatureBytes = decodeSignature(signature);\n\n    return {\n      address,\n      algorithm,\n      publicKeyBytes,\n      signatureBytes,\n      signingDataType: TezosAtomexSigningDataType.WalletMicheline\n    };\n  }\n}\n", "import type { BeaconWallet } from '@taquito/beacon-wallet';\nimport type { TempleWallet } from '@temple-wallet/dapp';\n\nimport type { AtomexSignature, Signer } from '../../blockchain/index';\nimport type { AtomexNetwork } from '../../common/index';\nimport { BeaconWalletTezosSigner } from './beaconWalletTezosSigner';\nimport { TempleWalletTezosSigner } from './templeWalletTezosSigner';\n\nexport class WalletTezosSigner implements Signer {\n  readonly blockchain = 'tezos';\n\n  protected readonly internalSigner: Signer;\n\n  constructor(\n    readonly atomexNetwork: AtomexNetwork,\n    protected readonly wallet: TempleWallet | BeaconWallet\n  ) {\n    this.internalSigner = this.createInternalSigner();\n  }\n\n  getAddress(): Promise<string> | string {\n    return this.internalSigner.getAddress();\n  }\n\n  getPublicKey(): Promise<string | undefined> | string | undefined {\n    return this.internalSigner.getPublicKey();\n  }\n\n  sign(message: string): Promise<AtomexSignature> {\n    return this.internalSigner.sign(message);\n  }\n\n  protected createInternalSigner() {\n    if ((this.wallet as BeaconWallet).client?.name !== undefined)\n      return new BeaconWalletTezosSigner(this.atomexNetwork, (this.wallet as BeaconWallet));\n    else if ((this.wallet as TempleWallet).permission !== undefined && (this.wallet as TempleWallet).connected !== undefined)\n      return new TempleWalletTezosSigner(this.atomexNetwork, (this.wallet as TempleWallet));\n    else\n      throw new Error('Unknown Tezos wallet');\n  }\n}\n", "import { InMemorySigner } from '@taquito/signer';\n\nimport type { AtomexSignature, Signer } from '../blockchain/index';\nimport type { AtomexNetwork } from '../common/index';\nimport { decodePublicKey, signingUtils } from './utils/index';\n\nexport class InMemoryTezosSigner implements Signer {\n  readonly blockchain = 'tezos';\n\n  protected readonly internalInMemorySigner: InMemorySigner;\n\n  constructor(readonly atomexNetwork: AtomexNetwork, secretKey: string) {\n    this.internalInMemorySigner = new InMemorySigner(secretKey);\n  }\n\n  getAddress(): Promise<string> {\n    return this.internalInMemorySigner.publicKeyHash();\n  }\n\n  getPublicKey(): Promise<string> {\n    return this.internalInMemorySigner.publicKey();\n  }\n\n  async sign(message: string): Promise<AtomexSignature> {\n    const messageBytes = signingUtils.getRawSigningData(message);\n\n    const [address, publicKey, rawSignature] = await Promise.all([\n      this.getAddress(),\n      this.getPublicKey(),\n      this.internalInMemorySigner.sign(messageBytes)\n    ]);\n\n    const publicKeyBytes = decodePublicKey(publicKey);\n    const signatureBytes = rawSignature.sbytes.substring(rawSignature.bytes.length);\n    const algorithm = signingUtils.getTezosSigningAlgorithm(publicKey);\n\n    return {\n      address,\n      algorithm,\n      publicKeyBytes,\n      signatureBytes\n    };\n  }\n}\n", "export * from './atomex';\nexport * from './ethereum';\nexport * from './helpers';\nexport * from './tezos';\nexport * from './fa12';\nexport * from './fa2';\n", "import type { AuthorizationManager } from '../authorization';\nimport config from './config.json';\nimport {\n  AddOrderRequest,\n  AddSwapRequisites,\n  AuthTokenRequest,\n  AuthTokenResponse,\n  BookQuote,\n  GetOrdersRequest,\n  GetSwapsRequest,\n  Order,\n  OrderBook,\n  OrderPreview,\n  Side,\n  Swap,\n  SymbolData,\n  CurrencyConfig,\n} from './types';\n\ninterface Query {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  [key: string]: any;\n}\n\nexport class Atomex {\n  private _network: 'mainnet' | 'testnet';\n  private _baseUrl: string;\n  private _authToken?: string;\n  private _authorizationManager?: AuthorizationManager;\n\n  constructor(\n    network: 'mainnet' | 'testnet',\n    baseUrl: string,\n    authToken?: string,\n  ) {\n    this._network = network;\n    this._baseUrl = baseUrl;\n    this._authToken = authToken;\n  }\n\n  static create(network: 'mainnet' | 'testnet' | 'localhost'): Atomex {\n    return new Atomex(\n      network == 'mainnet' ? 'mainnet' : 'testnet',\n      config.api[network].baseUrl,\n    );\n  }\n\n  setAuthorizationManager(authorizationManager: AuthorizationManager) {\n    this._authorizationManager = authorizationManager;\n  }\n\n  private getLocalAuthToken(address: string) {\n    const authToken = this._authorizationManager?.getAuthToken(address);\n\n    return authToken?.value;\n  }\n\n  /**\n   * Initialize Atomex authorization token\n   *\n   * @remarks the token can be generated using [[getAuthToken]]\n   *\n   * @param authToken Atomex authorization token with expiration time\n   */\n  setAuthToken(authToken: string) {\n    this._authToken = authToken;\n  }\n\n  private async makeRequest<T>(\n    method: 'get' | 'post' | 'delete',\n    path: string,\n    auth: boolean | string = false,\n    params?: Query,\n    payload?: Query,\n  ): Promise<T> {\n    const url = new URL(path, this._baseUrl);\n    if (params !== undefined) {\n      Object.keys(params).forEach(key =>\n        url.searchParams.append(key, params[key]),\n      );\n    }\n\n    const headers: Record<string, string> = {};\n    if (auth) {\n      const authToken = typeof auth === 'string' ? this.getLocalAuthToken(auth) : this._authToken;\n\n      if (!authToken)\n        throw new Error('Auth token is undefined');\n\n      headers['Authorization'] = `Bearer ${authToken}`;\n    }\n\n    let body = undefined;\n    if (method === 'post' && payload !== undefined) {\n      body = JSON.stringify(payload);\n      headers['Content-Type'] = 'application/json';\n    }\n\n    const response = await fetch(url.toString(), {\n      method,\n      headers,\n      body,\n    });\n    if (response.ok) {\n      return response.json();\n    } else {\n      const errBody = await response.text();\n      throw Error(errBody);\n    }\n  }\n\n  /**\n   * Get Atomex authorization token\n   *\n   * @remarks the message details can be generated using [[getAuthMessage]]\n   *\n   * @param authRequest details of the message, timeStamp and signed message with the algorithm used\n   * @returns atomex authorization token with expiration time\n   */\n  async getAuthToken(\n    authRequest: AuthTokenRequest,\n  ): Promise<AuthTokenResponse> {\n    return this.makeRequest('post', '/v1/Token', false, {}, authRequest);\n  }\n\n  /**\n   * Get list of all available symbols in Atomex\n   *\n   * @returns list of all the symbols and their minimum qty.\n   */\n  async getSymbols(): Promise<SymbolData[]> {\n    return this.makeRequest('get', '/v1/Symbols', false);\n  }\n\n  /**\n   * Get Top of Book Quotes for all or specific Symbols\n   *\n   * @param symbolList an array of Symbols eg. `ETH/BTC` , `XTZ/ETH`. A list of all symbols can be found using [[getSymbols]]\n   * @returns a list of Book Quotes\n   */\n  async getQuotes(symbolList?: string[]): Promise<BookQuote[]> {\n    const symbols =\n      symbolList !== undefined && symbolList.length > 0\n        ? symbolList.join(',')\n        : 'All';\n    return this.makeRequest('get', '/v1/MarketData/quotes', false, { symbols });\n  }\n\n  /**\n   * Get the Order Book for a particular Symbol\n   *\n   * @param symbol a symbol eg. `ETH/BTC`. A list of all symbols can be found using [[getSymbols]]\n   * @returns an order book containing all orders for the particular symbol\n   */\n  async getOrderBook(symbol: string): Promise<OrderBook> {\n    return this.makeRequest('get', '/v1/MarketData/book', false, { symbol });\n  }\n\n  /**\n   * Create a new Order in Atomex\n   *\n   * @param addOrderRequest details of the order being placed\n   * @returns order id\n   */\n  async addOrder(addOrderRequest: AddOrderRequest): Promise<number> {\n    const [baseConfig, quoteConfig] = this.splitSymbol(\n      addOrderRequest.symbol,\n    ).map(x => this.getCurrencyConfig(x)) as [CurrencyConfig, CurrencyConfig];\n    const query: Query = addOrderRequest;\n    query.requisites = {\n      baseCurrencyContract: baseConfig.contractAddress,\n      quoteCurrencyContract: quoteConfig.contractAddress,\n      ...query.requisites,\n    };\n\n    return this.makeRequest<Record<string, number>>(\n      'post',\n      '/v1/Orders',\n      addOrderRequest.requisites?.receivingAddress || true,\n      {},\n      query,\n    ).then(res => res['orderId']!);\n  }\n\n  /**\n   * Query and filter all available orders in Atomex\n   *\n   * @param {string?} address\n   * @param getOrdersRequest optional filters for querying all orders\n   * @returns list of orders\n   */\n  async getOrders(address?: string, getOrdersRequest?: GetOrdersRequest): Promise<Order[]> {\n    return this.makeRequest('get', '/v1/Orders', address || true, { ...getOrdersRequest });\n  }\n\n  /**\n   * Query specific Order using Order ID\n   *\n   * @param orderID order id to query\n   * @param {string?} address\n   * @returns details of requested order\n   */\n  async getOrder(orderID: string, address?: string): Promise<Order> {\n    return this.makeRequest('get', `/v1/Orders/${orderID}`, address || true);\n  }\n\n  /**\n   * Cancel an order request in Atomex\n   *\n   * @param orderID id of order to cancel\n   * @param symbol symbol used in the order. A list of all symbols can be found using [[getSymbols]]\n   * @param side side of the order `Buy` or `Sell`\n   * @param {string?} address\n   * @returns true/false value depending on operation success\n   */\n  async cancelOrder(\n    orderID: string,\n    symbol: string,\n    side: Side,\n    address: string,\n  ): Promise<boolean> {\n    return this.makeRequest<Record<string, boolean>>(\n      'delete',\n      `/v1/Orders/${orderID}`,\n      address || true,\n      { symbol, side },\n    ).then(res => res['result']!);\n  }\n\n  /**\n   * Add Requisites to a Swap in Atomex\n   *\n   * @param swapID id of swap\n   * @param swapRequisites swap requisites being updated\n   * @returns true/false depending on operation success\n   */\n  async addSwapRequisites(\n    swapID: string,\n    swapRequisites: AddSwapRequisites,\n  ): Promise<boolean> {\n    return this.makeRequest<Record<string, boolean>>(\n      'post',\n      `/v1/Swaps/${swapID}/requisites`,\n      swapRequisites?.receivingAddress || true,\n      {},\n      swapRequisites,\n    ).then(res => res['result']!);\n  }\n\n  /**\n   * Query and filter all available swaps in Atomex\n   *\n   * \n   * @param {string?} address\n   * @param getSwapsRequest filters for querying all swaps\n   * @returns a list of swaps\n   */\n  async getSwaps(address?: string, getSwapsRequest?: GetSwapsRequest): Promise<Swap[]> {\n    return this.makeRequest('get', '/v1/Swaps', address || true, { ...getSwapsRequest });\n  }\n\n  /**\n   * Query specific Swap using Swap ID\n   *\n   * @param swapID Atomex internal swap id\n   * @param {string?} address\n   * @returns details of swap requested\n   */\n  async getSwap(swapID: string, address?: string): Promise<Swap> {\n    return this.makeRequest('get', `/v1/Swaps/${swapID}`, address || true);\n  }\n\n  /**\n   * Returns an approximate preview of the requested amount and expected receive amount\n   *\n   * @param orderBook order-book received from [[getOrderBook]]\n   * @param side side for the transaction Buy/Sell\n   * @param amount amount received/sent\n   * @param direction direction for the order - Send/Receive\n   */\n  getOrderPreview(\n    orderBook: OrderBook,\n    side: Side,\n    amount: number,\n    direction: 'Send' | 'Receive',\n  ): OrderPreview {\n    const availablePrices = orderBook.entries\n      .filter(entry => {\n        if (entry.side == side) {\n          return false;\n        }\n        const getOrderSize = () => {\n          switch (side + direction) {\n            case 'BuySend':\n            case 'SellReceive':\n              return amount / entry.price;\n            default:\n              return amount;\n          }\n        };\n        return getOrderSize() <= Math.max(...entry.qtyProfile);\n      })\n      .map(entry => entry.price);\n\n    if (availablePrices.length == 0) {\n      throw new Error(\n        `No matching order found (${direction} ${amount} / ${side})`,\n      );\n    }\n\n    const bestPrice =\n      side == 'Buy'\n        ? Math.min(...availablePrices)\n        : Math.max(...availablePrices);\n    const getExpectedAmount = () => {\n      switch (side + direction) {\n        case 'BuySend':\n        case 'SellReceive':\n          return amount / bestPrice;\n        default:\n          return amount * bestPrice;\n      }\n    };\n    return {\n      price: bestPrice,\n      amountSent: direction == 'Send' ? amount : getExpectedAmount(),\n      amountReceived: direction == 'Receive' ? amount : getExpectedAmount(),\n    };\n  }\n\n  /**\n   * Split Atomex trading pair to base and quote currencies\n   *\n   * @param symbol Atomex trading pair {baseCurrency}/{quoteCurrency}\n   */\n  splitSymbol(symbol: string): [baseCurrency: string, quoteCurrency: string] {\n    const [baseCurrency, quoteCurrency] = symbol.split('/', 2);\n    if (!baseCurrency || !quoteCurrency)\n      throw new Error('Symbol is invalid');\n\n    return [baseCurrency, quoteCurrency];\n  }\n\n  /**\n   * Get currency & network specific configuration\n   *\n   * @param currency L1/L2 token symbol (uppercase)\n   */\n  getCurrencyConfig(currency: string): CurrencyConfig {\n    const currencyEntry = Object.entries(config.currencies).find(\n      ([k, _v]) => k == currency,\n    );\n    if (currencyEntry == undefined) {\n      throw new Error(`No matching config section for ${currency}`);\n    }\n    return {\n      blockchain: currencyEntry[1].blockchain,\n      decimals: currencyEntry[1].decimals.original,\n      displayDecimals: currencyEntry[1].decimals.displayed,\n      contractAddress: currencyEntry[1].contracts[this._network].address,\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      tokenAddress: (currencyEntry[1].contracts[this._network] as any).tokenAddress\n    };\n  }\n\n  /**\n   * Formatting an amount based on currency\n   *\n   * @param amount Amount received / sent\n   * @param currency L1/L2 token symbol (uppercase)\n   */\n  formatAmount(amount: number | string, currency: string): number {\n    const cfg = this.getCurrencyConfig(currency);\n    return typeof amount === 'string'\n      ? parseFloat(parseFloat(amount).toFixed(cfg.displayDecimals))\n      : parseFloat(amount.toFixed(cfg.displayDecimals));\n  }\n\n  /**\n   * Get order side for a particular trading pair given the bridge direction\n   *\n   * @param symbol Atomex trading pair {baseCurrency}/{quoteCurrency}\n   * @param fromCurrency Currency to send\n   * @param toCurrency Currency to receive\n   */\n  getOrderSide(\n    symbol: string,\n    fromCurrency: string,\n    toCurrency: string,\n  ): Side {\n    const [baseCurrency, quoteCurrency] = this.splitSymbol(symbol);\n\n    if (baseCurrency === fromCurrency && quoteCurrency === toCurrency)\n      return 'Sell';\n\n    if (quoteCurrency === fromCurrency && baseCurrency === toCurrency)\n      return 'Buy';\n\n    throw new Error(`Mismatch ${fromCurrency} => ${toCurrency} (${symbol})`);\n  }\n\n  /**\n   * Get maximum available liquidity\n   *\n   * @param orderBook order-book received from [[getOrderBook]]\n   * @param side order side Buy/Sell\n   */\n  getMaxOrderSize(orderBook: OrderBook, side: Side): number {\n    return Math.max(\n      ...orderBook.entries\n        .filter(entry => entry.side != side)\n        .map(entry => Math.max(...entry.qtyProfile)),\n    );\n  }\n}\n", "/* eslint-disable @typescript-eslint/ban-types */\nimport elliptic from 'elliptic';\nimport Web3 from 'web3';\nimport { Transaction } from 'web3-core';\nimport { Contract } from 'web3-eth-contract';\nimport { AbiInput, AbiItem } from 'web3-utils';\n\nimport config from './config.json';\nimport { Helpers, now } from './helpers';\nimport {\n  AuthMessage,\n  InitiateParameters,\n  PartialTransactionBody,\n  RedeemFees,\n  SwapTransactionStatus,\n} from './types';\n\nexport interface Function {\n  types: AbiInput[];\n  signature: string;\n}\n\n/**\n * Ethereum Util class for Ethereum related Atomex helper functions\n */\nexport class EthereumHelpers extends Helpers {\n  private _web3: Web3;\n  private _contract: Contract;\n  private _timeBetweenBlocks: number;\n  private _functions: Map<string, Function>;\n  private _gasLimit: number;\n\n  constructor(\n    web3: Web3,\n    jsonInterface: AbiItem[],\n    contractAddress: string,\n    timeBetweenBlocks: number,\n    gasLimit: number,\n  ) {\n    super();\n    this._web3 = web3;\n    this._contract = new web3.eth.Contract(jsonInterface, contractAddress);\n    this._timeBetweenBlocks = timeBetweenBlocks;\n    this._gasLimit = gasLimit;\n    this._functions = new Map<string, Function>();\n    jsonInterface.forEach(item => {\n      if (item.type === 'function') {\n        this._functions.set(item.name!, {\n          types: item.inputs!,\n          signature: web3.eth.abi.encodeFunctionSignature(item as AbiItem),\n        });\n      }\n    });\n  }\n\n  /**\n   * Connects to the supported ethereum chain\n   *\n   * @param chain chains supported by atomex, can be either mainnet or testnet\n   * @param rpc optional rpc endpoint to create eth chain client\n   * @returns chain id of the connected chain\n   */\n  static async create(\n    network: 'mainnet' | 'testnet',\n    rpcUri?: string,\n  ): Promise<EthereumHelpers> {\n    const networkSettings = config.blockchains.ethereum.rpc[network];\n    if (rpcUri !== undefined) {\n      networkSettings.rpc = rpcUri;\n    }\n\n    const web3 = new Web3(networkSettings.rpc);\n    const chainID = await web3.eth.getChainId();\n    if (networkSettings.chainID !== chainID) {\n      throw new Error(\n        `Wrong chain ID: expected ${networkSettings.chainID}, actual ${chainID}`,\n      );\n    }\n\n    return new EthereumHelpers(\n      web3,\n      config.currencies.ETH.contracts.abi as AbiItem[],\n      config.currencies.ETH.contracts[network].address,\n      networkSettings.blockTime,\n      config.currencies.ETH.contracts[network].gasLimit,\n    );\n  }\n\n  getAuthMessage(message: string, _address?: string): AuthMessage {\n    const nowMillis = Date.now();\n    return {\n      message,\n      timestamp: nowMillis,\n      msgToSign: message + nowMillis.toString(),\n      algorithm: 'Keccak256WithEcdsa:Geth2940',\n    };\n  }\n\n  buildInitiateTransaction(\n    initiateParameters: InitiateParameters,\n  ): PartialTransactionBody {\n    if (initiateParameters.refundTimestamp < now()) {\n      throw new Error(\n        `Swap timestamp is in the past: ${initiateParameters.refundTimestamp}`,\n      );\n    }\n\n    const data: string = this._contract.methods\n      .initiate(\n        '0x' + initiateParameters.secretHash,\n        initiateParameters.receivingAddress,\n        initiateParameters.refundTimestamp,\n        initiateParameters.rewardForRedeem,\n      )\n      .encodeABI();\n    return {\n      data,\n      contractAddr: this._contract.options.address,\n      amount: initiateParameters.netAmount + initiateParameters.rewardForRedeem,\n    };\n  }\n\n  buildRedeemTransaction(\n    secret: string,\n    hashedSecret: string,\n  ): PartialTransactionBody {\n    const data = this._contract.methods\n      .redeem(hashedSecret, secret)\n      .encodeABI();\n    return {\n      data,\n      contractAddr: this._contract.options.address,\n    };\n  }\n\n  buildRefundTransaction(secretHash: string): PartialTransactionBody {\n    const data = this._contract.methods.refund(secretHash).encodeABI();\n    return {\n      data,\n      contractAddr: this._contract.options.address,\n    };\n  }\n\n  buildAddTransaction(\n    secretHash: string,\n    amount: number,\n  ): PartialTransactionBody {\n    const data = this._contract.methods.add(secretHash).encodeABI();\n    return {\n      data,\n      contractAddr: this._contract.options.address,\n      amount,\n    };\n  }\n\n  /**\n   * Get the tx data for Atomex Contract Activate Swap call\n   *\n   * @param hashedSecret hashedSecret to identify swap\n   * @returns contract address and tx data that can be used to make a contract call\n   */\n  buildActivateTransaction(secretHash: string): PartialTransactionBody {\n    const data: string = this._contract.methods\n      .activate(secretHash)\n      .encodeABI();\n    return {\n      data,\n      contractAddr: this._contract.options.address,\n    };\n  }\n\n  parseInitiateParameters(transaction: Transaction): InitiateParameters {\n    const initiateMethod = this._functions.get('initiate')!;\n\n    if (!transaction.input.startsWith(initiateMethod.signature)) {\n      throw new Error(`Unexpected method signature: ${transaction.input}`);\n    }\n\n    const params = this._web3.eth.abi.decodeParameters(\n      initiateMethod.types,\n      transaction.input.slice(initiateMethod.signature.length),\n    );\n\n    return {\n      secretHash: params['_hashedSecret'].slice(2),\n      receivingAddress: params['_participant'],\n      refundTimestamp: parseInt(params['_refundTimestamp']),\n      rewardForRedeem: parseInt(\n        this._web3.utils.toBN(params['_payoff']).toString(),\n      ),\n      netAmount: parseInt(\n        this._web3.utils\n          .toBN(transaction.value)\n          .sub(this._web3.utils.toBN(params['_payoff']))\n          .toString(),\n      ),\n    };\n  }\n\n  async validateInitiateTransaction(\n    _blockHeight: number,\n    txID: string,\n    secretHash: string,\n    receivingAddress: string,\n    amount: number,\n    payoff: number,\n    minRefundTimestamp: number,\n    minConfirmations = 2,\n  ): Promise<SwapTransactionStatus> {\n    const netAmount = amount - payoff;\n    const transaction = await this._web3.eth.getTransaction(txID);\n\n    try {\n      if (transaction === undefined) {\n        throw new Error(`Failed to retrieve transaction: ${txID}`);\n      }\n\n      if (transaction.to !== this._contract.options.address) {\n        throw new Error(`Wrong contract address: ${transaction.to}`);\n      }\n\n      const initiateParameters = this.parseInitiateParameters(transaction);\n      if (initiateParameters.secretHash !== secretHash) {\n        throw new Error(\n          `Secret hash: expect ${secretHash}, actual ${initiateParameters.secretHash}`,\n        );\n      }\n\n      if (initiateParameters.receivingAddress.toLowerCase() !== receivingAddress.toLowerCase()) {\n        throw new Error(\n          `Receiving address: expect ${receivingAddress}, actual ${initiateParameters.receivingAddress}`,\n        );\n      }\n\n      if (initiateParameters.netAmount !== netAmount) {\n        throw new Error(\n          `Net amount: expect ${netAmount}, actual ${initiateParameters.netAmount}`,\n        );\n      }\n\n      if (initiateParameters.refundTimestamp < minRefundTimestamp) {\n        throw new Error(\n          `Refund timestamp: minimum ${minRefundTimestamp}, actual ${initiateParameters.refundTimestamp}`,\n        );\n      }\n    } catch (e: any) {\n      return {\n        status: 'Invalid',\n        message: e.message,\n        confirmations: 0,\n        nextBlockETA: 0,\n      };\n    }\n\n    const latestBlock = await this._web3.eth.getBlock('latest');\n    const confirmations =\n      latestBlock.number - (transaction.blockNumber || latestBlock.number);\n\n    const res: SwapTransactionStatus = {\n      status: transaction.blockNumber !== undefined ? 'Included' : 'Pending',\n      confirmations,\n      nextBlockETA:\n        parseInt(latestBlock.timestamp.toString()) + this._timeBetweenBlocks,\n    };\n\n    if (confirmations >= minConfirmations) {\n      res.status = 'Confirmed';\n    }\n\n    return res;\n  }\n\n  private hexSlice(i: number, j: number, bs: string) {\n    return '0x' + bs.slice(i * 2 + 2, j * 2 + 2);\n  }\n\n  private getVRS(signature: string) {\n    const vals = [\n      this.hexSlice(64, (signature.length - 2) / 2, signature),\n      this.hexSlice(0, 32, signature),\n      this.hexSlice(32, 64, signature),\n    ] as const;\n\n    return {\n      v: parseInt(vals[0].slice(2), 16),\n      r: vals[1].slice(2),\n      s: vals[2].slice(2),\n    };\n  }\n\n  /**\n   * Recover Ethereum Account Public Key from RLC signature\n   *\n   * @param msg original message, `msgToSign` parameter generated using [[getAuthMessage]]\n   * @param signature signed message\n   * @returns ethereum public key\n   */\n  recoverPublicKey(msg: string, signature: string) {\n    const hash = this._web3.eth.accounts.hashMessage(msg);\n    const vrs = this.getVRS(signature);\n    const secp256k1 = new elliptic.ec('secp256k1');\n    const ecPublicKey = secp256k1.recoverPubKey(\n      Buffer.from(hash.slice(2), 'hex'),\n      vrs,\n      vrs.v < 2 ? vrs.v : 1 - (vrs.v % 2),\n    );\n    return '0x' + ecPublicKey.encode('hex', false);\n  }\n\n  encodePublicKey(pubKey: string): string {\n    if (pubKey.startsWith('0x')) {\n      return pubKey.slice(2);\n    }\n    return pubKey;\n  }\n\n  encodeSignature(signature: string): string {\n    const vrs = this.getVRS(signature);\n    return vrs.r.padStart(64, '0') + vrs.s.padStart(64, '0');\n  }\n\n  async estimateInitiateFees(source: string): Promise<number> {\n    const dummyTx = {\n      receivingAddress: '0x0000000000000000000000000000000000000000',\n      secretHash:\n        '0000000000000000000000000000000000000000000000000000000000000000',\n      refundTimestamp: 2147483647,\n      rewardForRedeem: 0,\n      netAmount: 0,\n    };\n    const txData = this.buildInitiateTransaction(dummyTx);\n    const gasPrice = await this._web3.eth.getGasPrice();\n    const gasEstimate = await this._web3.eth.estimateGas({\n      from: source,\n      to: txData.contractAddr,\n      data: txData.data,\n      value: txData.amount,\n    });\n    const fee = parseInt(gasPrice) * gasEstimate;\n    return fee;\n  }\n\n  async estimateRedeemFees(_recipient: string): Promise<RedeemFees> {\n    const gasPrice = await this._web3.eth.getGasPrice();\n    const fee = parseInt(gasPrice) * this._gasLimit;\n    return {\n      totalCost: fee,\n      rewardForRedeem: 2 * fee,\n    };\n  }\n\n  isValidAddress(address: string): boolean {\n    return this._web3.utils.isAddress(address);\n  }\n}\n", "import {\n  AuthMessage,\n  InitiateParameters,\n  PartialTransactionBody,\n  RedeemFees,\n  SwapTransactionStatus,\n} from './types';\n\nexport abstract class Helpers {\n  /**\n   * Get the details needed for `getAuthToken` request\n   *\n   * @remarks the `msgToSign` value needs to be signed before being used for Auth\n   * @param message message to include for the Atomex Authentication message\n   * @param address required for Tezos blockchain, in order to determine the EC algorithm\n   * @returns details required for Atomex Auth\n   */\n  abstract getAuthMessage(\n    message: string,\n    address?: string,\n  ): AuthMessage;\n\n  /**\n   * Get the tx data for Atomex Contract Initiate Swap call\n   *\n   * @param swapDetails details of the swap being initiated\n   * @returns contract address and tx data that can be used to make a contract call\n   */\n  abstract buildInitiateTransaction(\n    initiateParameters: InitiateParameters,\n  ): PartialTransactionBody;\n\n  /**\n   * Get the tx data for Atomex Contract Redeem Swap call\n   *\n   * @param secret secret that can used to verify and redeem the funds\n   * @returns contract address and tx data that can be used to make a contract call\n   */\n  abstract buildRedeemTransaction(\n    secret: string,\n    hashedSecret: string,\n  ): PartialTransactionBody;\n\n  /**\n   * Get the tx data for Atomex Contract Refund Swap call\n   *\n   * @param secretHash secretHash to identify swap\n   * @returns contract address and tx data that can be used to make a contract call\n   */\n  abstract buildRefundTransaction(\n    secretHash: string,\n  ): PartialTransactionBody;\n\n  /**\n   * Get the tx data for Atomex Contract AdditionalFunds call\n   *\n   * @param secretHash secretHash to identify swap\n   * @returns contract address and tx data that can be used to make a contract call\n   */\n  abstract buildAddTransaction(\n    secretHash: string,\n    amount: number,\n  ): PartialTransactionBody;\n\n  /**\n   * Validate the Swap Details on chain using the tx detail from Atomex\n   * [does not check tx status, use status provided by atomex]\n   *\n   * @param blockHeight block height of the block where the tx is present\n   * @param txID operation/tx hash to identify blockchain transaction\n   * @param expectedData expected swap details that will be used for validation\n   * @param confirmations no. of tx confirmations required\n   * @returns status of tx, current no. of confirms and est. next block generation timestamp.\n   * No. of confirmations and block timestamp is only returned when `status:Included`\n   */\n  abstract validateInitiateTransaction(\n    blockHeight: number,\n    txID: string,\n    secretHash: string,\n    receivingAddress: string,\n    amount: number,\n    payoff: number,\n    minRefundTimestamp: number,\n    minConfirmations: number,\n  ): Promise<SwapTransactionStatus>;\n\n  /**\n   * Encodes Signature in a form compliant with Atomex\n   *\n   * @param signature signature to encode\n   * @returns encoded signature\n   */\n  abstract encodeSignature(signature: string): string;\n\n  /**\n   * Encodes Public Key in a form compliant with Atomex\n   *\n   * @param publicKey public key\n   * @returns encoded public key\n   */\n  abstract encodePublicKey(publicKey: string): string;\n\n  /**\n   * Estimates Initiate fees for a Swap\n   *\n   * @param source the initiator address\n   * @returns the initiate fees for Swap\n   */\n  abstract estimateInitiateFees(source: string): Promise<number>;\n\n  /**\n   * Estimates Miner Fee and Reward for Redeem to be used in a Swap\n   *\n   * @param recipient the counter-party address\n   * @returns the minerFee and the rewardForRedeem\n   */\n  abstract estimateRedeemFees(recipient: string): Promise<RedeemFees>;\n\n  /**\n   * Check validity of an account address\n   * \n   * @param address account address\n   * @returns true if valid, else false\n   */\n  abstract isValidAddress(address: string): boolean;\n}\n\nexport const dt2ts = (isoTime: Date | string): number =>\n  Math.round(new Date(isoTime).getTime() / 1000);\n\nexport const now = (): number => Math.round(Date.now() / 1000);\n", "import { ParameterSchema } from '@taquito/michelson-encoder';\nimport {\n  BlockResponse,\n  OperationContentsAndResultTransaction,\n  OpKind,\n} from '@taquito/rpc';\nimport { TezosToolkit } from '@taquito/taquito';\nimport {\n  b58cdecode,\n  prefix,\n  validateAddress,\n  ValidationResult,\n} from '@taquito/utils';\n\nimport config from './config.json';\nimport { dt2ts, Helpers, now } from './helpers';\nimport {\n  Algorithm,\n  AuthMessage,\n  InitiateParameters,\n  PartialTransactionBody,\n  RedeemFees,\n  SwapTransactionStatus,\n  TezosBasedCurrency,\n  Network\n} from './types';\n\nconst formatTimestamp = (timestamp: number) => {\n  return new Date(timestamp * 1000).toISOString().slice(0, -5) + 'Z';\n};\n\n/**\n * Tezos Util class for Tezos related Atomex helper functions\n */\nexport class TezosHelpers extends Helpers {\n  protected _tezos: TezosToolkit;\n  protected _contractAddress: string;\n  protected _timeBetweenBlocks: number;\n  protected _entrypoints: Map<string, ParameterSchema>;\n  protected _gasLimit: number;\n  protected _minimalFees: number;\n  protected _minimalNanotezPerGasUnit: number;\n  protected _minimalNanotezPerByte: number;\n  protected _costPerByte: number;\n  protected _redeemTxSize: number;\n  protected _initiateTxSize: number;\n\n  constructor(\n    tezos: TezosToolkit,\n    entrypoints: Record<string, any>,\n    contractAddress: string,\n    timeBetweenBlocks: number,\n    gasLimit: number,\n    minimalFees: number,\n    minimalNanotezPerGasUnit: number,\n    minimalNanotezPerByte: number,\n    costPerByte: number,\n    redeemTxSize: number,\n    initiateTxSize: number,\n  ) {\n    super();\n    this._tezos = tezos;\n    this._contractAddress = contractAddress;\n    this._timeBetweenBlocks = timeBetweenBlocks;\n    this._gasLimit = gasLimit;\n    this._minimalFees = minimalFees;\n    this._minimalNanotezPerGasUnit = minimalNanotezPerGasUnit;\n    this._minimalNanotezPerByte = minimalNanotezPerByte;\n    this._costPerByte = costPerByte;\n    this._redeemTxSize = redeemTxSize;\n    this._initiateTxSize = initiateTxSize;\n    this._entrypoints = new Map<string, ParameterSchema>(\n      Object.entries(entrypoints).map(([name, typeExpr]) => {\n        return [name, new ParameterSchema(typeExpr)];\n      }),\n    );\n  }\n\n  /**\n   * Connects to the supported tezos chain\n   *\n   * @param network networks supported by atomex, can be either mainnet or testnet\n   * @param currency either native currency (XTZ) or any supported FA1.2/FA2 token symbol\n   * @param rpc optional rpc endpoint to create tezos chain client\n   * @returns chain id of the connected chain\n   */\n  static async create(\n    network: Network,\n    currency: TezosBasedCurrency = 'XTZ',\n    rpcUri?: string,\n  ): Promise<TezosHelpers> {\n    const networkSettings = config.blockchains.tezos.rpc[network];\n    if (rpcUri !== undefined) {\n      networkSettings.rpc = rpcUri;\n    }\n\n    const tezos = new TezosToolkit(networkSettings.rpc);\n    const chainID = await tezos.rpc.getChainId();\n    if (networkSettings.chainID !== chainID.toString()) {\n      throw new Error(\n        `Wrong chain ID: expected ${networkSettings.chainID}, actual ${chainID}`,\n      );\n    }\n\n    return new TezosHelpers(\n      tezos,\n      config.currencies[currency].contracts.entrypoints,\n      config.currencies[currency].contracts[network].address,\n      config.blockchains.tezos.rpc[network].blockTime,\n      config.currencies[currency].contracts[network].gasLimit,\n      config.blockchains.tezos.rpc[network].minimalFees,\n      config.blockchains.tezos.rpc[network].minimalNanotezPerGasUnit,\n      config.blockchains.tezos.rpc[network].minimalNanotezPerByte,\n      config.blockchains.tezos.rpc[network].costPerByte,\n      config.currencies[currency].contracts[network].redeemTxSize,\n      config.currencies[currency].contracts[network].initiateTxSize,\n    );\n  }\n\n  private getTezosAlgorithm(prefix?: string): Algorithm {\n    switch (prefix) {\n      case 'tz1':\n        return 'Ed25519:Blake2b';\n      case 'tz2':\n        return 'Blake2bWithEcdsa:Secp256k1';\n      case 'tz3':\n        return 'Blake2bWithEcdsa:Secp256r1';\n      default:\n        throw new Error(`Unexpected address prefix: ${prefix}`);\n    }\n  }\n\n  getAuthMessage(message: string, address: string): AuthMessage {\n    const nowMillis = Date.now();\n    return {\n      message,\n      timestamp: nowMillis,\n      msgToSign: message + nowMillis.toString(),\n      algorithm: this.getTezosAlgorithm(address.slice(0, 3)),\n    };\n  }\n\n  buildInitiateTransaction(\n    initiateParameters: InitiateParameters,\n  ): PartialTransactionBody {\n    if (initiateParameters.refundTimestamp < now()) {\n      throw new Error(\n        `Swap timestamp is in the past: ${initiateParameters.refundTimestamp}`,\n      );\n    }\n\n    const parameter = this._entrypoints\n      .get('initiate')\n      ?.Encode(\n        initiateParameters.receivingAddress,\n        initiateParameters.secretHash,\n        formatTimestamp(initiateParameters.refundTimestamp),\n        initiateParameters.rewardForRedeem,\n      );\n    return {\n      data: {\n        entrypoint: 'initiate',\n        value: parameter,\n      },\n      contractAddr: this._contractAddress,\n      amount: initiateParameters.netAmount + initiateParameters.rewardForRedeem,\n    };\n  }\n\n  buildRedeemTransaction(\n    secret: string,\n    _hashedSecret = '',\n  ): PartialTransactionBody {\n    return {\n      data: {\n        entrypoint: 'redeem',\n        value: this._entrypoints.get('redeem')?.Encode(secret),\n      },\n      contractAddr: this._contractAddress,\n    };\n  }\n\n  buildRefundTransaction(secretHash: string): PartialTransactionBody {\n    return {\n      data: {\n        entrypoint: 'refund',\n        value: this._entrypoints.get('refund')?.Encode(secretHash),\n      },\n      contractAddr: this._contractAddress,\n    };\n  }\n\n  buildAddTransaction(\n    secretHash: string,\n    amount: number,\n  ): PartialTransactionBody {\n    return {\n      amount,\n      data: {\n        entrypoint: 'add',\n        value: this._entrypoints.get('add')?.Encode(secretHash),\n      },\n      contractAddr: this._contractAddress,\n    };\n  }\n\n  /**\n   * Get Block level\n   *\n   * @param blockLevel block level to identify the block\n   * @returns level of the block and block generation time\n   */\n  getBlockDetails(block: BlockResponse) {\n    return {\n      level: block.metadata.level_info!.level,\n      timestamp: dt2ts(block.header.timestamp),\n    };\n  }\n\n  parseInitiateParameters(\n    content: OperationContentsAndResultTransaction,\n  ): InitiateParameters {\n    if (content.parameters === undefined) {\n      throw new Error('Parameters are undefined');\n    }\n\n    const params = this._entrypoints\n      .get(content.parameters.entrypoint)\n      ?.Execute(content.parameters.value);\n    if (params === undefined) {\n      throw new Error(\n        `Unexpected entrypoint: ${content.parameters.entrypoint}`,\n      );\n    }\n\n    const initiateParams = (() => {\n      switch (content.parameters.entrypoint) {\n        case 'initiate':\n          return params;\n        case 'fund':\n        case 'default':\n          return params['initiate'];\n        default:\n          throw new Error(\n            `Unexpected entrypoint: ${content.parameters.entrypoint}`,\n          );\n      }\n    })();\n\n    return {\n      secretHash: initiateParams['settings']['hashed_secret'],\n      receivingAddress: initiateParams['participant'],\n      refundTimestamp: dt2ts(initiateParams['settings']['refund_time']),\n      netAmount:\n        parseInt(content.amount) -\n        parseInt(initiateParams['settings']['payoff']),\n      rewardForRedeem: parseInt(initiateParams['settings']['payoff']),\n    };\n  }\n\n  findContractCall(\n    block: BlockResponse,\n    txID: string,\n  ): OperationContentsAndResultTransaction[] {\n    const opg = block.operations[3]?.find(opg => opg.hash == txID);\n    if (opg === undefined) {\n      throw new Error(`Operation not found: ${txID} @ ${block.hash}`);\n    }\n\n    const contents = (\n      opg.contents.filter(c => c.kind == 'transaction' && c.destination == this._contractAddress)\n    ) as OperationContentsAndResultTransaction[];\n    if (contents.length === 0) {\n      throw new Error('Unsupported contract version is used');\n    }\n\n    return contents;\n  }\n\n  async validateInitiateTransaction(\n    blockHeight: number,\n    txID: string,\n    secretHash: string,\n    receivingAddress: string,\n    amount: number,\n    payoff: number,\n    minRefundTimestamp: number,\n    minConfirmations = 2,\n  ): Promise<SwapTransactionStatus> {\n    const netAmount = amount - payoff;\n    const block = await this._tezos.rpc.getBlock({\n      block: blockHeight.toString(),\n    });\n\n    try {\n      const tx = this.findContractCall(block, txID).find(content => {\n        const initiateParameters = this.parseInitiateParameters(content);\n        if (initiateParameters.secretHash !== secretHash) {\n          console.log(`[${content.counter}] Secret hash: expect ${secretHash}, actual ${initiateParameters.secretHash}`);\n          return false;\n        }\n\n        if (initiateParameters.receivingAddress.toLowerCase() !== receivingAddress.toLowerCase()) {\n          console.log(`[${content.counter}] Receiving address: expect ${receivingAddress}, actual ${initiateParameters.receivingAddress}`);\n          return false;\n        }\n\n        if (initiateParameters.netAmount !== netAmount) {\n          console.log(`[${content.counter}] Net amount: expect ${netAmount}, actual ${initiateParameters.netAmount}`);\n          return false;\n        }\n\n        if (initiateParameters.refundTimestamp < minRefundTimestamp) {\n          console.log(`[${content.counter}] Refund timestamp: minimum ${minRefundTimestamp}, actual ${initiateParameters.refundTimestamp}`);\n          return false;\n        }\n\n        return true;\n      }, this);\n\n      if (tx === undefined) {\n        throw new Error(`Initiate transaction that satisfies the expected criteria is not found in ${txID} contents`);\n      }\n    } catch (e: any) {\n      return {\n        status: 'Invalid',\n        message: e.message,\n        confirmations: 0,\n        nextBlockETA: 0,\n      };\n    }\n\n    const headDetails = this.getBlockDetails(\n      await this._tezos.rpc.getBlock({ block: 'head' }),\n    );\n    const txBlockDetails = this.getBlockDetails(block);\n    const confirmations = headDetails.level! - txBlockDetails.level!;\n\n    const res: SwapTransactionStatus = {\n      status: 'Included',\n      confirmations,\n      nextBlockETA: headDetails.timestamp + this._timeBetweenBlocks,\n    };\n\n    if (confirmations >= minConfirmations) {\n      res.status = 'Confirmed';\n    }\n\n    return res;\n  }\n\n  encodePublicKey(pubKey: string): string {\n    const curve = pubKey.substring(0, 2);\n    switch (curve) {\n      case 'ed':\n        return Buffer.from(b58cdecode(pubKey, prefix['edpk'])).toString('hex');\n      case 'p2':\n        return Buffer.from(b58cdecode(pubKey, prefix['p2pk'])).toString('hex');\n      case 'sp':\n        return Buffer.from(b58cdecode(pubKey, prefix['sppk'])).toString('hex');\n      default:\n        throw new Error('Unsupported Public Key Type');\n    }\n  }\n\n  encodeSignature(signature: string): string {\n    const pref = signature.startsWith('sig')\n      ? signature.substring(0, 3)\n      : signature.substring(0, 5);\n    if (Object.prototype.hasOwnProperty.call(prefix, pref)) {\n      return Buffer.from(\n        b58cdecode(\n          signature,\n          Object.getOwnPropertyDescriptor(prefix, pref)?.value,\n        ),\n      ).toString('hex');\n    }\n    throw new Error('Unsupported Signature Type');\n  }\n\n  calcFees(gas = 0, storageDiff = 0, txSize = 0): number {\n    return (\n      this._minimalFees +\n      this._minimalNanotezPerGasUnit * gas +\n      this._minimalNanotezPerByte * txSize +\n      storageDiff * this._costPerByte\n    );\n  }\n\n  async estimateInitiateFees(source: string): Promise<number> {\n    const dummyTx = {\n      receivingAddress: 'tz1Q2prWCrDGFDuGTe7axdt4z9e3QkCqdhmD',\n      secretHash:\n        '169cbd29345af89a0983f28254e71bdd1367890b9876fc8a9ea117c32f6a521b',\n      refundTimestamp: 2147483647,\n      rewardForRedeem: 0,\n      netAmount: 100,\n    };\n\n    const tx = this.buildInitiateTransaction(dummyTx);\n\n    const header = await this._tezos.rpc.getBlockHeader();\n    const contract = await this._tezos.rpc.getContract(source);\n    const op = await this._tezos.rpc.runOperation({\n      chain_id: header.chain_id,\n      operation: {\n        branch: header.hash,\n        signature:\n          'sigUHx32f9wesZ1n2BWpixXz4AQaZggEtchaQNHYGRCoWNAXx45WGW2ua3apUUUAGMLPwAU41QoaFCzVSL61VaessLg4YbbP',\n        contents: [\n          {\n            amount: '0',\n            counter: (parseInt(contract.counter || '0') + 1).toString(),\n            destination: this._contractAddress,\n            fee: this.calcFees(1040000, 60000, this._initiateTxSize).toString(),\n            gas_limit: '1040000', // TODO: move to config\n            kind: OpKind.TRANSACTION,\n            source,\n            storage_limit: '60000', // TODO: move to config\n            parameters: tx.data,\n          },\n        ],\n      },\n    });\n\n    let paidStorageDiff = 0,\n      consumedGas = 0;\n    (op.contents as OperationContentsAndResultTransaction[]).forEach(tx => {\n      if (tx.metadata.operation_result.status !== 'applied') {\n        throw new Error('Some error was encountered while estimating fees');\n      }\n      consumedGas += parseInt(tx.metadata.operation_result.consumed_gas || '0');\n      paidStorageDiff += parseInt(\n        tx.metadata.operation_result.paid_storage_size_diff || '0',\n      );\n    });\n\n    return this.calcFees(consumedGas, paidStorageDiff, this._initiateTxSize);\n  }\n\n  async estimateRedeemFees(recipient: string): Promise<RedeemFees> {\n    let fees = this.calcFees(this._gasLimit, 0, this._redeemTxSize);\n    const revealedKey = await this._tezos.rpc.getManagerKey(recipient);\n    if (revealedKey === null) {\n      fees += 257 * this._costPerByte;\n    }\n    return {\n      totalCost: fees,\n      rewardForRedeem: 2 * fees,\n    };\n  }\n\n  isValidAddress(address: string): boolean {\n    return validateAddress(address) == ValidationResult.VALID;\n  }\n}\n", "import { OperationContentsAndResultTransaction } from '@taquito/rpc';\nimport { TezosToolkit } from '@taquito/taquito';\n\nimport config from './config.json';\nimport { dt2ts } from './helpers';\nimport { TezosHelpers } from './tezos';\nimport { InitiateParameters, Network, TezosBasedCurrency } from './types';\n\n\n/**\n * TZIP-7 Util class for Tezos FA1.2 tokens related Atomex helper functions\n */\nexport class FA12Helpers extends TezosHelpers {\n\n  /**\n   * Connects to the supported tezos chain\n   *\n   * @param network networks supported by atomex, can be either mainnet or testnet\n   * @param currency FA1.2 token symbol\n   * @param rpc optional rpc endpoint to create tezos chain client\n   * @returns chain id of the connected chain\n   */\n  static async create(\n    network: Network,\n    currency: TezosBasedCurrency,\n    rpcUri?: string,\n  ): Promise<TezosHelpers> {\n    const networkSettings = config.blockchains.tezos.rpc[network];\n    if (rpcUri !== undefined) {\n      networkSettings.rpc = rpcUri;\n    }\n\n    const tezos = new TezosToolkit(networkSettings.rpc);\n    const chainID = await tezos.rpc.getChainId();\n    if (networkSettings.chainID !== chainID.toString()) {\n      throw new Error(\n        `Wrong chain ID: expected ${networkSettings.chainID}, actual ${chainID}`,\n      );\n    }\n\n    return new FA12Helpers(\n      tezos,\n      config.currencies[currency].contracts.entrypoints,\n      config.currencies[currency].contracts[network].address,\n      config.blockchains.tezos.rpc[network].blockTime,\n      config.currencies[currency].contracts[network].gasLimit,\n      config.blockchains.tezos.rpc[network].minimalFees,\n      config.blockchains.tezos.rpc[network].minimalNanotezPerGasUnit,\n      config.blockchains.tezos.rpc[network].minimalNanotezPerByte,\n      config.blockchains.tezos.rpc[network].costPerByte,\n      config.currencies[currency].contracts[network].redeemTxSize,\n      config.currencies[currency].contracts[network].initiateTxSize,\n    );\n  }\n\n  parseInitiateParameters(\n    content: OperationContentsAndResultTransaction,\n  ): InitiateParameters {\n    if (content.parameters === undefined) {\n      throw new Error('Parameters are undefined');\n    }\n\n    const params = this._entrypoints\n      .get(content.parameters.entrypoint)\n      ?.Execute(content.parameters.value);\n    if (params === undefined) {\n      throw new Error(\n        `Unexpected entrypoint: ${content.parameters.entrypoint}`,\n      );\n    }\n\n    const initiateParams = (() => {\n      switch (content.parameters.entrypoint) {\n        case 'initiate':\n          return params;\n        case 'default':\n          return params['initiate'];\n        default:\n          throw new Error(\n            `Unexpected entrypoint: ${content.parameters.entrypoint}`,\n          );\n      }\n    })();\n\n    return {\n      secretHash: initiateParams['hashedSecret'],\n      receivingAddress: initiateParams['participant'],\n      refundTimestamp: dt2ts(initiateParams['refundTime']),\n      netAmount: parseInt(initiateParams['totalAmount']) - parseInt(initiateParams['payoffAmount']),\n      rewardForRedeem: parseInt(initiateParams['payoffAmount']),\n    };\n  }\n}\n", "import { OperationContentsAndResultTransaction } from '@taquito/rpc';\nimport { TezosToolkit } from '@taquito/taquito';\n\nimport config from './config.json';\nimport { dt2ts } from './helpers';\nimport { TezosHelpers } from './tezos';\nimport { InitiateParameters, Network, TezosBasedCurrency } from './types';\n\n\nexport class FA2Helpers extends TezosHelpers {\n\n  /**\n   * Connects to the supported tezos chain\n   *\n   * @param network networks supported by atomex, can be either mainnet or testnet\n   * @param currency FA2 token symbol\n   * @param rpc optional rpc endpoint to create tezos chain client\n   * @returns chain id of the connected chain\n   */\n  static async create(\n    network: Network,\n    currency: TezosBasedCurrency,\n    rpcUri?: string,\n  ): Promise<TezosHelpers> {\n    const networkSettings = config.blockchains.tezos.rpc[network];\n    if (rpcUri !== undefined) {\n      networkSettings.rpc = rpcUri;\n    }\n\n    const tezos = new TezosToolkit(networkSettings.rpc);\n    const chainID = await tezos.rpc.getChainId();\n    if (networkSettings.chainID !== chainID.toString()) {\n      throw new Error(\n        `Wrong chain ID: expected ${networkSettings.chainID}, actual ${chainID}`,\n      );\n    }\n\n    return new FA2Helpers(\n      tezos,\n      config.currencies[currency].contracts.entrypoints,\n      config.currencies[currency].contracts[network].address,\n      config.blockchains.tezos.rpc[network].blockTime,\n      config.currencies[currency].contracts[network].gasLimit,\n      config.blockchains.tezos.rpc[network].minimalFees,\n      config.blockchains.tezos.rpc[network].minimalNanotezPerGasUnit,\n      config.blockchains.tezos.rpc[network].minimalNanotezPerByte,\n      config.blockchains.tezos.rpc[network].costPerByte,\n      config.currencies[currency].contracts[network].redeemTxSize,\n      config.currencies[currency].contracts[network].initiateTxSize,\n    );\n  }\n\n  parseInitiateParameters(content: OperationContentsAndResultTransaction): InitiateParameters {\n    if (!content.parameters) {\n      throw new Error('Parameters are undefined');\n    }\n\n    const params = this._entrypoints.get(content.parameters.entrypoint)?.Execute(content.parameters.value);\n    if (!params) {\n      throw new Error(`Unexpected entrypoint: ${content.parameters.entrypoint}`);\n    }\n\n    const initiateParams = this.getInitiateParams(content.parameters.entrypoint, params);\n\n    return {\n      // TODO: return tokenAddress and tokenId\n      secretHash: initiateParams['hashedSecret'],\n      receivingAddress: initiateParams['participant'],\n      refundTimestamp: dt2ts(initiateParams['refundTime']),\n      netAmount: parseInt(initiateParams['totalAmount']) - parseInt(initiateParams['payoffAmount']),\n      rewardForRedeem: parseInt(initiateParams['payoffAmount']),\n    };\n  }\n\n  private getInitiateParams(entrypoint: string, params: any) {\n    switch (entrypoint) {\n      case 'initiate':\n        return params;\n      case 'default':\n        return params['initiate'];\n      default:\n        throw new Error(\n          `Unexpected entrypoint: ${entrypoint}`,\n        );\n    }\n  }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACKO,IAAM,SAAN,MAAa;AAAA,EAClB,AAAS;AAAA,EACT,AAAS;AAAA,EACT,AAAS;AAAA,EAET,AAAS;AAAA,EAET,YAAY,SAAwB;AAClC,SAAK,gBAAgB,QAAQ;AAC7B,SAAK,qBAAqB,QAAQ,UAAU;AAC5C,SAAK,UAAU,QAAQ;AACvB,SAAK,gBAAgB,QAAQ;AAAA,EAC/B;AAAA,EAIA,MAAM,KAAK,wBAAqD,eAA0D;AACxH,UAAM,IAAI,MAAM,iBAAiB;AAAA,EACnC;AACF;;;AClBO,IAAM,eAAN,MAAkF;AAAA,EACrF,AAAQ,YAAuC,oBAAI,IAAI;AAAA,EAEvD,YAAY,UAAgC;AACxC,SAAK,UAAU,IAAI,QAAQ;AAC3B,WAAO;AAAA,EACX;AAAA,EAEA,eAAe,UAAgC;AAC3C,QAAI,KAAK,UAAU,IAAI,QAAQ;AAC3B,WAAK,UAAU,OAAO,QAAQ;AAClC,WAAO;AAAA,EACX;AAAA,EAEA,qBAAqB;AACjB,SAAK,YAAY,oBAAI,IAAI;AACzB,WAAO;AAAA,EACX;AAAA,EAEA,QAAQ,MAAS;AACb,QAAI,CAAC,KAAK,UAAU;AAChB;AAEJ,QAAI,KAAK,UAAU,SAAS,GAAG;AAC3B,WAAK,UAAU,OAAO,EAAE,KAAK,EAAE,MAAM,GAAG,IAAI;AAAA,IAChD,OAAO;AAEH,OAAC,GAAG,KAAK,SAAS,EAAE,QAAQ,cAAY,SAAS,GAAG,IAAI,CAAC;AAAA,IAC7D;AAAA,EACJ;AACJ;;;ACpCA,yBAAuB;AAEvB,wBAAsB;AAEtB,IAAM,cAAe,WAAW,SAAU;;;ACJ1C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBAAsB;AAIf,IAAM,wBAAwB,CAAC,QAA4B;AAJlE;AAKE,QAAM,WAAW,UAAI,MAAM,cAAc,MAAxB,mBAA2B,IAAI,SAAO,SAAS,KAAK,EAAE;AAGvE,SAAO,IAAI,WAAW,QAAS;AACjC;AAEO,IAAM,wBAAwB,CAAC,UAA8B,0BAAO,KAAK,KAAK,EAAE,SAAS,KAAK;AAC9F,IAAM,oBAAoB,CAAC,UAA0B,0BAAO,KAAK,OAAO,MAAM,EAAE,SAAS,KAAK;AAC9F,IAAM,oBAAoB,CAAC,UAA0B,0BAAO,KAAK,sBAAsB,KAAK,CAAC,EAAE,SAAS,MAAM;AAE9G,IAAM,oBAAoB,CAAC,UAA2C,kBAAkB,KAAK,UAAU,KAAK,CAAC;AAC7G,IAAM,oBAAoB,CAA8D,UAA4B;AACzH,MAAI;AACF,WAAO,KAAK,MAAM,kBAAkB,KAAK,CAAC;AAAA,EAC5C,QACA;AACE,WAAO;AAAA,EACT;AACF;AAEO,IAAM,oBAAoB,CAAC,cAAkC,aAAgC;AAClG,SAAO,IAAI,yBAAU,YAAY,EAAE,aAAa,MAAM,QAAQ,EAAE,aAAa;AAC/E;AAEO,IAAM,uBAAuB,CAAC,OAA2B,aAAgC;AAC9F,SAAO,IAAI,yBAAU,KAAK,EAAE,aAAa,EAAE,IAAI,MAAM,QAAQ;AAC/D;;;AC/BA;AAAA;AAAA;AAAA;AAEO,IAAM,wBAAwB,CACnC,QACA,WACG;AACH,MAAK,QAAO,WAAW,WAAW,SAAS,OAAO,mBAAoB,QAAO,WAAW,WAAW,SAAS,OAAO;AACjH;AAEF,QAAM,IAAI,MAAM,wBAAwB;AAC1C;;;ACVA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAO,IAAM,aAAa,CAAC,UAAuB;AAAlD;AAAqD,kBAAU,aAAM,OAAN,mBAAU,uBAAsB,MAAM,MAAM,CAAC;AAAA;AAE5G,IAAM,YAAY,CAAC,QAAgB,SAAkB,WAAmB,aAAa,QAAQ;AAC3F,MAAI,OAAO,UAAU,aAAa;AAChC,WAAO,OAAO,SAAS,WAAW,UAAU;AAE9C,QAAM,eAAe,OAAO;AAE5B,MAAI,aAAa,gBAAgB,cAAc;AAC7C,WAAO;AAET,QAAM,aAAa,YAAY;AAC/B,MAAI,SAAS,WAAW,OAAO,KAAK,KAAK,aAAa,WAAW,MAAM,CAAC;AAExE,MAAI,OAAO,SAAS;AAClB,aAAS,OAAO,MAAM,GAAG,UAAU;AAErC,SAAO,UAAU,SAAS,SAAS,SAAS;AAC9C;AAEO,IAAM,WAAW,CAAC,QAAgB,WAAmB,aAAa,QAAQ,OAAO,UAAU,aAAa,SAC3G,OAAO,SAAS,WAAW,UAAU,IACrC,UAAU,QAAQ,MAAM,WAAW,UAAU;AAE1C,IAAM,SAAS,CAAC,QAAgB,WAAmB,aAAa,QAAQ,OAAO,UAAU,WAAW,SACvG,OAAO,OAAO,WAAW,UAAU,IACnC,UAAU,QAAQ,OAAO,WAAW,UAAU;;;ACtB3C,IAAM,OAAO,CAAC,OAAe,IAAI,QAAc,aAAW,WAAW,SAAS,EAAE,CAAC;AAEjF,IAAM,yBAAyB,CAAC,eAAuB,KAAK,IAAI,YAAY,UAAU;;;ACYtF,IAAM,wBAAN,MAA2B;AAAA,EAChC,AAAS,SAAqC;AAAA,IAC5C,YAAY,IAAI,aAAa;AAAA,IAC7B,cAAc,IAAI,aAAa;AAAA,IAC/B,mBAAmB,IAAI,aAAa;AAAA,IACpC,kBAAkB,IAAI,aAAa;AAAA,EACrC;AAAA,EAUA,AAAS;AAAA,EAET,AAAmB;AAAA,EACnB,AAAmB;AAAA,EACnB,AAAmB;AAAA,EACnB,AAAmB;AAAA,EAEnB,AAAiB,iBAA6C,oBAAI,IAAI;AAAA,EAEtE,YAAY,SAAsC;AAChD,SAAK,gBAAgB,QAAQ;AAC7B,SAAK,QAAQ,QAAQ;AACrB,SAAK,iBAAiB,QAAQ;AAE9B,wBAAY,sBAAsB,MAAM,KAAK,cAAc;AAE3D,SAAK,mBAAmB,IAAI,IAAI,sBAAqB,4BAA4B,QAAQ,oBAAoB;AAC7G,SAAK,oCAAoC,QAAQ,qCAAqC,sBAAqB;AAAA,EAC7G;AAAA,EAEA,IAAc,gBAAoD;AAChE,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,aAAa,SAAwC;AA1DvD;AA2DI,WAAO,WAAK,cAAc,IAAI,OAAO,MAA9B,mBAAiC;AAAA,EAC1C;AAAA,EAEA,MAAM,UACJ,SACA,uBAAuB,OACvB,YACA,cAAsB,sBAAqB,sBACvB;AACpB,QAAI,CAAC,sBAAsB;AACzB,YAAM,aAAY,KAAK,aAAa,OAAO,KAAM,MAAM,KAAK,uBAAuB,OAAO;AAE1F,UAAI,cAAa,CAAC,KAAK,gBAAgB,UAAS;AAC9C,eAAO;AAAA,IACX;AAEA,UAAM,SAAS,MAAM,KAAK,eAAe,WAAW,SAAS,UAAU;AACvE,QAAI,CAAC;AACH,YAAM,IAAI,MAAM,8CAA8C,iBAAiB;AAEjF,UAAM,YAAY,KAAK,0BAA0B,WAAW;AAC5D,UAAM,kBAAkB,MAAM,OAAO,KAAK,cAAc,SAAS;AAEjE,QAAI,gBAAgB,YAAY;AAC9B,YAAM,IAAI,MAAM,oCAAoC;AAEtD,UAAM,6BAA6B,MAAM,KAAK,iBAAiB;AAAA,MAC7D,SAAS;AAAA,MACT,WAAW,gBAAgB;AAAA,MAC3B,WAAW,gBAAgB;AAAA,MAC3B,iBAAiB,gBAAgB;AAAA,MACjC,WAAW,gBAAgB;AAAA,MAC3B;AAAA,IACF,CAAC;AAED,UAAM,YAAuB;AAAA,MAC3B,OAAO,2BAA2B;AAAA,MAClC,QAAQ,2BAA2B;AAAA,MACnC;AAAA,MACA,SAAS,IAAI,KAAK,2BAA2B,OAAO;AAAA,IACtD;AAEA,UAAM,KAAK,kBAAkB,WAAW,IAAI;AAE5C,WAAO;AAAA,EACT;AAAA,EAEA,MAAM,YAAY,SAAmC;AACnD,UAAM,YAAY,KAAK,aAAa,OAAO;AAE3C,WAAO,YAAY,KAAK,oBAAoB,SAAS,IAAI;AAAA,EAC3D;AAAA,EAEA,MAAM,uBAAuB,SAAiD;AAC5E,UAAM,YAAY,MAAM,KAAK,MAAM,aAAa,OAAO;AAEvD,QAAI,CAAC;AACH,aAAO;AAET,WAAO,MAAM,KAAK,kBAAkB,WAAW,KAAK;AAAA,EACtD;AAAA,EAEA,MAAgB,kBAAkB,WAAsB,YAAqD;AAC3G,UAAM,YAAY,KAAK,eAAe,SAAS;AAC/C,QAAI,CAAC;AACH;AAEF,UAAM,gBAAgB;AAAA,MACpB;AAAA,MACA;AAAA,IACF;AACA,SAAK,eAAe,IAAI,UAAU,SAAS,aAAa;AAExD,QAAI;AACF,kBAAY,MAAM,KAAK,MAAM,gBAAgB,UAAU,SAAS,SAAS;AAE3E,IAAC,KAAK,OAA2C,WAAW,KAAK,SAAS;AAC1E,WAAO;AAAA,EACT;AAAA,EAEA,MAAgB,oBAAoB,WAAwC;AAC1E,UAAM,gBAAgB,KAAK,eAAe,IAAI,UAAU,OAAO;AAC/D,QAAI,CAAC;AACH,aAAO;AAET,SAAK,iBAAiB,cAAc,SAAS;AAC7C,UAAM,SAAU,MAAM,KAAK,MAAM,gBAAgB,SAAS,KAAK,KAAK,eAAe,OAAO,UAAU,OAAO;AAE3G,QAAI;AACF,MAAC,KAAK,OAA2C,aAAa,KAAK,SAAS;AAE9E,WAAO;AAAA,EACT;AAAA,EAEA,AAAU,eAAe,WAAkD;AACzE,UAAM,gBAAgB,UAAU,QAAQ,QAAQ,IAAI,KAAK,IAAI;AAC7D,QAAI,iBAAiB,GAAG;AACtB,WAAK,MAAM,gBAAgB,SAAS;AACpC,MAAC,KAAK,OAA2C,iBAAiB,KAAK,SAAS;AAEhF;AAAA,IACF;AAEA,UAAM,wBAAwB,gBAAiB,KAAK,oCAAoC;AACxF,UAAM,YAAY,WAAW,KAAK,kCAAkC,uBAAuB,qBAAqB,GAAG,SAAS;AAE5H,WAAO;AAAA,EACT;AAAA,EAEA,AAAU,iBAAiB,oBAAgD;AACzE,iBAAa,kBAAkB;AAAA,EACjC;AAAA,EAEA,AAAU,0BAA0B,cAA8B;AAChE,WAAO,KAAK,IAAI;AAAA,EAClB;AAAA,EAEA,MAAgB,iBAAiB,aAA6E;AAC5G,UAAM,WAAW,MAAM,YAAM,KAAK,iBAAiB,MAAM;AAAA,MACvD,QAAQ;AAAA,MACR,SAAS;AAAA,QACP,UAAU;AAAA,QACV,gBAAgB;AAAA,MAClB;AAAA,MACA,MAAM,KAAK,UAAU,WAAW;AAAA,IAClC,CAAC;AAED,QAAI,CAAC,SAAS;AACZ,YAAM,IAAI,MAAM,MAAM,SAAS,KAAK,CAAC;AAEvC,WAAO,SAAS,KAAK;AAAA,EACvB;AAAA,EAEA,AAAU,mCAAmC,CAAC,cAAyB;AACrE,UAAM,gBAAgB,KAAK,eAAe,IAAI,UAAU,OAAO;AAC/D,QAAI,CAAC;AACH;AAEF,iBAAa,cAAc,SAAS;AACpC,UAAM,WAAW,UAAU,QAAQ,QAAQ,IAAI,KAAK,IAAI;AACxD,UAAM,eAAe,WAAW,KAAK,iCAAiC,uBAAuB,QAAQ,GAAG,SAAS;AAEjH,SAAK,eAAe,IAAI,UAAU,SAAS;AAAA,MACzC,GAAG;AAAA,MACH,WAAW;AAAA,IACb,CAAC;AACD,IAAC,KAAK,OAA2C,kBAAkB,KAAK,SAAS;AAAA,EACnF;AAAA,EAEA,AAAU,kCAAkC,CAAC,cAAyB;AACpE,SAAK,oBAAoB,SAAS;AAClC,IAAC,KAAK,OAA2C,iBAAiB,KAAK,SAAS;AAAA,EAClF;AAAA,EAEA,AAAU,gBAAgB,WAAsB;AAC9C,WAAQ,UAAU,QAAQ,QAAQ,IAAI,KAAK,IAAI,KAAO,KAAK,oCAAoC;AAAA,EACjG;AACF;AAtMO,IAAM,uBAAN;AAYL,cAZW,sBAYe,wBAAuB;AACjD,cAbW,sBAae,8BAA6B;AACvD,cAdW,sBAce,iDAAgD;;;AC5BrE,IAAM,iBAAN,MAAqB;AAAA,EAG1B,YAAqB,eAA8B;AAA9B;AAAA,EACrB;AAAA,EAHA,AAAiB,WAAwB,oBAAI,IAAI;AAAA,EAKjD,IAAc,UAAuB;AACnC,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,UAAU,QAAiC;AACzC,wBAAY,sBAAsB,MAAM,MAAM;AAC9C,SAAK,SAAS,IAAI,MAAM;AAExB,WAAO,QAAQ,QAAQ,MAAM;AAAA,EAC/B;AAAA,EAIA,MAAM,aAAa,iBAAkC,YAAuC;AAC1F,UAAM,SAAS,OAAO,oBAAoB,WAErC,MAAM,KAAK,WAAW,iBAAiB,UAAU,IAClD;AAEJ,WAAO,SAAS,KAAK,SAAS,OAAO,MAAM,IAAI;AAAA,EACjD;AAAA,EAEA,MAAM,WAAW,SAAiB,YAAkD;AAClF,QAAI,CAAC,KAAK,QAAQ;AAChB,aAAO;AAET,UAAM,2BAA8E,CAAC;AACrF,eAAW,UAAU,KAAK,SAAS;AACjC,UAAI,cAAc,OAAO,eAAe;AACtC;AAEF,YAAM,mBAAmB,OAAO,WAAW;AAC3C,UAAI,OAAO,qBAAqB,UAAU;AACxC,YAAI,qBAAqB;AACvB,iBAAO;AAAA;AAEP;AAAA,MACJ;AAEA,+BAAyB,KAAK,iBAAiB,KAAK,cAAW,CAAC,QAAQ,QAAO,CAAC,CAAC;AAAA,IACnF;AAEA,UAAM,0BAA0B,MAAM,QAAQ,WAAW,wBAAwB;AACjF,eAAW,0BAA0B,yBAAyB;AAC5D,UAAI,uBAAuB,WAAW,aAAa;AAEjD;AAAA,MACF;AAEA,UAAI,uBAAuB,MAAM,OAAO;AACtC,eAAO,uBAAuB,MAAM;AAAA,IACxC;AAEA,WAAO;AAAA,EACT;AACF;;;AC7DO,IAAM,mCAAN,MAA4E;AAAA,EACjF,kCAAkC,WAAkD;AAClF,WAAO;AAAA,MACL,GAAG,UAAU;AAAA,MACb,GAAG,UAAU;AAAA,MACb,GAAG,UAAU,QAAQ,QAAQ;AAAA,MAC7B,GAAG,UAAU;AAAA,IACf;AAAA,EACF;AAAA,EAEA,kCAAkC,qBAA4D;AAC5F,WAAO;AAAA,MACL,SAAS,oBAAoB;AAAA,MAC7B,QAAQ,oBAAoB;AAAA,MAC5B,SAAS,IAAI,KAAK,oBAAoB,CAAC;AAAA,MACvC,OAAO,oBAAoB;AAAA,IAC7B;AAAA,EACF;AACF;;;AClBO,IAAM,6BAAN,MAAyD;AAAA,EAG9D,YACqB,eACA,2BACV,YAAoB,2BAA0B,kBACvD;AAHmB;AACA;AACV;AAAA,EAEX;AAAA,EAEA,aAAa,SAAwC;AACnD,UAAM,eAAe,aAAa,QAAQ,KAAK,OAAO,OAAO,CAAC;AAE9D,WAAQ,gBAAgB,KAAK,0BAA0B,kCAAkC,KAAK,MAAM,YAAY,CAAC,KAC5G;AAAA,EACP;AAAA,EAEA,cAAc,WAAkC;AAC9C,WAAO,UAAU,IAAI,aAAW,KAAK,aAAa,OAAO,CAAC,EACvD,OAAO,OAAO;AAAA,EACnB;AAAA,EAEA,gBAAgB,SAAiB,WAAiC;AAChE,UAAM,sBAAsB,KAAK,0BAA0B,kCAAkC,SAAS;AACtG,QAAI,CAAC;AACH,YAAM,IAAI,MAAM,wBAAwB,0DAA0D;AAEpG,iBAAa,QAAQ,KAAK,OAAO,OAAO,GAAG,KAAK,UAAU,mBAAmB,CAAC;AAE9E,WAAO;AAAA,EACT;AAAA,EAEA,gBAAgB,SAA0B;AACxC,iBAAa,WAAW,KAAK,OAAO,OAAO,CAAC;AAE5C,WAAO;AAAA,EACT;AAAA,EAEA,AAAU,OAAO,SAAiB;AAChC,WAAO,KAAK,YAAY;AAAA,EAC1B;AACF;AAzCO,IAAM,4BAAN;AACL,cADW,2BACe,oBAAmB;;;ACIxC,IAAM,0BAAN,MAAsD;AAAA,EAG3D,YACqB,eACA,2BACV,YAAoB,wBAAuB,kBACpD;AAHmB;AACA;AACV;AAAA,EAEX;AAAA,EAEA,IAAc,MAAM;AAClB,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,aAAa,SAAwC;AACnD,UAAM,kCAAkC,KAAK,mCAAmC;AAGhF,WAAO,gCAAgC,YAAa,MAAK,0BAA0B,kCAAkC,gCAAgC,QAAS,KACzJ;AAAA,EACP;AAAA,EAEA,cAAc,WAAkC;AAC9C,UAAM,kCAAkC,KAAK,mCAAmC;AAEhF,WAAO,OAAO,OAAO,+BAA+B,EACjD,IAAI,yBAAuB,KAAK,0BAA0B,kCAAkC,mBAAmB,CAAC,EAChH,OAAO,CAAC,cAAsC,CAAC,CAAC,aAAa,UAAU,QAAQ,UAAU,OAAO,IAAI,EAAE;AAAA,EAC3G;AAAA,EAEA,gBAAgB,SAAiB,WAAiC;AAChE,UAAM,kCAAkC,KAAK,mCAAmC;AAChF,UAAM,sBAAsB,KAAK,0BAA0B,kCAAkC,SAAS;AACtG,QAAI,CAAC;AACH,YAAM,IAAI,MAAM,wBAAwB,0DAA0D;AAEpG,oCAAgC,WAAW;AAC3C,SAAK,aAAa,QAAQ,KAAK,KAAK,KAAK,UAAU,+BAA+B,CAAC;AAEnF,WAAO;AAAA,EACT;AAAA,EAEA,gBAAgB,SAA0B;AACxC,UAAM,kCAAkC,KAAK,mCAAmC;AAEhF,QAAI,CAAC,gCAAgC;AACnC,aAAO;AAET,WAAO,gCAAgC;AAEvC,QAAI,OAAO,KAAK,+BAA+B,EAAE;AAC/C,WAAK,aAAa,QAAQ,KAAK,KAAK,KAAK,UAAU,+BAA+B,CAAC;AAAA;AAEnF,WAAK,aAAa,WAAW,KAAK,GAAG;AAEvC,WAAO;AAAA,EACT;AAAA,EAEA,AAAU,qCAA4D;AACpE,UAAM,gBAAgB,KAAK,aAAa,QAAQ,KAAK,GAAG;AACxD,QAAI,CAAC;AACH,aAAO,CAAC;AAEV,WAAO,KAAK,MAAM,aAAa;AAAA,EACjC;AACF;AAjEO,IAAM,yBAAN;AACL,cADW,wBACe,oBAAmB;;;ACAxC,IAAM,wCAAN,MAAiF;AAAA,EACtF,AAAmB;AAAA,EAEnB,YACE,gBAA6D,cAC7D,4BAAuD,IAAI,iCAAiC,GAC5F;AACA,SAAK,gBAAgB,OAAO,kBAAkB,WAC1C,KAAK,8BAA8B,eAAe,yBAAyB,IAC3E;AAAA,EACN;AAAA,EAEA,aAAa,SAAiD;AAC5D,WAAO,QAAQ,QAAQ,KAAK,cAAc,aAAa,OAAO,CAAC;AAAA,EACjE;AAAA,EAEA,iBAAiB,WAA2C;AAC1D,WAAO,QAAQ,QAAQ,KAAK,cAAc,cAAc,SAAS,CAAC;AAAA,EACpE;AAAA,EAEA,gBAAgB,SAAiB,WAA0C;AACzE,WAAO,QAAQ,QAAQ,KAAK,cAAc,gBAAgB,SAAS,SAAS,CAAC;AAAA,EAC/E;AAAA,EAIA,gBAAgB,oBAA0D;AACxE,UAAM,UAAU,OAAO,uBAAuB,WAC1C,qBACA,mBAAmB;AAEvB,WAAO,QAAQ,QAAQ,KAAK,cAAc,gBAAgB,OAAO,CAAC;AAAA,EACpE;AAAA,EAEA,AAAQ,8BAA8B,cAA2C,2BAAsD;AACrI,YAAQ;AAAA,WACD;AACH,eAAO,IAAI,uBAAuB,WAAW,cAAc,yBAAyB;AAAA,WACjF;AACH,eAAO,IAAI,0BAA0B,WAAW,cAAc,yBAAyB;AAAA;AAEvF,cAAM,IAAI,MAAM,oCAAoC,cAAc;AAAA;AAAA,EAExE;AACF;;;AC9CO,IAAM,mBAAN,MAA+C;AAAA,EAKpD,YACW,eACU,sBACnB;AAFS;AACU;AAAA,EAErB;AAAA,EARA,AAAS,eAAmE,IAAI,aAAa;AAAA,EAC7F,AAAS,mBAA+E,IAAI,aAAa;AAAA,EACzG,AAAS,mBAAmF,IAAI,aAAa;AAAA,EAQ7G,SAAS,SAA6C;AACpD,UAAM,IAAI,MAAM,yBAAyB;AAAA,EAC3C;AAAA,EAEA,UAAU,UAA6D;AACrE,UAAM,IAAI,MAAM,yBAAyB;AAAA,EAC3C;AAAA,EAEA,aAAsC;AACpC,UAAM,IAAI,MAAM,yBAAyB;AAAA,EAC3C;AAAA,EAEA,eAAiC;AAC/B,UAAM,IAAI,MAAM,yBAAyB;AAAA,EAC3C;AAAA,EAEA,eAAmC;AACjC,UAAM,IAAI,MAAM,yBAAyB;AAAA,EAC3C;AAAA,EAEA,SAAS,iBAAmD;AAC1D,UAAM,IAAI,MAAM,yBAAyB;AAAA,EAC3C;AAAA,EAEA,YAAY,SAAmC;AAC7C,UAAM,IAAI,MAAM,yBAAyB;AAAA,EAC3C;AAAA,EAEA,kBAAmC;AACjC,UAAM,IAAI,MAAM,yBAAyB;AAAA,EAC3C;AAAA,EAEA,oBAAoB,MAA6C;AAC/D,UAAM,IAAI,MAAM,yBAAyB;AAAA,EAC3C;AAAA,EAEA,QAAQ,QAA+B;AACrC,UAAM,IAAI,MAAM,iBAAiB;AAAA,EACnC;AACF;;;AClDO,IAAM,wBAAN,MAAoD;AAAA,EAKzD,YACW,eACU,sBACnB;AAFS;AACU;AAAA,EAErB;AAAA,EARA,AAAS,eAAmE,IAAI,aAAa;AAAA,EAC7F,AAAS,mBAA+E,IAAI,aAAa;AAAA,EACzG,AAAS,mBAAmF,IAAI,aAAa;AAAA,EAQ7G,SAAS,SAA6C;AACpD,UAAM,IAAI,MAAM,yBAAyB;AAAA,EAC3C;AAAA,EAEA,UAAU,UAA6D;AACrE,UAAM,IAAI,MAAM,yBAAyB;AAAA,EAC3C;AAAA,EAEA,aAAsC;AACpC,UAAM,IAAI,MAAM,yBAAyB;AAAA,EAC3C;AAAA,EAEA,eAAiC;AAC/B,UAAM,IAAI,MAAM,yBAAyB;AAAA,EAC3C;AAAA,EAEA,eAAmC;AACjC,UAAM,IAAI,MAAM,yBAAyB;AAAA,EAC3C;AAAA,EAEA,SAAS,iBAAmD;AAC1D,UAAM,IAAI,MAAM,yBAAyB;AAAA,EAC3C;AAAA,EAEA,YAAY,SAAmC;AAC7C,UAAM,IAAI,MAAM,yBAAyB;AAAA,EAC3C;AAAA,EAEA,kBAAmC;AACjC,UAAM,IAAI,MAAM,yBAAyB;AAAA,EAC3C;AAAA,EAEA,oBAAoB,MAA6C;AAC/D,UAAM,IAAI,MAAM,yBAAyB;AAAA,EAC3C;AAAA,EAEA,QAAQ,QAA+B;AACrC,UAAM,IAAI,MAAM,iBAAiB;AAAA,EACnC;AACF;;;ACnDO,IAAM,uBAAN,MAAmD;AAAA,EACxD,YACW,eACA,kBACA,uBACT;AAHS;AACA;AACA;AAET,wBAAY,sBAAsB,MAAM,gBAAgB;AACxD,wBAAY,sBAAsB,MAAM,qBAAqB;AAAA,EAC/D;AAAA,EAEA,IAAI,eAAe;AACjB,WAAO,KAAK,sBAAsB;AAAA,EACpC;AAAA,EAEA,IAAI,mBAAmB;AACrB,WAAO,KAAK,sBAAsB;AAAA,EACpC;AAAA,EAEA,IAAI,mBAAmB;AACrB,WAAO,KAAK,sBAAsB;AAAA,EACpC;AAAA,EAEA,SAAS,SAA6C;AACpD,WAAO,KAAK,iBAAiB,SAAS,OAAO;AAAA,EAC/C;AAAA,EAEA,UAAU,UAA6D;AACrE,WAAO,KAAK,iBAAiB,UAAU,QAAQ;AAAA,EACjD;AAAA,EAEA,aAAsC;AACpC,WAAO,KAAK,iBAAiB,WAAW;AAAA,EAC1C;AAAA,EAEA,eAAiC;AAC/B,WAAO,KAAK,iBAAiB,aAAa;AAAA,EAC5C;AAAA,EAEA,eAAmC;AACjC,WAAO,KAAK,iBAAiB,aAAa;AAAA,EAC5C;AAAA,EAEA,SAAS,iBAAmD;AAC1D,WAAO,KAAK,iBAAiB,SAAS,eAAe;AAAA,EACvD;AAAA,EAEA,YAAY,SAAmC;AAC7C,WAAO,KAAK,iBAAiB,YAAY,OAAO;AAAA,EAClD;AAAA,EAEA,kBAAmC;AACjC,WAAO,KAAK,iBAAiB,gBAAgB;AAAA,EAC/C;AAAA,EAEA,oBAAoB,MAA6C;AAC/D,WAAO,KAAK,iBAAiB,oBAAoB,IAAI;AAAA,EACvD;AAAA,EAEA,QAAQ,QAA+B;AACrC,WAAO,KAAK,iBAAiB,QAAQ,MAAM;AAAA,EAC7C;AACF;;;ACpEO,IAAK,6BAAL,kBAAK,gCAAL;AACL,qEAAQ,KAAR;AACA,sEAAS,KAAT;AACA,0EAAa,KAAb;AAHU;AAAA;;;ACGL,IAAM,6BAAN,MAA+D;AAAA,EACpE,AAAmB;AAAA,EAInB,YAAY,YAAyG;AACnH,SAAK,aAAa,IAAI,IAAI,sBAAsB,MAAM,aAAa,OAAO,QAAQ,UAAU,CAAC;AAAA,EAC/F;AAAA,EAEA,YAAY,YAA2D;AACrE,WAAO,QAAQ,QAAQ,KAAK,WAAW,IAAI,UAAU,CAAC;AAAA,EACxD;AAAA,EAEA,YAAY,UAAoB;AAC9B,SAAK,WAAW,IAAI,SAAS,IAAI,QAAQ;AAAA,EAC3C;AAAA,EAEA,eAAe,YAA4B;AACzC,WAAO,KAAK,WAAW,OAAO,UAAU;AAAA,EAC1C;AACF;;;ACvBA,sBAAyB;AAMzB,IAAI,iBAA4B;AAChC,IAAM,oBAAoB,MAAM;AAC9B,MAAI,CAAC;AACH,qBAAiB,IAAI,mBAAG,WAAW;AAErC,SAAO;AACT;AAEA,IAAM,iBAAiB,CAAC,iBAAyF;AAC/G,QAAM,iBAAiB,mBAAW,sBAAsB,YAAY;AAEpE,MAAI,eAAe,WAAW,MAAM,eAAe,WAAW;AAC5D,UAAM,IAAI,MAAM,sBAAsB,cAAc;AAGtD,MAAI,IAAI,eAAe,WAAW,KAAK,KAAM,gBAAe,OAAQ,KAAK,eAAe;AACxF,MAAI,MAAM,KAAK,MAAM;AACnB,SAAK;AAEP,QAAM,SAAS;AAAA,IACb,GAAG,sBAAsB,eAAe,MAAM,GAAG,EAAE,CAAC;AAAA,IACpD,GAAG,sBAAsB,eAAe,MAAM,IAAI,EAAE,CAAC;AAAA,IACrD;AAAA,IACA,mBAAmB,IAAK,IAAI;AAAA,EAC9B;AAEA,SAAO;AACT;AAEO,IAAM,mBAAmB,CAAC,cAAsB,oBAA4B;AACjF,QAAM,oBAAoB,eAAe,YAAY;AAErD,QAAM,gBAAgB,0BAAO,KAAK,gBAAgB,WAAW,IAAI,IAAI,gBAAgB,UAAU,CAAC,IAAI,iBAAiB,KAAK;AAC1H,QAAM,cAAc,kBAAkB,EAAE,cACtC,eACA,EAAE,GAAG,kBAAkB,GAAG,GAAG,kBAAkB,EAAE,GACjD,kBAAkB,iBACpB;AAEA,SAAO,OAAO,YAAY,OAAO,OAAO,KAAK;AAC/C;;;ACxCO,IAAM,sBAAN,MAA2C;AAAA,EAKhD,YACW,eACU,MACnB;AAFS;AACU;AAAA,EAErB;AAAA,EANA,AAAS,aAAa;AAAA,EAQtB,MAAM,aAA8B;AAClC,UAAM,WAAW,MAAM,KAAK,KAAK,IAAI,YAAY;AACjD,UAAM,UAAU,SAAS;AACzB,QAAI,CAAC;AACH,YAAM,IAAI,MAAM,wBAAwB;AAE1C,WAAO;AAAA,EACT;AAAA,EAEA,eAAe;AACb,WAAO;AAAA,EACT;AAAA,EAEA,MAAM,KAAK,SAA2C;AACpD,UAAM,UAAU,MAAM,KAAK,WAAW;AACtC,UAAM,iBAAiB,MAAM,KAAK,aAAa,SAAS,OAAO;AAC/D,UAAM,iBAAiB,iBAAiB,gBAAgB,KAAK,KAAK,IAAI,SAAS,YAAY,OAAO,CAAC;AAEnG,WAAO;AAAA,MACL;AAAA,MACA,gBAAgB,eAAe,WAAW,IAAI,IAAI,eAAe,UAAU,CAAC,IAAI;AAAA,MAChF,gBAAgB,eAAe,UAAU,eAAe,WAAW,IAAI,IAAI,IAAI,GAAG,eAAe,SAAS,CAAC;AAAA,MAC3G,WAAW,oBAAmB;AAAA,IAChC;AAAA,EACF;AAAA,EAEA,AAAU,aAAa,SAAiB,SAAiB;AACvD,WAAO,IAAI,QAAgB,CAAC,SAAS,WAAW,KAAK,KAAK,IAAI,SAAS,KAAK,SAAS,SAAS,IAAI,CAAC,OAAO,cAAc;AACtH,aAAO,YAAY,QAAQ,SAAS,IAAI,OAAO,KAAK;AAAA,IACtD,CAAC,CAAC;AAAA,EACJ;AACF;AA1CO,IAAM,qBAAN;AACL,cADW,oBACK,oBAAmB;;;ACJ9B,IAAM,oCAAN,MAA6E;AAAA,EAClF,AAAmB,gBAAwC,oBAAI,IAAI;AAAA,EAEnE,aAAa,SAAiD;AAC5D,WAAO,QAAQ,QAAQ,KAAK,cAAc,IAAI,OAAO,CAAC;AAAA,EACxD;AAAA,EAEA,iBAAiB,WAA2C;AAC1D,WAAO,QAAQ,QACb,UAAU,OACR,CAAC,QAAQ,YAAY;AACnB,YAAM,YAAY,KAAK,cAAc,IAAI,OAAO;AAChD,UAAI;AACF,eAAO,KAAK,SAAS;AAEvB,aAAO;AAAA,IACT,GACA,CAAC,CACH,CACF;AAAA,EACF;AAAA,EAEA,gBAAgB,SAAiB,WAA0C;AACzE,SAAK,cAAc,IAAI,SAAS,SAAS;AAEzC,WAAO,QAAQ,QAAQ,SAAS;AAAA,EAClC;AAAA,EAIA,gBAAgB,oBAA0D;AACxE,UAAM,UAAU,OAAO,uBAAuB,WAC1C,qBACA,mBAAmB;AAEvB,WAAO,QAAQ,QAAQ,KAAK,cAAc,OAAO,OAAO,CAAC;AAAA,EAC3D;AACF;;;ACxCA,wBAA4B;;;ACA5B,oBAA+D;;;ACA/D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,oBAA2C;AAM3C,IAAM,gCAAgC;AACtC,IAAM,0BAA0B,CAAC,SAAiB,gBAAyB;AACzE,QAAM,eAAe,mBAAW,kBAAkB,OAAO;AACzD,QAAM,qBAAqB,cAAe,cAAc,eAAgB;AACxE,QAAM,gBAAgB,aAAU,SAAU,oBAAmB,SAAS,GAAG,SAAS,EAAE,GAAG,GAAG,GAAG;AAE7F,SAAO,SAAS,gBAAgB;AAClC;AAEO,IAAM,oBAAoB,CAAC,YAAoB,mBAAW,kBAAkB,OAAO;AACnF,IAAM,6BAA6B,CAAC,YAAoB,wBAAwB,OAAO;AACvF,IAAM,gCAAgC,CAAC,YAAoB,wBAAwB,SAAS,6BAA6B;AAEzH,IAAM,2BAA2B,CAAC,uBAA+B;AACtE,QAAM,UAAS,mBAAmB,UAAU,GAAG,mBAAmB,WAAW,IAAI,IAAI,IAAI,CAAC;AAE1F,UAAQ;AAAA,SACD,qBAAO;AAAA,SACP,qBAAO;AACV,aAAO;AAAA,SAEJ,qBAAO;AAAA,SACP,qBAAO;AACV,aAAO;AAAA,SAEJ,qBAAO;AAAA,SACP,qBAAO;AACV,aAAO;AAAA;AAGP,YAAM,IAAI,MAAM,yCAAyC,YAAW,qBAAqB;AAAA;AAE/F;AAEO,IAAM,kBAAkB,CAAC,cAAsB;AACpD,QAAM,kBAAmB,UAAU,WAAW,KAAK,IAC/C,UAAU,UAAU,GAAG,CAAC,IACxB,UAAU,UAAU,GAAG,CAAC;AAC5B,QAAM,kBAAkB,8BAAW,WAAW,qBAAO,gBAAgB;AAErE,SAAO,OAAO,KAAK,eAAe,EAAE,SAAS,KAAK;AACpD;;;AD3CO,IAAM,kBAAkB,CAAC,cAAsB;AACpD,QAAM,YAAY,8CAA2B,SAAS;AACtD,QAAM,kBAAkB,8BAAW,WAAW,qBAAO,UAAU;AAE/D,SAAO,0BAAO,KAAK,eAAe,EAAE,SAAS,KAAK;AACpD;;;ADAO,IAAM,0BAAN,MAAgD;AAAA,EAGrD,YACW,eACU,cACnB;AAFS;AACU;AAAA,EAErB;AAAA,EANA,AAAS,aAAa;AAAA,EAQtB,aAA8B;AAC5B,WAAO,KAAK,aAAa,OAAO;AAAA,EAClC;AAAA,EAEA,MAAM,eAA4C;AAtBpD;AAuBI,WAAQ,YAAM,KAAK,aAAa,OAAO,iBAAiB,MAAhD,mBAAoD;AAAA,EAC9D;AAAA,EAEA,MAAM,KAAK,SAA2C;AACpD,UAAM,CAAC,SAAS,WAAW,aAAa,MAAM,QAAQ,IAAI;AAAA,MACxD,KAAK,WAAW;AAAA,MAChB,KAAK,aAAa;AAAA,MAClB,KAAK,aAAa,OAAO,mBAAmB;AAAA,QAC1C,SAAS,gBAAa,8BAA8B,OAAO;AAAA,QAC3D,aAAa,8BAAY;AAAA,MAC3B,CAAC;AAAA,IACH,CAAC;AAED,QAAI,CAAC;AACH,YAAM,IAAI,MAAM,yCAAyC;AAE3D,UAAM,YAAY,gBAAa,yBAAyB,SAAS;AACjE,UAAM,iBAAiB,gBAAgB,SAAS;AAChD,UAAM,iBAAiB,gBAAgB,UAAU,SAAS;AAE1D,WAAO;AAAA,MACL;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA,iBAAiB;AAAA,IACnB;AAAA,EACF;AACF;;;AG3CO,IAAM,0BAAN,MAAgD;AAAA,EAGrD,YACW,eACU,cACnB;AAFS;AACU;AAAA,EAErB;AAAA,EANA,AAAS,aAAa;AAAA,EAQtB,aAA8B;AAC5B,WAAO,KAAK,aAAa,OAAO;AAAA,EAClC;AAAA,EAEA,eAAmC;AArBrC;AAsBI,WAAO,WAAK,aAAa,eAAlB,mBAA8B;AAAA,EACvC;AAAA,EAEA,MAAM,KAAK,SAA2C;AACpD,UAAM,CAAC,SAAS,WAAW,aAAa,MAAM,QAAQ,IAAI;AAAA,MACxD,KAAK,WAAW;AAAA,MAChB,KAAK,aAAa;AAAA,MAClB,KAAK,aAAa,KAAK,gBAAa,8BAA8B,OAAO,CAAC;AAAA,IAC5E,CAAC;AAED,QAAI,CAAC;AACH,YAAM,IAAI,MAAM,yCAAyC;AAE3D,UAAM,YAAY,gBAAa,yBAAyB,SAAS;AACjE,UAAM,iBAAiB,gBAAgB,SAAS;AAChD,UAAM,iBAAiB,gBAAgB,SAAS;AAEhD,WAAO;AAAA,MACL;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA,iBAAiB;AAAA,IACnB;AAAA,EACF;AACF;;;ACvCO,IAAM,oBAAN,MAA0C;AAAA,EAK/C,YACW,eACU,QACnB;AAFS;AACU;AAEnB,SAAK,iBAAiB,KAAK,qBAAqB;AAAA,EAClD;AAAA,EATA,AAAS,aAAa;AAAA,EAEtB,AAAmB;AAAA,EASnB,aAAuC;AACrC,WAAO,KAAK,eAAe,WAAW;AAAA,EACxC;AAAA,EAEA,eAAiE;AAC/D,WAAO,KAAK,eAAe,aAAa;AAAA,EAC1C;AAAA,EAEA,KAAK,SAA2C;AAC9C,WAAO,KAAK,eAAe,KAAK,OAAO;AAAA,EACzC;AAAA,EAEA,AAAU,uBAAuB;AAhCnC;AAiCI,QAAK,YAAK,OAAwB,WAA7B,mBAAqC,UAAS;AACjD,aAAO,IAAI,wBAAwB,KAAK,eAAgB,KAAK,MAAuB;AAAA,aAC5E,KAAK,OAAwB,eAAe,UAAc,KAAK,OAAwB,cAAc;AAC7G,aAAO,IAAI,wBAAwB,KAAK,eAAgB,KAAK,MAAuB;AAAA;AAEpF,YAAM,IAAI,MAAM,sBAAsB;AAAA,EAC1C;AACF;;;ACxCA,oBAA+B;AAMxB,IAAM,sBAAN,MAA4C;AAAA,EAKjD,YAAqB,eAA8B,WAAmB;AAAjD;AACnB,SAAK,yBAAyB,IAAI,6BAAe,SAAS;AAAA,EAC5D;AAAA,EANA,AAAS,aAAa;AAAA,EAEtB,AAAmB;AAAA,EAMnB,aAA8B;AAC5B,WAAO,KAAK,uBAAuB,cAAc;AAAA,EACnD;AAAA,EAEA,eAAgC;AAC9B,WAAO,KAAK,uBAAuB,UAAU;AAAA,EAC/C;AAAA,EAEA,MAAM,KAAK,SAA2C;AACpD,UAAM,eAAe,gBAAa,kBAAkB,OAAO;AAE3D,UAAM,CAAC,SAAS,WAAW,gBAAgB,MAAM,QAAQ,IAAI;AAAA,MAC3D,KAAK,WAAW;AAAA,MAChB,KAAK,aAAa;AAAA,MAClB,KAAK,uBAAuB,KAAK,YAAY;AAAA,IAC/C,CAAC;AAED,UAAM,iBAAiB,gBAAgB,SAAS;AAChD,UAAM,iBAAiB,aAAa,OAAO,UAAU,aAAa,MAAM,MAAM;AAC9E,UAAM,YAAY,gBAAa,yBAAyB,SAAS;AAEjE,WAAO;AAAA,MACL;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAAA,EACF;AACF;;;AC3CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACwBO,IAAM,UAAN,MAAa;AAAA,EAClB,AAAQ;AAAA,EACR,AAAQ;AAAA,EACR,AAAQ;AAAA,EACR,AAAQ;AAAA,EAER,YACE,SACA,SACA,WACA;AACA,SAAK,WAAW;AAChB,SAAK,WAAW;AAChB,SAAK,aAAa;AAAA,EACpB;AAAA,EAEA,OAAO,OAAO,SAAsD;AAClE,WAAO,IAAI,QACT,WAAW,YAAY,YAAY,WACnC,eAAO,IAAI,SAAS,OACtB;AAAA,EACF;AAAA,EAEA,wBAAwB,sBAA4C;AAClE,SAAK,wBAAwB;AAAA,EAC/B;AAAA,EAEA,AAAQ,kBAAkB,SAAiB;AAnD7C;AAoDI,UAAM,YAAY,WAAK,0BAAL,mBAA4B,aAAa;AAE3D,WAAO,uCAAW;AAAA,EACpB;AAAA,EASA,aAAa,WAAmB;AAC9B,SAAK,aAAa;AAAA,EACpB;AAAA,EAEA,MAAc,YACZ,QACA,MACA,OAAyB,OACzB,QACA,SACY;AACZ,UAAM,MAAM,IAAI,IAAI,MAAM,KAAK,QAAQ;AACvC,QAAI,WAAW,QAAW;AACxB,aAAO,KAAK,MAAM,EAAE,QAAQ,SAC1B,IAAI,aAAa,OAAO,KAAK,OAAO,IAAI,CAC1C;AAAA,IACF;AAEA,UAAM,UAAkC,CAAC;AACzC,QAAI,MAAM;AACR,YAAM,YAAY,OAAO,SAAS,WAAW,KAAK,kBAAkB,IAAI,IAAI,KAAK;AAEjF,UAAI,CAAC;AACH,cAAM,IAAI,MAAM,yBAAyB;AAE3C,cAAQ,mBAAmB,UAAU;AAAA,IACvC;AAEA,QAAI,OAAO;AACX,QAAI,WAAW,UAAU,YAAY,QAAW;AAC9C,aAAO,KAAK,UAAU,OAAO;AAC7B,cAAQ,kBAAkB;AAAA,IAC5B;AAEA,UAAM,WAAW,MAAM,MAAM,IAAI,SAAS,GAAG;AAAA,MAC3C;AAAA,MACA;AAAA,MACA;AAAA,IACF,CAAC;AACD,QAAI,SAAS,IAAI;AACf,aAAO,SAAS,KAAK;AAAA,IACvB,OAAO;AACL,YAAM,UAAU,MAAM,SAAS,KAAK;AACpC,YAAM,MAAM,OAAO;AAAA,IACrB;AAAA,EACF;AAAA,EAUA,MAAM,aACJ,aAC4B;AAC5B,WAAO,KAAK,YAAY,QAAQ,aAAa,OAAO,CAAC,GAAG,WAAW;AAAA,EACrE;AAAA,EAOA,MAAM,aAAoC;AACxC,WAAO,KAAK,YAAY,OAAO,eAAe,KAAK;AAAA,EACrD;AAAA,EAQA,MAAM,UAAU,YAA6C;AAC3D,UAAM,UACJ,eAAe,UAAa,WAAW,SAAS,IAC5C,WAAW,KAAK,GAAG,IACnB;AACN,WAAO,KAAK,YAAY,OAAO,yBAAyB,OAAO,EAAE,QAAQ,CAAC;AAAA,EAC5E;AAAA,EAQA,MAAM,aAAa,QAAoC;AACrD,WAAO,KAAK,YAAY,OAAO,uBAAuB,OAAO,EAAE,OAAO,CAAC;AAAA,EACzE;AAAA,EAQA,MAAM,SAAS,iBAAmD;AApKpE;AAqKI,UAAM,CAAC,YAAY,eAAe,KAAK,YACrC,gBAAgB,MAClB,EAAE,IAAI,OAAK,KAAK,kBAAkB,CAAC,CAAC;AACpC,UAAM,QAAe;AACrB,UAAM,aAAa;AAAA,MACjB,sBAAsB,WAAW;AAAA,MACjC,uBAAuB,YAAY;AAAA,MACnC,GAAG,MAAM;AAAA,IACX;AAEA,WAAO,KAAK,YACV,QACA,cACA,uBAAgB,eAAhB,mBAA4B,qBAAoB,MAChD,CAAC,GACD,KACF,EAAE,KAAK,SAAO,IAAI,UAAW;AAAA,EAC/B;AAAA,EASA,MAAM,UAAU,SAAkB,kBAAuD;AACvF,WAAO,KAAK,YAAY,OAAO,cAAc,WAAW,MAAM,EAAE,GAAG,iBAAiB,CAAC;AAAA,EACvF;AAAA,EASA,MAAM,SAAS,SAAiB,SAAkC;AAChE,WAAO,KAAK,YAAY,OAAO,cAAc,WAAW,WAAW,IAAI;AAAA,EACzE;AAAA,EAWA,MAAM,YACJ,SACA,QACA,MACA,SACkB;AAClB,WAAO,KAAK,YACV,UACA,cAAc,WACd,WAAW,MACX,EAAE,QAAQ,KAAK,CACjB,EAAE,KAAK,SAAO,IAAI,SAAU;AAAA,EAC9B;AAAA,EASA,MAAM,kBACJ,QACA,gBACkB;AAClB,WAAO,KAAK,YACV,QACA,aAAa,qBACb,kDAAgB,qBAAoB,MACpC,CAAC,GACD,cACF,EAAE,KAAK,SAAO,IAAI,SAAU;AAAA,EAC9B;AAAA,EAUA,MAAM,SAAS,SAAkB,iBAAoD;AACnF,WAAO,KAAK,YAAY,OAAO,aAAa,WAAW,MAAM,EAAE,GAAG,gBAAgB,CAAC;AAAA,EACrF;AAAA,EASA,MAAM,QAAQ,QAAgB,SAAiC;AAC7D,WAAO,KAAK,YAAY,OAAO,aAAa,UAAU,WAAW,IAAI;AAAA,EACvE;AAAA,EAUA,gBACE,WACA,MACA,QACA,WACc;AACd,UAAM,kBAAkB,UAAU,QAC/B,OAAO,WAAS;AACf,UAAI,MAAM,QAAQ,MAAM;AACtB,eAAO;AAAA,MACT;AACA,YAAM,eAAe,MAAM;AACzB,gBAAQ,OAAO;AAAA,eACR;AAAA,eACA;AACH,mBAAO,SAAS,MAAM;AAAA;AAEtB,mBAAO;AAAA;AAAA,MAEb;AACA,aAAO,aAAa,KAAK,KAAK,IAAI,GAAG,MAAM,UAAU;AAAA,IACvD,CAAC,EACA,IAAI,WAAS,MAAM,KAAK;AAE3B,QAAI,gBAAgB,UAAU,GAAG;AAC/B,YAAM,IAAI,MACR,4BAA4B,aAAa,YAAY,OACvD;AAAA,IACF;AAEA,UAAM,YACJ,QAAQ,QACJ,KAAK,IAAI,GAAG,eAAe,IAC3B,KAAK,IAAI,GAAG,eAAe;AACjC,UAAM,oBAAoB,MAAM;AAC9B,cAAQ,OAAO;AAAA,aACR;AAAA,aACA;AACH,iBAAO,SAAS;AAAA;AAEhB,iBAAO,SAAS;AAAA;AAAA,IAEtB;AACA,WAAO;AAAA,MACL,OAAO;AAAA,MACP,YAAY,aAAa,SAAS,SAAS,kBAAkB;AAAA,MAC7D,gBAAgB,aAAa,YAAY,SAAS,kBAAkB;AAAA,IACtE;AAAA,EACF;AAAA,EAOA,YAAY,QAA+D;AACzE,UAAM,CAAC,cAAc,iBAAiB,OAAO,MAAM,KAAK,CAAC;AACzD,QAAI,CAAC,gBAAgB,CAAC;AACpB,YAAM,IAAI,MAAM,mBAAmB;AAErC,WAAO,CAAC,cAAc,aAAa;AAAA,EACrC;AAAA,EAOA,kBAAkB,UAAkC;AAClD,UAAM,gBAAgB,OAAO,QAAQ,eAAO,UAAU,EAAE,KACtD,CAAC,CAAC,GAAG,QAAQ,KAAK,QACpB;AACA,QAAI,iBAAiB,QAAW;AAC9B,YAAM,IAAI,MAAM,kCAAkC,UAAU;AAAA,IAC9D;AACA,WAAO;AAAA,MACL,YAAY,cAAc,GAAG;AAAA,MAC7B,UAAU,cAAc,GAAG,SAAS;AAAA,MACpC,iBAAiB,cAAc,GAAG,SAAS;AAAA,MAC3C,iBAAiB,cAAc,GAAG,UAAU,KAAK,UAAU;AAAA,MAE3D,cAAe,cAAc,GAAG,UAAU,KAAK,UAAkB;AAAA,IACnE;AAAA,EACF;AAAA,EAQA,aAAa,QAAyB,UAA0B;AAC9D,UAAM,MAAM,KAAK,kBAAkB,QAAQ;AAC3C,WAAO,OAAO,WAAW,WACrB,WAAW,WAAW,MAAM,EAAE,QAAQ,IAAI,eAAe,CAAC,IAC1D,WAAW,OAAO,QAAQ,IAAI,eAAe,CAAC;AAAA,EACpD;AAAA,EASA,aACE,QACA,cACA,YACM;AACN,UAAM,CAAC,cAAc,iBAAiB,KAAK,YAAY,MAAM;AAE7D,QAAI,iBAAiB,gBAAgB,kBAAkB;AACrD,aAAO;AAET,QAAI,kBAAkB,gBAAgB,iBAAiB;AACrD,aAAO;AAET,UAAM,IAAI,MAAM,YAAY,mBAAmB,eAAe,SAAS;AAAA,EACzE;AAAA,EAQA,gBAAgB,WAAsB,MAAoB;AACxD,WAAO,KAAK,IACV,GAAG,UAAU,QACV,OAAO,WAAS,MAAM,QAAQ,IAAI,EAClC,IAAI,WAAS,KAAK,IAAI,GAAG,MAAM,UAAU,CAAC,CAC/C;AAAA,EACF;AACF;;;AC7ZA,uBAAqB;AACrB,kBAAiB;;;ACMV,IAAe,UAAf,MAAuB;AAqH9B;AAEO,IAAM,QAAQ,CAAC,YACpB,KAAK,MAAM,IAAI,KAAK,OAAO,EAAE,QAAQ,IAAI,GAAI;AAExC,IAAM,MAAM,MAAc,KAAK,MAAM,KAAK,IAAI,IAAI,GAAI;;;ADzGtD,IAAM,kBAAN,cAA8B,QAAQ;AAAA,EAC3C,AAAQ;AAAA,EACR,AAAQ;AAAA,EACR,AAAQ;AAAA,EACR,AAAQ;AAAA,EACR,AAAQ;AAAA,EAER,YACE,MACA,eACA,iBACA,mBACA,UACA;AACA,UAAM;AACN,SAAK,QAAQ;AACb,SAAK,YAAY,IAAI,KAAK,IAAI,SAAS,eAAe,eAAe;AACrE,SAAK,qBAAqB;AAC1B,SAAK,YAAY;AACjB,SAAK,aAAa,oBAAI,IAAsB;AAC5C,kBAAc,QAAQ,UAAQ;AAC5B,UAAI,KAAK,SAAS,YAAY;AAC5B,aAAK,WAAW,IAAI,KAAK,MAAO;AAAA,UAC9B,OAAO,KAAK;AAAA,UACZ,WAAW,KAAK,IAAI,IAAI,wBAAwB,IAAe;AAAA,QACjE,CAAC;AAAA,MACH;AAAA,IACF,CAAC;AAAA,EACH;AAAA,EASA,aAAa,OACX,SACA,QAC0B;AAC1B,UAAM,kBAAkB,eAAO,YAAY,SAAS,IAAI;AACxD,QAAI,WAAW,QAAW;AACxB,sBAAgB,MAAM;AAAA,IACxB;AAEA,UAAM,OAAO,IAAI,oBAAK,gBAAgB,GAAG;AACzC,UAAM,UAAU,MAAM,KAAK,IAAI,WAAW;AAC1C,QAAI,gBAAgB,YAAY,SAAS;AACvC,YAAM,IAAI,MACR,4BAA4B,gBAAgB,mBAAmB,SACjE;AAAA,IACF;AAEA,WAAO,IAAI,gBACT,MACA,eAAO,WAAW,IAAI,UAAU,KAChC,eAAO,WAAW,IAAI,UAAU,SAAS,SACzC,gBAAgB,WAChB,eAAO,WAAW,IAAI,UAAU,SAAS,QAC3C;AAAA,EACF;AAAA,EAEA,eAAe,SAAiB,UAAgC;AAC9D,UAAM,YAAY,KAAK,IAAI;AAC3B,WAAO;AAAA,MACL;AAAA,MACA,WAAW;AAAA,MACX,WAAW,UAAU,UAAU,SAAS;AAAA,MACxC,WAAW;AAAA,IACb;AAAA,EACF;AAAA,EAEA,yBACE,oBACwB;AACxB,QAAI,mBAAmB,kBAAkB,IAAI,GAAG;AAC9C,YAAM,IAAI,MACR,kCAAkC,mBAAmB,iBACvD;AAAA,IACF;AAEA,UAAM,OAAe,KAAK,UAAU,QACjC,SACC,OAAO,mBAAmB,YAC1B,mBAAmB,kBACnB,mBAAmB,iBACnB,mBAAmB,eACrB,EACC,UAAU;AACb,WAAO;AAAA,MACL;AAAA,MACA,cAAc,KAAK,UAAU,QAAQ;AAAA,MACrC,QAAQ,mBAAmB,YAAY,mBAAmB;AAAA,IAC5D;AAAA,EACF;AAAA,EAEA,uBACE,QACA,cACwB;AACxB,UAAM,OAAO,KAAK,UAAU,QACzB,OAAO,cAAc,MAAM,EAC3B,UAAU;AACb,WAAO;AAAA,MACL;AAAA,MACA,cAAc,KAAK,UAAU,QAAQ;AAAA,IACvC;AAAA,EACF;AAAA,EAEA,uBAAuB,YAA4C;AACjE,UAAM,OAAO,KAAK,UAAU,QAAQ,OAAO,UAAU,EAAE,UAAU;AACjE,WAAO;AAAA,MACL;AAAA,MACA,cAAc,KAAK,UAAU,QAAQ;AAAA,IACvC;AAAA,EACF;AAAA,EAEA,oBACE,YACA,QACwB;AACxB,UAAM,OAAO,KAAK,UAAU,QAAQ,IAAI,UAAU,EAAE,UAAU;AAC9D,WAAO;AAAA,MACL;AAAA,MACA,cAAc,KAAK,UAAU,QAAQ;AAAA,MACrC;AAAA,IACF;AAAA,EACF;AAAA,EAQA,yBAAyB,YAA4C;AACnE,UAAM,OAAe,KAAK,UAAU,QACjC,SAAS,UAAU,EACnB,UAAU;AACb,WAAO;AAAA,MACL;AAAA,MACA,cAAc,KAAK,UAAU,QAAQ;AAAA,IACvC;AAAA,EACF;AAAA,EAEA,wBAAwB,aAA8C;AACpE,UAAM,iBAAiB,KAAK,WAAW,IAAI,UAAU;AAErD,QAAI,CAAC,YAAY,MAAM,WAAW,eAAe,SAAS,GAAG;AAC3D,YAAM,IAAI,MAAM,gCAAgC,YAAY,OAAO;AAAA,IACrE;AAEA,UAAM,SAAS,KAAK,MAAM,IAAI,IAAI,iBAChC,eAAe,OACf,YAAY,MAAM,MAAM,eAAe,UAAU,MAAM,CACzD;AAEA,WAAO;AAAA,MACL,YAAY,OAAO,iBAAiB,MAAM,CAAC;AAAA,MAC3C,kBAAkB,OAAO;AAAA,MACzB,iBAAiB,SAAS,OAAO,mBAAmB;AAAA,MACpD,iBAAiB,SACf,KAAK,MAAM,MAAM,KAAK,OAAO,UAAU,EAAE,SAAS,CACpD;AAAA,MACA,WAAW,SACT,KAAK,MAAM,MACR,KAAK,YAAY,KAAK,EACtB,IAAI,KAAK,MAAM,MAAM,KAAK,OAAO,UAAU,CAAC,EAC5C,SAAS,CACd;AAAA,IACF;AAAA,EACF;AAAA,EAEA,MAAM,4BACJ,cACA,MACA,YACA,kBACA,QACA,QACA,oBACA,mBAAmB,GACa;AAChC,UAAM,YAAY,SAAS;AAC3B,UAAM,cAAc,MAAM,KAAK,MAAM,IAAI,eAAe,IAAI;AAE5D,QAAI;AACF,UAAI,gBAAgB,QAAW;AAC7B,cAAM,IAAI,MAAM,mCAAmC,MAAM;AAAA,MAC3D;AAEA,UAAI,YAAY,OAAO,KAAK,UAAU,QAAQ,SAAS;AACrD,cAAM,IAAI,MAAM,2BAA2B,YAAY,IAAI;AAAA,MAC7D;AAEA,YAAM,qBAAqB,KAAK,wBAAwB,WAAW;AACnE,UAAI,mBAAmB,eAAe,YAAY;AAChD,cAAM,IAAI,MACR,uBAAuB,sBAAsB,mBAAmB,YAClE;AAAA,MACF;AAEA,UAAI,mBAAmB,iBAAiB,YAAY,MAAM,iBAAiB,YAAY,GAAG;AACxF,cAAM,IAAI,MACR,6BAA6B,4BAA4B,mBAAmB,kBAC9E;AAAA,MACF;AAEA,UAAI,mBAAmB,cAAc,WAAW;AAC9C,cAAM,IAAI,MACR,sBAAsB,qBAAqB,mBAAmB,WAChE;AAAA,MACF;AAEA,UAAI,mBAAmB,kBAAkB,oBAAoB;AAC3D,cAAM,IAAI,MACR,6BAA6B,8BAA8B,mBAAmB,iBAChF;AAAA,MACF;AAAA,IACF,SAAS,GAAP;AACA,aAAO;AAAA,QACL,QAAQ;AAAA,QACR,SAAS,EAAE;AAAA,QACX,eAAe;AAAA,QACf,cAAc;AAAA,MAChB;AAAA,IACF;AAEA,UAAM,cAAc,MAAM,KAAK,MAAM,IAAI,SAAS,QAAQ;AAC1D,UAAM,gBACJ,YAAY,SAAU,aAAY,eAAe,YAAY;AAE/D,UAAM,MAA6B;AAAA,MACjC,QAAQ,YAAY,gBAAgB,SAAY,aAAa;AAAA,MAC7D;AAAA,MACA,cACE,SAAS,YAAY,UAAU,SAAS,CAAC,IAAI,KAAK;AAAA,IACtD;AAEA,QAAI,iBAAiB,kBAAkB;AACrC,UAAI,SAAS;AAAA,IACf;AAEA,WAAO;AAAA,EACT;AAAA,EAEA,AAAQ,SAAS,GAAW,GAAW,IAAY;AACjD,WAAO,OAAO,GAAG,MAAM,IAAI,IAAI,GAAG,IAAI,IAAI,CAAC;AAAA,EAC7C;AAAA,EAEA,AAAQ,OAAO,WAAmB;AAChC,UAAM,OAAO;AAAA,MACX,KAAK,SAAS,IAAK,WAAU,SAAS,KAAK,GAAG,SAAS;AAAA,MACvD,KAAK,SAAS,GAAG,IAAI,SAAS;AAAA,MAC9B,KAAK,SAAS,IAAI,IAAI,SAAS;AAAA,IACjC;AAEA,WAAO;AAAA,MACL,GAAG,SAAS,KAAK,GAAG,MAAM,CAAC,GAAG,EAAE;AAAA,MAChC,GAAG,KAAK,GAAG,MAAM,CAAC;AAAA,MAClB,GAAG,KAAK,GAAG,MAAM,CAAC;AAAA,IACpB;AAAA,EACF;AAAA,EASA,iBAAiB,KAAa,WAAmB;AAC/C,UAAM,OAAO,KAAK,MAAM,IAAI,SAAS,YAAY,GAAG;AACpD,UAAM,MAAM,KAAK,OAAO,SAAS;AACjC,UAAM,YAAY,IAAI,yBAAS,GAAG,WAAW;AAC7C,UAAM,cAAc,UAAU,cAC5B,OAAO,KAAK,KAAK,MAAM,CAAC,GAAG,KAAK,GAChC,KACA,IAAI,IAAI,IAAI,IAAI,IAAI,IAAK,IAAI,IAAI,CACnC;AACA,WAAO,OAAO,YAAY,OAAO,OAAO,KAAK;AAAA,EAC/C;AAAA,EAEA,gBAAgB,QAAwB;AACtC,QAAI,OAAO,WAAW,IAAI,GAAG;AAC3B,aAAO,OAAO,MAAM,CAAC;AAAA,IACvB;AACA,WAAO;AAAA,EACT;AAAA,EAEA,gBAAgB,WAA2B;AACzC,UAAM,MAAM,KAAK,OAAO,SAAS;AACjC,WAAO,IAAI,EAAE,SAAS,IAAI,GAAG,IAAI,IAAI,EAAE,SAAS,IAAI,GAAG;AAAA,EACzD;AAAA,EAEA,MAAM,qBAAqB,QAAiC;AAC1D,UAAM,UAAU;AAAA,MACd,kBAAkB;AAAA,MAClB,YACE;AAAA,MACF,iBAAiB;AAAA,MACjB,iBAAiB;AAAA,MACjB,WAAW;AAAA,IACb;AACA,UAAM,SAAS,KAAK,yBAAyB,OAAO;AACpD,UAAM,WAAW,MAAM,KAAK,MAAM,IAAI,YAAY;AAClD,UAAM,cAAc,MAAM,KAAK,MAAM,IAAI,YAAY;AAAA,MACnD,MAAM;AAAA,MACN,IAAI,OAAO;AAAA,MACX,MAAM,OAAO;AAAA,MACb,OAAO,OAAO;AAAA,IAChB,CAAC;AACD,UAAM,MAAM,SAAS,QAAQ,IAAI;AACjC,WAAO;AAAA,EACT;AAAA,EAEA,MAAM,mBAAmB,YAAyC;AAChE,UAAM,WAAW,MAAM,KAAK,MAAM,IAAI,YAAY;AAClD,UAAM,MAAM,SAAS,QAAQ,IAAI,KAAK;AACtC,WAAO;AAAA,MACL,WAAW;AAAA,MACX,iBAAiB,IAAI;AAAA,IACvB;AAAA,EACF;AAAA,EAEA,eAAe,SAA0B;AACvC,WAAO,KAAK,MAAM,MAAM,UAAU,OAAO;AAAA,EAC3C;AACF;;;AElWA,+BAAgC;AAChC,iBAIO;AACP,qBAA6B;AAC7B,qBAKO;AAeP,IAAM,kBAAkB,CAAC,cAAsB;AAC7C,SAAO,IAAI,KAAK,YAAY,GAAI,EAAE,YAAY,EAAE,MAAM,GAAG,EAAE,IAAI;AACjE;AAKO,IAAM,eAAN,cAA2B,QAAQ;AAAA,EACxC,AAAU;AAAA,EACV,AAAU;AAAA,EACV,AAAU;AAAA,EACV,AAAU;AAAA,EACV,AAAU;AAAA,EACV,AAAU;AAAA,EACV,AAAU;AAAA,EACV,AAAU;AAAA,EACV,AAAU;AAAA,EACV,AAAU;AAAA,EACV,AAAU;AAAA,EAEV,YACE,OACA,aACA,iBACA,mBACA,UACA,aACA,0BACA,uBACA,aACA,cACA,gBACA;AACA,UAAM;AACN,SAAK,SAAS;AACd,SAAK,mBAAmB;AACxB,SAAK,qBAAqB;AAC1B,SAAK,YAAY;AACjB,SAAK,eAAe;AACpB,SAAK,4BAA4B;AACjC,SAAK,yBAAyB;AAC9B,SAAK,eAAe;AACpB,SAAK,gBAAgB;AACrB,SAAK,kBAAkB;AACvB,SAAK,eAAe,IAAI,IACtB,OAAO,QAAQ,WAAW,EAAE,IAAI,CAAC,CAAC,MAAM,cAAc;AACpD,aAAO,CAAC,MAAM,IAAI,yCAAgB,QAAQ,CAAC;AAAA,IAC7C,CAAC,CACH;AAAA,EACF;AAAA,EAUA,aAAa,OACX,SACA,WAA+B,OAC/B,QACuB;AACvB,UAAM,kBAAkB,eAAO,YAAY,MAAM,IAAI;AACrD,QAAI,WAAW,QAAW;AACxB,sBAAgB,MAAM;AAAA,IACxB;AAEA,UAAM,QAAQ,IAAI,4BAAa,gBAAgB,GAAG;AAClD,UAAM,UAAU,MAAM,MAAM,IAAI,WAAW;AAC3C,QAAI,gBAAgB,YAAY,QAAQ,SAAS,GAAG;AAClD,YAAM,IAAI,MACR,4BAA4B,gBAAgB,mBAAmB,SACjE;AAAA,IACF;AAEA,WAAO,IAAI,aACT,OACA,eAAO,WAAW,UAAU,UAAU,aACtC,eAAO,WAAW,UAAU,UAAU,SAAS,SAC/C,eAAO,YAAY,MAAM,IAAI,SAAS,WACtC,eAAO,WAAW,UAAU,UAAU,SAAS,UAC/C,eAAO,YAAY,MAAM,IAAI,SAAS,aACtC,eAAO,YAAY,MAAM,IAAI,SAAS,0BACtC,eAAO,YAAY,MAAM,IAAI,SAAS,uBACtC,eAAO,YAAY,MAAM,IAAI,SAAS,aACtC,eAAO,WAAW,UAAU,UAAU,SAAS,cAC/C,eAAO,WAAW,UAAU,UAAU,SAAS,cACjD;AAAA,EACF;AAAA,EAEA,AAAQ,kBAAkB,SAA4B;AACpD,YAAQ;AAAA,WACD;AACH,eAAO;AAAA,WACJ;AACH,eAAO;AAAA,WACJ;AACH,eAAO;AAAA;AAEP,cAAM,IAAI,MAAM,8BAA8B,SAAQ;AAAA;AAAA,EAE5D;AAAA,EAEA,eAAe,SAAiB,SAA8B;AAC5D,UAAM,YAAY,KAAK,IAAI;AAC3B,WAAO;AAAA,MACL;AAAA,MACA,WAAW;AAAA,MACX,WAAW,UAAU,UAAU,SAAS;AAAA,MACxC,WAAW,KAAK,kBAAkB,QAAQ,MAAM,GAAG,CAAC,CAAC;AAAA,IACvD;AAAA,EACF;AAAA,EAEA,yBACE,oBACwB;AAhJ5B;AAiJI,QAAI,mBAAmB,kBAAkB,IAAI,GAAG;AAC9C,YAAM,IAAI,MACR,kCAAkC,mBAAmB,iBACvD;AAAA,IACF;AAEA,UAAM,YAAY,WAAK,aACpB,IAAI,UAAU,MADC,mBAEd,OACA,mBAAmB,kBACnB,mBAAmB,YACnB,gBAAgB,mBAAmB,eAAe,GAClD,mBAAmB;AAEvB,WAAO;AAAA,MACL,MAAM;AAAA,QACJ,YAAY;AAAA,QACZ,OAAO;AAAA,MACT;AAAA,MACA,cAAc,KAAK;AAAA,MACnB,QAAQ,mBAAmB,YAAY,mBAAmB;AAAA,IAC5D;AAAA,EACF;AAAA,EAEA,uBACE,QACA,gBAAgB,IACQ;AA5K5B;AA6KI,WAAO;AAAA,MACL,MAAM;AAAA,QACJ,YAAY;AAAA,QACZ,OAAO,WAAK,aAAa,IAAI,QAAQ,MAA9B,mBAAiC,OAAO;AAAA,MACjD;AAAA,MACA,cAAc,KAAK;AAAA,IACrB;AAAA,EACF;AAAA,EAEA,uBAAuB,YAA4C;AAtLrE;AAuLI,WAAO;AAAA,MACL,MAAM;AAAA,QACJ,YAAY;AAAA,QACZ,OAAO,WAAK,aAAa,IAAI,QAAQ,MAA9B,mBAAiC,OAAO;AAAA,MACjD;AAAA,MACA,cAAc,KAAK;AAAA,IACrB;AAAA,EACF;AAAA,EAEA,oBACE,YACA,QACwB;AAnM5B;AAoMI,WAAO;AAAA,MACL;AAAA,MACA,MAAM;AAAA,QACJ,YAAY;AAAA,QACZ,OAAO,WAAK,aAAa,IAAI,KAAK,MAA3B,mBAA8B,OAAO;AAAA,MAC9C;AAAA,MACA,cAAc,KAAK;AAAA,IACrB;AAAA,EACF;AAAA,EAQA,gBAAgB,OAAsB;AACpC,WAAO;AAAA,MACL,OAAO,MAAM,SAAS,WAAY;AAAA,MAClC,WAAW,MAAM,MAAM,OAAO,SAAS;AAAA,IACzC;AAAA,EACF;AAAA,EAEA,wBACE,SACoB;AA7NxB;AA8NI,QAAI,QAAQ,eAAe,QAAW;AACpC,YAAM,IAAI,MAAM,0BAA0B;AAAA,IAC5C;AAEA,UAAM,SAAS,WAAK,aACjB,IAAI,QAAQ,WAAW,UAAU,MADrB,mBAEX,QAAQ,QAAQ,WAAW;AAC/B,QAAI,WAAW,QAAW;AACxB,YAAM,IAAI,MACR,0BAA0B,QAAQ,WAAW,YAC/C;AAAA,IACF;AAEA,UAAM,iBAAkB,OAAM;AAC5B,cAAQ,QAAQ,WAAW;AAAA,aACpB;AACH,iBAAO;AAAA,aACJ;AAAA,aACA;AACH,iBAAO,OAAO;AAAA;AAEd,gBAAM,IAAI,MACR,0BAA0B,QAAQ,WAAW,YAC/C;AAAA;AAAA,IAEN,GAAG;AAEH,WAAO;AAAA,MACL,YAAY,eAAe,YAAY;AAAA,MACvC,kBAAkB,eAAe;AAAA,MACjC,iBAAiB,MAAM,eAAe,YAAY,cAAc;AAAA,MAChE,WACE,SAAS,QAAQ,MAAM,IACvB,SAAS,eAAe,YAAY,SAAS;AAAA,MAC/C,iBAAiB,SAAS,eAAe,YAAY,SAAS;AAAA,IAChE;AAAA,EACF;AAAA,EAEA,iBACE,OACA,MACyC;AAvQ7C;AAwQI,UAAM,MAAM,YAAM,WAAW,OAAjB,mBAAqB,KAAK,UAAO,KAAI,QAAQ;AACzD,QAAI,QAAQ,QAAW;AACrB,YAAM,IAAI,MAAM,wBAAwB,UAAU,MAAM,MAAM;AAAA,IAChE;AAEA,UAAM,WACJ,IAAI,SAAS,OAAO,OAAK,EAAE,QAAQ,iBAAiB,EAAE,eAAe,KAAK,gBAAgB;AAE5F,QAAI,SAAS,WAAW,GAAG;AACzB,YAAM,IAAI,MAAM,sCAAsC;AAAA,IACxD;AAEA,WAAO;AAAA,EACT;AAAA,EAEA,MAAM,4BACJ,aACA,MACA,YACA,kBACA,QACA,QACA,oBACA,mBAAmB,GACa;AAChC,UAAM,YAAY,SAAS;AAC3B,UAAM,QAAQ,MAAM,KAAK,OAAO,IAAI,SAAS;AAAA,MAC3C,OAAO,YAAY,SAAS;AAAA,IAC9B,CAAC;AAED,QAAI;AACF,YAAM,KAAK,KAAK,iBAAiB,OAAO,IAAI,EAAE,KAAK,aAAW;AAC5D,cAAM,qBAAqB,KAAK,wBAAwB,OAAO;AAC/D,YAAI,mBAAmB,eAAe,YAAY;AAChD,kBAAQ,IAAI,IAAI,QAAQ,gCAAgC,sBAAsB,mBAAmB,YAAY;AAC7G,iBAAO;AAAA,QACT;AAEA,YAAI,mBAAmB,iBAAiB,YAAY,MAAM,iBAAiB,YAAY,GAAG;AACxF,kBAAQ,IAAI,IAAI,QAAQ,sCAAsC,4BAA4B,mBAAmB,kBAAkB;AAC/H,iBAAO;AAAA,QACT;AAEA,YAAI,mBAAmB,cAAc,WAAW;AAC9C,kBAAQ,IAAI,IAAI,QAAQ,+BAA+B,qBAAqB,mBAAmB,WAAW;AAC1G,iBAAO;AAAA,QACT;AAEA,YAAI,mBAAmB,kBAAkB,oBAAoB;AAC3D,kBAAQ,IAAI,IAAI,QAAQ,sCAAsC,8BAA8B,mBAAmB,iBAAiB;AAChI,iBAAO;AAAA,QACT;AAEA,eAAO;AAAA,MACT,GAAG,IAAI;AAEP,UAAI,OAAO,QAAW;AACpB,cAAM,IAAI,MAAM,6EAA6E,eAAe;AAAA,MAC9G;AAAA,IACF,SAAS,GAAP;AACA,aAAO;AAAA,QACL,QAAQ;AAAA,QACR,SAAS,EAAE;AAAA,QACX,eAAe;AAAA,QACf,cAAc;AAAA,MAChB;AAAA,IACF;AAEA,UAAM,cAAc,KAAK,gBACvB,MAAM,KAAK,OAAO,IAAI,SAAS,EAAE,OAAO,OAAO,CAAC,CAClD;AACA,UAAM,iBAAiB,KAAK,gBAAgB,KAAK;AACjD,UAAM,gBAAgB,YAAY,QAAS,eAAe;AAE1D,UAAM,MAA6B;AAAA,MACjC,QAAQ;AAAA,MACR;AAAA,MACA,cAAc,YAAY,YAAY,KAAK;AAAA,IAC7C;AAEA,QAAI,iBAAiB,kBAAkB;AACrC,UAAI,SAAS;AAAA,IACf;AAEA,WAAO;AAAA,EACT;AAAA,EAEA,gBAAgB,QAAwB;AACtC,UAAM,QAAQ,OAAO,UAAU,GAAG,CAAC;AACnC,YAAQ;AAAA,WACD;AACH,eAAO,OAAO,KAAK,+BAAW,QAAQ,sBAAO,OAAO,CAAC,EAAE,SAAS,KAAK;AAAA,WAClE;AACH,eAAO,OAAO,KAAK,+BAAW,QAAQ,sBAAO,OAAO,CAAC,EAAE,SAAS,KAAK;AAAA,WAClE;AACH,eAAO,OAAO,KAAK,+BAAW,QAAQ,sBAAO,OAAO,CAAC,EAAE,SAAS,KAAK;AAAA;AAErE,cAAM,IAAI,MAAM,6BAA6B;AAAA;AAAA,EAEnD;AAAA,EAEA,gBAAgB,WAA2B;AA7W7C;AA8WI,UAAM,OAAO,UAAU,WAAW,KAAK,IACnC,UAAU,UAAU,GAAG,CAAC,IACxB,UAAU,UAAU,GAAG,CAAC;AAC5B,QAAI,OAAO,UAAU,eAAe,KAAK,uBAAQ,IAAI,GAAG;AACtD,aAAO,OAAO,KACZ,+BACE,WACA,aAAO,yBAAyB,uBAAQ,IAAI,MAA5C,mBAA+C,KACjD,CACF,EAAE,SAAS,KAAK;AAAA,IAClB;AACA,UAAM,IAAI,MAAM,4BAA4B;AAAA,EAC9C;AAAA,EAEA,SAAS,MAAM,GAAG,cAAc,GAAG,SAAS,GAAW;AACrD,WACE,KAAK,eACL,KAAK,4BAA4B,MACjC,KAAK,yBAAyB,SAC9B,cAAc,KAAK;AAAA,EAEvB;AAAA,EAEA,MAAM,qBAAqB,QAAiC;AAC1D,UAAM,UAAU;AAAA,MACd,kBAAkB;AAAA,MAClB,YACE;AAAA,MACF,iBAAiB;AAAA,MACjB,iBAAiB;AAAA,MACjB,WAAW;AAAA,IACb;AAEA,UAAM,KAAK,KAAK,yBAAyB,OAAO;AAEhD,UAAM,SAAS,MAAM,KAAK,OAAO,IAAI,eAAe;AACpD,UAAM,WAAW,MAAM,KAAK,OAAO,IAAI,YAAY,MAAM;AACzD,UAAM,KAAK,MAAM,KAAK,OAAO,IAAI,aAAa;AAAA,MAC5C,UAAU,OAAO;AAAA,MACjB,WAAW;AAAA,QACT,QAAQ,OAAO;AAAA,QACf,WACE;AAAA,QACF,UAAU;AAAA,UACR;AAAA,YACE,QAAQ;AAAA,YACR,SAAU,UAAS,SAAS,WAAW,GAAG,IAAI,GAAG,SAAS;AAAA,YAC1D,aAAa,KAAK;AAAA,YAClB,KAAK,KAAK,SAAS,OAAS,KAAO,KAAK,eAAe,EAAE,SAAS;AAAA,YAClE,WAAW;AAAA,YACX,MAAM,kBAAO;AAAA,YACb;AAAA,YACA,eAAe;AAAA,YACf,YAAY,GAAG;AAAA,UACjB;AAAA,QACF;AAAA,MACF;AAAA,IACF,CAAC;AAED,QAAI,kBAAkB,GACpB,cAAc;AAChB,IAAC,GAAG,SAAqD,QAAQ,SAAM;AACrE,UAAI,IAAG,SAAS,iBAAiB,WAAW,WAAW;AACrD,cAAM,IAAI,MAAM,kDAAkD;AAAA,MACpE;AACA,qBAAe,SAAS,IAAG,SAAS,iBAAiB,gBAAgB,GAAG;AACxE,yBAAmB,SACjB,IAAG,SAAS,iBAAiB,0BAA0B,GACzD;AAAA,IACF,CAAC;AAED,WAAO,KAAK,SAAS,aAAa,iBAAiB,KAAK,eAAe;AAAA,EACzE;AAAA,EAEA,MAAM,mBAAmB,WAAwC;AAC/D,QAAI,OAAO,KAAK,SAAS,KAAK,WAAW,GAAG,KAAK,aAAa;AAC9D,UAAM,cAAc,MAAM,KAAK,OAAO,IAAI,cAAc,SAAS;AACjE,QAAI,gBAAgB,MAAM;AACxB,cAAQ,MAAM,KAAK;AAAA,IACrB;AACA,WAAO;AAAA,MACL,WAAW;AAAA,MACX,iBAAiB,IAAI;AAAA,IACvB;AAAA,EACF;AAAA,EAEA,eAAe,SAA0B;AACvC,WAAO,oCAAgB,OAAO,KAAK,gCAAiB;AAAA,EACtD;AACF;;;ACtcA,sBAA6B;AAWtB,IAAM,cAAN,cAA0B,aAAa;AAAA,EAU5C,aAAa,OACX,SACA,UACA,QACuB;AACvB,UAAM,kBAAkB,eAAO,YAAY,MAAM,IAAI;AACrD,QAAI,WAAW,QAAW;AACxB,sBAAgB,MAAM;AAAA,IACxB;AAEA,UAAM,QAAQ,IAAI,6BAAa,gBAAgB,GAAG;AAClD,UAAM,UAAU,MAAM,MAAM,IAAI,WAAW;AAC3C,QAAI,gBAAgB,YAAY,QAAQ,SAAS,GAAG;AAClD,YAAM,IAAI,MACR,4BAA4B,gBAAgB,mBAAmB,SACjE;AAAA,IACF;AAEA,WAAO,IAAI,YACT,OACA,eAAO,WAAW,UAAU,UAAU,aACtC,eAAO,WAAW,UAAU,UAAU,SAAS,SAC/C,eAAO,YAAY,MAAM,IAAI,SAAS,WACtC,eAAO,WAAW,UAAU,UAAU,SAAS,UAC/C,eAAO,YAAY,MAAM,IAAI,SAAS,aACtC,eAAO,YAAY,MAAM,IAAI,SAAS,0BACtC,eAAO,YAAY,MAAM,IAAI,SAAS,uBACtC,eAAO,YAAY,MAAM,IAAI,SAAS,aACtC,eAAO,WAAW,UAAU,UAAU,SAAS,cAC/C,eAAO,WAAW,UAAU,UAAU,SAAS,cACjD;AAAA,EACF;AAAA,EAEA,wBACE,SACoB;AAzDxB;AA0DI,QAAI,QAAQ,eAAe,QAAW;AACpC,YAAM,IAAI,MAAM,0BAA0B;AAAA,IAC5C;AAEA,UAAM,SAAS,WAAK,aACjB,IAAI,QAAQ,WAAW,UAAU,MADrB,mBAEX,QAAQ,QAAQ,WAAW;AAC/B,QAAI,WAAW,QAAW;AACxB,YAAM,IAAI,MACR,0BAA0B,QAAQ,WAAW,YAC/C;AAAA,IACF;AAEA,UAAM,iBAAkB,OAAM;AAC5B,cAAQ,QAAQ,WAAW;AAAA,aACpB;AACH,iBAAO;AAAA,aACJ;AACH,iBAAO,OAAO;AAAA;AAEd,gBAAM,IAAI,MACR,0BAA0B,QAAQ,WAAW,YAC/C;AAAA;AAAA,IAEN,GAAG;AAEH,WAAO;AAAA,MACL,YAAY,eAAe;AAAA,MAC3B,kBAAkB,eAAe;AAAA,MACjC,iBAAiB,MAAM,eAAe,aAAa;AAAA,MACnD,WAAW,SAAS,eAAe,cAAc,IAAI,SAAS,eAAe,eAAe;AAAA,MAC5F,iBAAiB,SAAS,eAAe,eAAe;AAAA,IAC1D;AAAA,EACF;AACF;;;AC3FA,sBAA6B;AAQtB,IAAM,aAAN,cAAyB,aAAa;AAAA,EAU3C,aAAa,OACX,SACA,UACA,QACuB;AACvB,UAAM,kBAAkB,eAAO,YAAY,MAAM,IAAI;AACrD,QAAI,WAAW,QAAW;AACxB,sBAAgB,MAAM;AAAA,IACxB;AAEA,UAAM,QAAQ,IAAI,6BAAa,gBAAgB,GAAG;AAClD,UAAM,UAAU,MAAM,MAAM,IAAI,WAAW;AAC3C,QAAI,gBAAgB,YAAY,QAAQ,SAAS,GAAG;AAClD,YAAM,IAAI,MACR,4BAA4B,gBAAgB,mBAAmB,SACjE;AAAA,IACF;AAEA,WAAO,IAAI,WACT,OACA,eAAO,WAAW,UAAU,UAAU,aACtC,eAAO,WAAW,UAAU,UAAU,SAAS,SAC/C,eAAO,YAAY,MAAM,IAAI,SAAS,WACtC,eAAO,WAAW,UAAU,UAAU,SAAS,UAC/C,eAAO,YAAY,MAAM,IAAI,SAAS,aACtC,eAAO,YAAY,MAAM,IAAI,SAAS,0BACtC,eAAO,YAAY,MAAM,IAAI,SAAS,uBACtC,eAAO,YAAY,MAAM,IAAI,SAAS,aACtC,eAAO,WAAW,UAAU,UAAU,SAAS,cAC/C,eAAO,WAAW,UAAU,UAAU,SAAS,cACjD;AAAA,EACF;AAAA,EAEA,wBAAwB,SAAoE;AApD9F;AAqDI,QAAI,CAAC,QAAQ,YAAY;AACvB,YAAM,IAAI,MAAM,0BAA0B;AAAA,IAC5C;AAEA,UAAM,SAAS,WAAK,aAAa,IAAI,QAAQ,WAAW,UAAU,MAAnD,mBAAsD,QAAQ,QAAQ,WAAW;AAChG,QAAI,CAAC,QAAQ;AACX,YAAM,IAAI,MAAM,0BAA0B,QAAQ,WAAW,YAAY;AAAA,IAC3E;AAEA,UAAM,iBAAiB,KAAK,kBAAkB,QAAQ,WAAW,YAAY,MAAM;AAEnF,WAAO;AAAA,MAEL,YAAY,eAAe;AAAA,MAC3B,kBAAkB,eAAe;AAAA,MACjC,iBAAiB,MAAM,eAAe,aAAa;AAAA,MACnD,WAAW,SAAS,eAAe,cAAc,IAAI,SAAS,eAAe,eAAe;AAAA,MAC5F,iBAAiB,SAAS,eAAe,eAAe;AAAA,IAC1D;AAAA,EACF;AAAA,EAEA,AAAQ,kBAAkB,YAAoB,QAAa;AACzD,YAAQ;AAAA,WACD;AACH,eAAO;AAAA,WACJ;AACH,eAAO,OAAO;AAAA;AAEd,cAAM,IAAI,MACR,0BAA0B,YAC5B;AAAA;AAAA,EAEN;AACF;",
  "names": []
}
